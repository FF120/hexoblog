---
title: 算法专题_链表相关题目
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-07-26 18:46:20
---

各个在线OJ系统涉及到的链表相关的算法题目和分析解答。

<!-- more -->

## 删除

### 删除链表元素

删除链表节点为某个值的所有元素。

[删除链表中的元素](http://lintcode.com/zh-cn/problem/remove-linked-list-elements/)

```c
ListNode *removeElements(ListNode *head, int val) {
       // Write your code here
       ListNode *guard=new ListNode(0);
       guard->next = head;
       head = guard;

       ListNode *pre = guard;
       ListNode *tmp = guard->next;
       while(tmp){
           if(tmp->val == val){
               pre->next = tmp->next;
               tmp = tmp->next;
           }else{
               pre = tmp;
               tmp = tmp -> next;
           }

       }
       return head->next;
   }
```

不使用哨兵的方法，在要求不使用额外空间的时候可以用这种方法。

```c
ListNode *removeElements(ListNode *head, int val) {
       // Write your code here
       // 删除链表中等于给定值val的所有节点
       while(head && head->val == val){
           head = head->next;
       }
       if(head == nullptr) return head;
       ListNode *pre = head;
       ListNode *c = head->next; // 头结点已经不可能==val了，因为前面已经删除了
       while(c){
           if(c->val == val){
               pre->next = c->next;
               c->next= nullptr;
               c = pre->next;
           }else{
               pre = c;
               c = c->next;
           }
       }
       return head;
}
```

### O(1)时间删除链表元素

思路：给出要删除的节点，是不可能在O(1)的时间内删除该节点的，因为想要删除该节点，必须找到它前面的节点，这个操作只能从头遍历(在没有指向前面的指针的情况下)，复杂度不可能是O(1). 但是可以把要删除的节点后面的节点的值赋给要删除的节点，再删除要删除的节点后面的节点，这样'看起来'好像删除了当前的节点。实际上在计算机内存中真正的变化是要删除的节点的值变成了它后面节点的值.

[在O(1)时间复杂度删除链表节点](http://lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/)

```c
void deleteNode(ListNode *node) {
        // write your code here
        node->val = node->next->val;
        node->next = node->next->next;
}
```

### 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素每个元素只留下一个。

[删除排序链表中的重复元素](http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list/)

遇到不同的元素的时候再删除。

```c
ListNode *deleteDuplicates(ListNode *head) {
        // write your code here
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *pre = head;
        ListNode *current = head->next;
        while(current){
            if(pre->val == current->val){
                current = current->next;
            }else{
                pre->next = current;
                pre = current;
                current = current->next;
            }

        }
        // 链表结尾有重复元素的情况
        pre->next = current;
        return head;
}
```

一旦遇到相同的元素就删除。

```c
ListNode *deleteDuplicates(ListNode *head) {
        // 给定一个排序链表，删除所有重复的元素每个元素只留下一个。
        if(head == nullptr || head->next == nullptr) return head;
        if(head->next->next == nullptr && head->val == head->next->val) return head->next;
        ListNode *pre = head;
        ListNode *c = head->next;
        while(c){
            if(pre->val == c->val){
                pre->next = c->next;
                c = c->next;
            }else{
                pre = pre->next;
                c = c->next;
            }
        }
        return head;
}
```
### 删除排序链表中的重复元素2

给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。

[删除排序链表中的重复元素2](http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list-ii/)

```c
ListNode * deleteDuplicates(ListNode *head) {
       //给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。
       ListNode *guard = new ListNode(0);
       guard->next = head;
       head = guard;

       ListNode *pre = guard;
       ListNode *start = guard->next;
       ListNode *end = guard->next;
       while(end){
           while(end && start->val == end->val){
               end = end->next;
           }
           if(start->next == end){
               pre = start;
               start = end;
           }else{
               pre->next = end;
               start = end;
           }
       }
       return head->next;
}
```

不使用哨兵节点的方案

```c
ListNode * deleteDuplicates(ListNode *head) {
    //给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。
    ListNode *pre = head;
    ListNode *start = head;
    ListNode *end = head;
    while(end){
        while(end && start->val == end->val){
            end = end->next;
        }
        if(start->next == end){
            pre = start;
            start = end;
        }else{
            if(pre == start && pre == head){
                head = end;
                pre = end;
            }
            else    pre->next = end;
            start = end;
        }
    }
    return head;
}

```

### 删除单向链表中倒数第K个节点

例如：`head-->1-->2-->3-->4-->5-->6`  K=2
返回：`head-->1-->2-->3-->4-->6`

思路一： 先遍历一遍链表，统计链表有多少个元素。然后就可以知道倒数第K个元素就是
正数第n-k+1个元素，从head开始移动指针，移动n-k次就是要删除的节点。
删除一个节点，只需要把原来指向这个元素的指针指向它后面的元素就可以了。所以我们要做的
操作就是从head开始，移动n-k-1次，找到要删除的节点前面的节点a,然后执行a->next = a->next->next

```c
ListNode *removeNthFromEnd(ListNode *head, int n) {
    // write your code here
    int len = 0;
    ListNode *tmp = head;
    while(tmp){
        len ++;
        tmp = tmp->next;
    }
    if(len < n) return nullptr;
    if(len == n) return head->next;

    tmp = head;
    int count = len + 1 - n  ;// 正数第count个节点
    count = count - 2;
    while(count--){
        tmp = tmp->next;
    }
    tmp->next = tmp->next->next;
    return head;
}
```

思路二：使用两个间隔K个元素的指针遍历一遍链表，当前面的指针走到尾节点的时候，后面的节点指向的就是倒数第K个节点。

```c
ListNode *removeNthFromEnd(ListNode *head, int n) {
    // write your code here
    if(head == nullptr) return nullptr;
    ListNode *first = head;
    ListNode *second = head;
    int count = n + 1;
    while(first && count--){
        first = first->next;
    }
    if(first == nullptr) return head->next; // 删除第一个节点
    if(count > 0) return nullptr; // 没有导数第n个节点
    while(first){
        first = first->next;
        second = second->next;
    }
    second->next = second->next->next;
    return head;
}
```
### 删除双向链表的倒数第K个节点

双向链表删除某个节点，需要知道该节点前的节点或者该节点后面的节点
设a为要删除的节点的前一个节点，则删除后面的节点的方式是：
```c
a->next = a->next->next;
a->next->next->pre = a->next->pre;
```
设b为要删除的节点的后一个节点，则删除前面的节点的方式是：
```c
b->pre = b->pre->pre;
b->pre->pre->next = b;
```
如果双向链表是有首尾头节点的，直接从尾头结点开始计数即可。
如果没有尾头结点，处理方式可以参考单链表删除倒数第K个节点的方法。

```c

```

### 删除链表的中间节点

### 删除链表的a/b处的节点

## 查找

### 查找链表的中间节点

```c
/**
 * 找到链表的中间节点并返回
 * @param head
 * @return
 */
ListNode* findMiddle(ListNode* head){
    if(head == nullptr || head->next == nullptr) return head;
    ListNode *first = head, *second = head;
    while(second->next && second->next->next){
        first = first->next;
        second = second->next->next;
    }
    return first;
}
```

## 排序

### 插入排序（使用单链表实现）

```c
ListNode *insertionSortList(ListNode *head) {
    // 使用链表实现插入排序
    if(head == nullptr || head->next == nullptr) return head;

    ListNode *guard = new ListNode(INT32_MIN);
    guard->next = head;
    head = guard;

    ListNode *sorted = guard;
    ListNode *ends = guard->next;
    ListNode *unsorted = ends->next;
    ends->next = nullptr; // 链表断开
    while(unsorted){
        // 找到插入的位置
        while(sorted != ends){
            if(unsorted->val >= sorted->val && unsorted->val < sorted->next->val){
                // 插入到iter1后面
                ListNode *tmp = unsorted;
                unsorted = unsorted->next;
                tmp->next = sorted->next;
                sorted->next = tmp;
                sorted = guard;
                break;
            }
            sorted = sorted->next;
        }
        if(sorted == ends && unsorted->val >= ends->val){
            ends->next = unsorted;
            unsorted = unsorted->next;
            ends = ends->next;
            ends->next = nullptr;
            sorted = guard;
        }

    }
    return head->next;
}
```

### 快速排序(单链表实现)

快速排序一般的思想是首尾两个指针相向运动，但是单链表没有向前的指针，这要求我们换一种思路。如何从前往后遍历找到支点的位置。假设支点的值是value. 我们需要遍历一遍链表，使得所有小于value的值都在前面，所有大于value的值都在后面，这个时候就找到的value应该在的位置。

## 交换和翻转

### 交换链表当中两个节点

给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。

[交换链表当中两个节点](http://lintcode.com/zh-cn/problem/swap-two-nodes-in-linked-list/)

```c
ListNode* swapNodes(ListNode* head, int v1, int v2) {
    // Write your code here
    if(head==nullptr) return head;

    // add a guard
    ListNode *guard = new ListNode(0);
    guard->next = head;
    head = guard;

    //search the value
    ListNode *pre_v1=nullptr;
    ListNode *pre_v2=nullptr;
    ListNode *pre_tmp=guard;
    ListNode *tmp=pre_tmp->next;
    while(tmp){
        if(tmp->val==v1){
            pre_v1 = pre_tmp;
        }
        if(tmp->val==v2){
            pre_v2 = pre_tmp;
        }
        pre_tmp = tmp;
        tmp = tmp->next;
    }

    // not find v1 or v2
    if(pre_v1==nullptr || pre_v2==nullptr){
        return head->next;
    }

    // swap the two nodes
    ListNode *v1s = pre_v1->next;
    ListNode *v2s = pre_v2->next;
    ListNode *next_v1 = v1s->next;
    ListNode *next_v2 = v2s->next;

    if(pre_v1 == v2s){
        pre_v2->next = v1s;
        v1s->next = v2s;
        v2s->next = next_v1;
    }else if(pre_v2 == v1s){
        pre_v1->next = v2s;
        v2s->next = v1s;
        v1s->next = next_v2;
    }else{
        v1s->next = next_v2;
        v2s->next = next_v1;
        pre_v1->next = v2s;
        pre_v2->next = v1s;
    }

    return head->next;
}
```

### 两两交换链表中的节点

给一个链表，两两交换其中的节点，然后返回交换后的链表。

[两两交换链表中的节点](http://lintcode.com/zh-cn/problem/swap-nodes-in-pairs/)

```c
ListNode* swapPairs(ListNode* head) {
        // Write your code here
        if(head==nullptr || head->next==nullptr) return head;

        ListNode *guard = new ListNode(0);
        guard->next = head;
        head = guard;

        ListNode *pres1 = guard;
        ListNode *s1 = guard->next;
        ListNode *s2 = guard->next->next;
        while(s1!=nullptr && s2!=nullptr){
            pres1->next = s2;
            s1->next = s2->next;
            s2->next = s1;
            if(s1->next==nullptr || s1->next->next==nullptr){
                return head->next;
            }else{
                pres1 = s1;
                s1 = s1->next;
                s2 = s2->next->next->next;
            }
        }
        return head->next;
    }
```

### 翻转链表

[翻转链表](http://lintcode.com/zh-cn/problem/reverse-linked-list/)

```c
ListNode *reverse(ListNode *head) {
    // write your code here
    if(head==nullptr || head->next==nullptr) return head;
    ListNode *iter =head;
    ListNode *next_iter = head->next;

    iter->next=nullptr;
    while(next_iter){
        ListNode *tmp = next_iter->next;
        next_iter->next = iter;
        iter = next_iter;
        next_iter = tmp;
    }
    head = iter;
    return head;
}
```

### 翻转部分链表

[翻转链表 II](http://lintcode.com/zh-cn/problem/reverse-linked-list-ii/)

```c
/**
 * @param head a ListNode
 * @param val an integer
 * @return a ListNode
 */
ListNode *reverseBetween(ListNode *head, int m, int n) {
    // write your code here
    if(head == nullptr || m >= n || m < 1 || n < 1 ) return head;
    ListNode *pre = head, *pre_iter = head, *m_node = head, *n_node, *next, *iter=head;
    int count = 1;

    // find the m'th and n'th node
    while(iter){
        if(count == m){
            m_node = iter;
            pre = pre_iter;
        }
        if(count == n){
            n_node = iter; // 题目保证第n个节点不为空，所以这里不用判断了
            next = n_node->next;
            break;
        }
        pre_iter = iter;
        iter = iter->next;
        count ++;
    }
    // 翻转链表
    ListNode *tc = m_node->next, *tp = m_node, *tn;
    int cc = n - m ;
    while(cc--){
        tn = tc->next;
        tc->next = tp;
        tp = tc;
        tc = tn;
    }

    m_node->next = next;
    if(m_node == head ){
        head = n_node;
    }else{
        pre->next = n_node;
    }

    return head;
}
```

### K组翻转链表

```c
ListNode *reverseKGroup(ListNode *head, int k) {
    // Write your code here

    // add a guard
    ListNode *guard = new ListNode(0);
    guard->next = head;
    head = guard;

    ListNode *front = guard;
    ListNode *end = guard->next;
    while(end){
        int tmpk = 0;
        bool isk=false;
        while(true){
            if(end!=nullptr){
                tmpk++;
                end = end->next;
            }
            if(tmpk == k){
                isk = true;
                break;
            }else if(end==nullptr){
                isk = false;
                break;
            }
        }

        if(isk){
            // inverse the k link
            ListNode* iter = front->next;
            ListNode* next_iter = iter->next;
            iter->next = end;

            int countk = k-1;
            while(countk--){
                ListNode* tmp = next_iter->next;
                next_iter->next = iter;
                iter = next_iter;
                next_iter = tmp;
            }
            front->next = iter;

            countk = k;
            while(countk--){
                front = front->next;
            }
        }else{
            return head->next;
        }
    }
    return head->next;
}
```

### 旋转链表

[旋转链表](http://lintcode.com/zh-cn/problem/rotate-list/)

```c
ListNode *rotateRight(ListNode *head, int k) {
    //给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数
    if(head == nullptr || head->next == nullptr || k <= 0) return head;
    ListNode *end = head;
    int len = 1;
    while(end->next){
        end = end->next;
        len++;
    }
    k = k % len;
    if(k == 0) return head;
    int index = (len - 1 - k) % len;
    ListNode *tmp = head;
    while(tmp && index --){
        tmp = tmp->next;
    }
    if(index == -1){
        end->next = head;
        head = tmp->next;
        tmp->next = nullptr;
    }
    return head;
}
```

### 首尾交错重排链表

给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作。

[首位交错重排链表](http://lintcode.com/zh-cn/problem/reorder-list/)

```c
/**
 * 找到链表的中间节点并返回
 * @param head
 * @return
 */
ListNode* findMiddle(ListNode* head){
    if(head == nullptr || head->next == nullptr) return head;
    ListNode *first = head, *second = head;
    while(second->next && second->next->next){
        first = first->next;
        second = second->next->next;
    }
    return first;
}
/**
 * 反转链表
 * @param head
 * @return
 */
ListNode *reverse(ListNode *head) {
    // write your code here
    if(head==nullptr || head->next==nullptr) return head;
    ListNode *iter =head;
    ListNode *next_iter = head->next;
    iter->next=nullptr;
    while(next_iter){
        ListNode *tmp = next_iter->next;
        next_iter->next = iter;
        iter = next_iter;
        next_iter = tmp;
    }
    head = iter;
    return head;
}
/**
 * 交叉合并两个链表
 * @param l1
 * @param l2
 * @return
 */
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    // 如果其中一个链表为空，直接返回另外一个链表就是结果
    if(l1 == nullptr) return l2;
    if(l2 == nullptr) return l1;
    ListNode *head = l1;
    l1 = l1->next;
    ListNode *iter = head;
    bool odd = false;
    while(l1 != nullptr || l2 != nullptr){
        if(!odd){
            if(l2){
                iter->next = l2;
                l2 = l2->next;
                iter = iter->next;
            }
        }
        if(odd){
            if(l1){
                iter->next = l1;
                l1 = l1->next;
                iter = iter->next;
            }

        }
        odd = !odd;
    }
    return head;
}

ListNode* reorderList(ListNode *head) {
    if(head == nullptr || head->next == nullptr) return head;
    // 给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作
    // 找到中间节点， 反转后半段，然后交叉拼接起来，可以确保不适用额外的空间
    ListNode* middle = findMiddle(head);
    ListNode* head2 = reverse(middle->next);
    middle->next = nullptr;
    head = mergeTwoLists(head,head2);
    return head;
}
```

### 回文链表

判断一个链表中的值是否是回文

[]()

找到中间节点，把后面的链表反转，然后与前面的逐个节点比较，如果完全一样或者只有最后一个节点不一样，则是回文的。

```c
bool isPalindrome(ListNode* head) {
    // Write your code here
    if(head == nullptr) return true;
    ListNode *middle = findMiddle(head);
    ListNode *head2 = reverse(middle->next);
    middle->next = nullptr;
    ListNode *iter1 = head, *iter2 = head2;
    while(iter1 && iter2){
        if(iter1->val != iter2->val) return false;
        iter1 = iter1->next;
        iter2 = iter2->next;
    }
    if(iter1 && iter1->next == nullptr){
        return true;
    }
    if(iter2 && iter2->next == nullptr){
        return true;
    }
    if(iter1 == nullptr && iter2 == nullptr){
        return true;
    }
    return false;
}
```

### 打印两个有序单链表的公共部分（值相同的部分）

例如：a : `1-->2-->3-->4-->5`
      b : `10->3-->4-->20-->30`
打印 3-->4
思路： 因为是有序的链表，所以问题很简单。开始的时候l1 = head1;l2 = head2;
然后比较l1和l2指向的值的大小，谁小就向前移动谁，相等的话记录下来，最后一起打印出来。
如果是打印最长的公共部分，定义一个max变量，每次比较一下，最后打印那个最长的公共部分就行了。
```c

```




### 复杂链表的深度复制

[牛客网OJ](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```c
/**
 * 复杂链表的复制(牛客网-剑指offer)
 */
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};

RandomListNode* Clone(RandomListNode* pHead)
{
    // 克隆每一个节点链接在原来的节点后面
    if(pHead == nullptr) return nullptr;
    RandomListNode *iter = pHead;
    while(iter){
        RandomListNode *newNode = new RandomListNode(iter->label);
        newNode->next = iter->next;
        iter->next = newNode;
        iter = newNode->next;
    }

    // 链接随机指针
    iter = pHead;
    while(iter){
        if(iter->random){
            iter->next->random = iter->random->next;

        }
        iter = iter->next->next;
    }

    // 拆分出新的链表
    RandomListNode *newHead = pHead->next;
    RandomListNode *new_iter = newHead;
    iter = pHead;
    while(iter){
        iter->next = new_iter->next;
        iter = iter->next;
        if(iter){
            new_iter->next = iter->next;
            new_iter = new_iter->next;
        }
    }
    return newHead;
}
```

## 多个链表操作

### 交叉合并两个链表

```c
/**
 * 交叉合并两个链表
 * @param l1
 * @param l2
 * @return
 */
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    // 如果其中一个链表为空，直接返回另外一个链表就是结果
    if(l1 == nullptr) return l2;
    if(l2 == nullptr) return l1;
    ListNode *head = l1;
    l1 = l1->next;
    ListNode *iter = head;
    bool odd = false;
    while(l1 != nullptr || l2 != nullptr){
        if(!odd){
            if(l2){
                iter->next = l2;
                l2 = l2->next;
                iter = iter->next;
            }
        }
        if(odd){
            if(l1){
                iter->next = l1;
                l1 = l1->next;
                iter = iter->next;
            }

        }
        odd = !odd;
    }
    return head;
}
```

### 合并两个排序链表

[合并两个排序链表](http://lintcode.com/zh-cn/problem/merge-two-sorted-lists/)

```c
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    // write your code here
    ListNode* guard = new ListNode(0);
    ListNode* head = guard;
    while(l1 && l2){
        if(l1->val > l2->val){
            guard->next = l2;
            guard = guard->next;
            l2 = l2->next;
        }else{
            guard->next = l1;
            guard = guard->next;
            l1 = l1->next;
        }
    }
    if(l1){
        guard->next = l1;
    }
    if(l2){
        guard->next = l2;
    }
    return head->next;
}
```

### 合并K个排序链表

[合并k个排序链表](http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/)

```c
ListNode *mergeKLists(vector<ListNode *> &lists) {
    // write your code here
    ListNode* guard = new ListNode(0);
    ListNode* head = guard;

    // current 指向K个链表的头指针
    vector<ListNode*> currents;
    for(auto link : lists){
        if(link != nullptr)
            currents.push_back(link);
    }

    int index = 0;
    while(!currents.empty()){
        int minV = INT32_MAX;
        for(int i = 0; i < currents.size();++i){
            // 去掉已经为空的链表
            if(currents[i] == nullptr){
                currents.erase(currents.begin()+i);
            }
            if(currents[i]->val < minV){
                index = i;
                minV = currents[i]->val;
            }
        }
        guard->next = currents[index];
        guard = guard->next;
        if(currents[index]->next != nullptr)
            currents[index] = currents[index]->next;
        else
            currents.erase(currents.begin()+index);
    }
    return head->next;
}
```

### 使用链表求两个数的和

你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。

[链表求和](http://lintcode.com/zh-cn/problem/add-two-numbers/)

```c
ListNode *addLists(ListNode *l1, ListNode *l2) {
    if(l1 == nullptr) return l2;
    if(l2 == nullptr) return l1;
    // 链表求和
    int carry = 0;
    ListNode *head = new ListNode(0);
    ListNode *iter = head;
    int number;
    while(l1 != nullptr && l2 != nullptr){
        number = (l1->val + l2->val + carry ) % 10 ;
        carry = (l1->val + l2->val + carry ) / 10 ;
        ListNode *node = new ListNode(number);
        iter->next = node;
        iter = iter->next;
        l1 = l1->next;
        l2 = l2->next;
    }
    while(l1){
        number = (l1->val + carry) % 10;
        carry = (l1->val + carry) / 10;
        ListNode *node = new ListNode(number);
        iter->next = node;
        iter = iter->next;
        l1 = l1->next;

    }
    while(l2){
        number = (l2->val + carry) % 10;
        carry = (l2->val + carry) / 10;
        ListNode *node = new ListNode(number);
        iter->next = node;
        iter = iter->next;
        l2 = l2->next;
    }
    if(carry){
        ListNode *node = new ListNode(carry);
        iter->next = node;
    }
    return head->next;
}
```

### 链表求和2

假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。

[链表求和 II](http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#)

先翻转链表，求和，在翻转回去。

```c
ListNode *addLists2(ListNode *l1, ListNode *l2) {
    return reverse(addLists(reverse(l1),reverse(l2)));
}
```

