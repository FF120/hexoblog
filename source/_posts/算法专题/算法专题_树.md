---
title: 算法专题：树及相关的常见问题
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-09 17:33:46
---
树是没有环的图。树和链表、图都有关联。链表是树的一种特殊情况，而图都可以对应一棵生成树。学习完链表，学习树，然后学习图，是一个比较容易接受的过程。
<!-- more -->
## 二叉树

每个节点最多有两个子节点的树叫做二叉树。类型有：完全二叉树，满二叉树和完美二叉树。

### 二叉树的性质

- 二叉树的第i层节点数目至多是`2^(i-1); (i>=1)`
- 深度为K的二叉树至多有`2^(K-1)`个节点。
- 二叉树中出度为2的节点数目记作n2, 叶节点记作n0; 则有`n0 = n2 + 1`
- 深度为n的完美二叉树，其节点的数目是`2^n -1`, 叶节点数目是`2^(n-1)`, 非叶节点的数目是`2^(n-1)-1`
- 节点数目为n的完美二叉树，深度是`log2(n+1)`
- 节点数目为n的完全二叉树，深度是`[log2(n)] + 1`  其中[]表示向下取整

### 二叉树的操作


#### 结构的定义

二叉树的结构和双向链表比较相似，需要两个指针分别指向左孩子和右孩子。
```c++
class TreeNode {
public:
   int val;
   TreeNode *left, *right;
   TreeNode(int val) {
       this->val = val;
       this->left = this->right = nullptr;
   }
}
```

#### 创建

根据二叉树的前序遍历和中序遍历的结果创建二叉树，根据前序遍历序列和中序遍历序列可以唯一的确定一棵二叉树。
假设前序遍历的序列是pre; 中序遍历的序列是vin;里面都不含有重复数字；
首先确定根节点，肯定是pre[0], 然后在vin中寻找pre[0], 它前面的一定是左子树上的，后面的都是右子树上的。
假设pre[0]出现在vin[3],可以知道左子树上有三个节点，分别是vin[0],vin[1],vin[2], 在pre中从pre[0]以后数3个数字
这三个数字一定是位于左子树上的，剩下的属于右子树。
分别按照上面的方法递归处理左右子树，直到只剩下一个元素，返回答案；
举例来说，假设`pre = [1,2,4,7,3,5,6,8] `   `vin=[4,7,2,1,5,3,8,6]`
第一次： 可知1是根，2，4，7是1的左子树上的，3,5,6,8,是1的右子树上的。 分别处理序列`[2,4,7] [4,7,2]` 和` [3,5,6,8] [5,3,6,8]`
第二次： 对于`[2,4,7] [4,7,2]` 可以得到2是根，而4，7都是左子树上的， 接着处理`[4,7] [4,7]` 此时4是根，而7位于右子树上，这边处理完毕；
         对于`[3,5,6,8] [5,3,8,6]` 可以得到3是根，5是左子树上的，`[6,8]`是右子树上的。接着处理`[6,8][8,6]` 此时6是根，而8位于左子树上。

综合上面的分析，可以得到这个二叉树的形状如下：

![](construct_tree.svg)

```C++
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        if(pre.empty() || vin.empty()){return nullptr;}
        TreeNode* node = new TreeNode(pre[0]);// 先建立根节点
        int len = pre.size();
        for(size_t i=0;i<vin.size();++i){
            if(vin[i] == pre[0]){
                // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。
                vector<int> left_pre(i,0);
                vector<int> left_vin(i,0);
                vector<int> right_pre(len-1-i,0);
                vector<int> right_vin(len-1-i,0);
                copy(vin.begin(),vin.begin()+i,left_vin.begin());
                copy(vin.begin()+i+1,vin.end(),right_vin.begin());
                copy(pre.begin()+1,pre.begin()+1+i,left_pre.begin());
                copy(pre.begin()+i+1,pre.end(),right_pre.begin());
                node->left =  reConstructBinaryTree(left_pre,left_vin);
                node->right = reConstructBinaryTree(right_pre,right_vin);
            }

        }
        return node;
```
#### 遍历

##### 前序遍历(递归)

前序遍历就是按照`root->left->right`的顺序遍历二叉树
二叉树的遍历最方便的是使用递归函数，因为二叉树本身就是递归定义的，使用递归处理二叉树会比较方便。
**前序遍历遍历的步骤**：
1. 输出当前节点
2. 如果有左孩子，用左孩子做参数递归
3. 如果有右孩子，用由孩子做参数递归

```C++
 vector<int> preorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        re.push_back(root->val);
        if(root->left){
            vector<int> ll = preorderTraversal(root->left);
            re.insert(re.end(), ll.begin(), ll.end());
        }
        if(root->right){
            vector<int> rr = preorderTraversal(root->right);
            re.insert(re.end(), rr.begin(), rr.end());
        }
        return re;
    }
```

##### 前序遍历(非递归)

非递归的实现，递归函数的实现是使用堆栈的方式，所以把递归调用的函数改写成非递归的形式一般也是使用堆栈作为数据结构。

**前序遍历的非递归遍历步骤**

1. 输出当前的节点值，并把当前的节点压入栈
2. current = current->left;
循环以上步骤直到没有左孩子，执行下面的步骤
3. 取栈顶元素的右孩子，弹出栈顶元素，然后回到步骤1.

```c
//前序遍历的非递归实现
vector<int> preorderTraversal(TreeNode *root) {
	vector<int> re;
	 if(root == nullptr) return re;
	 stack<TreeNode*> s;
	 TreeNode *tmp = root;
	 while(tmp!=nullptr || !s.empty()){ // 逻辑或是短路的
		while(tmp!=nullptr){
			re.push_back(tmp->val);
			s.push(tmp);
			tmp = tmp->left;
		}
		// 循环退出说明没有了左孩子
		if(!s.empty()){
		   tmp = s.top();
		   s.pop();
		   tmp = tmp->right;
		}
	 }
	 return re;
}
```

##### 中序遍历(递归)

中序遍历就是按照`left->root->right`的数序遍历二叉树

**中序遍历遍历的步骤**

> 1. 如果当前的节点有左孩子，用左孩子作为参数递归
> 2. 输出当前节点
> 3. 如果当前节点有右孩子，用右孩子作为参数递归

```c
vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = inorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        re.push_back(root->val);
        if(root->right){
            vector<int> rr = inorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        return re;
    }
```

##### 中序遍历(非递归)

**中序遍历的非递归实现**

> 1. 对于当前的节点，放入堆栈，然后搜索有没有左孩子，一直向下搜索到没有左孩子为止。
> 2. 从堆栈取出栈顶元素，输出，然后搜索右孩子

```c
//中序遍历的非递归实现
vector<int> preorderTraversal(TreeNode *root) {
	 vector<int> re;
	 if(root == nullptr) return re;
	 stack<TreeNode*> s;
	 TreeNode *tmp = root;
	 while(tmp!=nullptr || !s.empty()){ // 逻辑或是短路的
		while(tmp!=nullptr){
			s.push(tmp);
			tmp = tmp->left;
		}
		// 循环退出说明没有了左孩子
		if(!s.empty()){
		   tmp = s.top();
		   re.push_back(tmp->val);
		   s.pop();
		   tmp = tmp->right;
		}
	 }
	 return re;
}
```

##### 后序遍历(递归)

后序遍历就是按照`left->right->root`的顺序遍历二叉树

**后序遍历遍历的步骤是**

> 1. 如果当前节点有左孩子，用左孩子作为参数递归
> 2. 如果当前节点有右孩子，用右孩子作为参数递归
> 3. 输出当前节点

```c
 vector<int> postorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = postorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        if(root->right){
            vector<int> rr = postorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        re.push_back(root->val);
        return re;
    }
```

##### 后序遍历(非递归)

**后序遍历的非递归实现**

第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。

```c
//后序遍历的非递归实现

```

第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。

```c

```

##### 层次遍历

二叉树的层次遍历类似与图的广度优先搜索，可以使用队列来实现。
思路是： 使用两个队列保存相邻两层的节点，循环输出每层的节点

**层次遍历遍历的步骤**

> 1. 初始化两个队列d1,d2;令d1保存root,d2为空
> 2. 清空d2,遍历d1中的节点，把d1中节点的所有孩子节点按照顺序放入d2中
> 3. 打印d1中的节点
> 4. 交换d1和d2;转到2
> 循环直到d2中为空，结束。

```c
// 从底向上层次遍历二叉树
 vector<vector<int>> levelOrderBottom(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        vector<TreeNode*> v1,v2;
        if(root == nullptr){
            return result;
        }
        v1.push_back(root);
        while(!v1.empty()){
            // 遍历v1中的所有节点，将下一层节点保存在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            vector<int> tmp;
            //打印v1
            for(int i=0;i<v1.size();i++){
                tmp.push_back(v1[i]->val);
            }
            result.insert(result.begin(),tmp);
            swap(v1,v2);
            v2.clear();
        }
        return result;
 }
```

```c
// 自顶向下遍历二叉树
 vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        if(!root) return result;
        vector<TreeNode*> v1,v2;
        v1.push_back(root);
        int level = 1;
        while(!v1.empty()){
            //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            // 打印v1中的节点,如果level 是奇数，则从左向又打印，
            // 如果level是偶数，则从右向左打印
            vector<int> tmp;
            if(level % 2 == 0){
                for(int i=v1.size()-1;i>=0;i--){
                    tmp.push_back(v1[i]->val);
                }
            }
            if(level % 2 ){
                for(int i=0;i<v1.size();i++){
                    tmp.push_back(v1[i]->val);
                }
            }
            result.push_back(tmp);
            // 更新该更新的数据
            swap(v1,v2);
            v2.clear();
            level++;
        }
        return result;
    }
```

#### 二叉树的最小深度

递归的方法：
```c
/**
 * Definition of TreeNode:
 * class TreeNode {
 * public:
 *     int val;
 *     TreeNode *left, *right;
 *     TreeNode(int val) {
 *         this->val = val;
 *         this->left = this->right = NULL;
 *     }
 * }
 */
class Solution {
public:
    /**
     * @param root: The root of binary tree.
     * @return: An integer
     */
    int minDepth(TreeNode *root) {
        // write your code here
        // 根节点不能算作叶子节点，所以此处要判断有没有左右节点
        if(root == nullptr) return 0;
        int maxDL = 1;
        int maxDR = 1;
        if(root->left == nullptr && root->right == nullptr){
            return 1;
        }
        if(root->left == nullptr){
            maxDL = 1000000;
        }
        if(root->right == nullptr){
            maxDR = 1000000;
        }
        if(root->left){
            maxDL += minDepth(root->left);
        }
        if(root->right){
            maxDR += minDepth(root->right);
        }
        return min(maxDL,maxDR);
    }
};
```

非递归的方法：

```c

```

####
#### 可视化

#### 插入、修改、删除

### 二叉树的应用

#### 哈夫曼编码

## 二叉查找树

由于红黑树本质上就是一棵二叉查找树，所以在了解红黑树之前，咱们先来看下二叉查找树。

二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

>- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
>- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
>- 任意结点的左、右子树也分别为二叉查找树。
>- 没有键值相等的结点（no duplicate nodes）。

因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn）.（至于n个结点的二叉树高度为lgn的证明，可参考算法导论 第12章 二叉查找树 第12.4节）。

但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。后面我们会看到一种基于二叉查找树-红黑树，它通过一些性质使得树相对平衡，使得最终查找、插入、删除的时间复杂度最坏情况下依然为O（lgn）。

**应用**

输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。

```c
// 思路：如果是二叉搜索树的后序遍历序列，那么最后一个一定是根，并且一定可以存在这样的关系：根前面的元素分成两部分，前一部分都比根小，后一部分都比根大，注意，这里前一部分和后一部分都可能为空。判断给出的序列是否满足这样的规律，然后分别递归判断左右两个分支。
bool bst(vector<int> &a,int l,int r){
       // 1. 找到第一个比根(r)小的元素，这里作为左右子树的分界
       if(l>=r) return true;
       int i=r-1;
       while(i>=l && a[i]>a[r]){
           --i;
       }
       // 此时i指向从后向前第一个小于a[r]的元素
       // 2. 检查从i到l的所有元素是否都小于a[r]
       int mid = i;
       while(i>=l){
           if(a[i] >= a[r]){
               return false;
           }
           i--;
       }
       // 此时 i应该等于l-1
       // 3. 划分出左右子树并且确保符合二叉搜索树的要求，递归左右子树，看是否符合要求
       return bst(a,l,mid) && bst(a,mid+1,r-1);

   }
   bool VerifySquenceOfBST(vector<int> sequence) {
   if(sequence.empty()) return false;
       return bst(sequence,0,sequence.size()-1);
   }
```
## 平衡二叉树
## AVL树
## 红黑树
参考文章：http://blog.csdn.net/chenhuajie123/article/details/11951777
红黑树，本质上来说就是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)

红黑树的性质：

> 1. 每个结点要么是红的，要么是黑的。
> 2. 根结点是黑的。
> 3. 每个叶结点（叶结点即指树尾端NIL指针或NULL结点）是黑的。
> 4. 如果一个结点是红的，那么它的俩个儿子都是黑的。
> 5. 对于任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

红黑树的示例：

![2017-04-11_094148.png](2017-04-11_094148.png)

## B树

## B+树

## Trie树

## 堆

堆是节点上的值有大小顺序的树。大根堆是根的元素最大，孩子节点的值都要小于父亲节点的值。小
根堆是根节点的值最小，孩子节点的值都要大于父亲节点的值。

堆的优点：

> 查找最大或最小元素很快
> 插入或删除一个元素之后能很快调整好堆，保持最大堆或最小堆的结构

堆常用来实现[优先队列]()。最大堆和最小堆的例子：

![2017-04-11_091249.png](2017-04-11_091249.png)

### 堆结构的定义

数据结构中最常使用的是二叉堆，就是每个节点最多有两个孩子节点。二叉堆就是节点有序的二叉树。
```c
class HeapNode {
public:
    int val;
    HeapNode *left, *right;
    HeapNode(int val) {
        this->val = val;
        this->left = this->right = nullptr;
    }
};
```

因为二叉堆就是节点有序的二叉树，所以堆的结构和二叉树的结构是一样的。对的存储亦可以使用数组，就像二叉树的存储那样。

### 堆的调整

每次在堆插入和删除元素的时候，都会破坏堆原有的有序性，需要调整堆。我们以大根堆为例来说明如何调整。

**插入元素**

在堆的末尾插入一个元素，然后搜索该元素的父亲节点，如果父亲节点小于自己，交换位置，继续向上，直到调整到根节点。

### 堆的应用

#### 堆排序

堆排序的基本思想是利用堆这种结构维护数据的有序性。首先用所有的数据初始化一个堆。然后从堆顶开始，把无序的数字和堆最后的数字交换，重新调整堆。
如此循环直到整个堆都有序。

#### 找出前K个最大的数字

思想：在一个很大的无序数组里面选择前k个最大（最小）的数据，最直观的做法是把数组里面的数据全部排好序，然后输出前面最大（最小）的k个数据。但是，排序最好需要O(nlogn)的时间，而且我们不需要前k个最大（最小）的元素是有序的。这个时候我们可以建立k个元素的最小堆(得出前k个最大值)或者最大堆(得到前k个最小值)，我们只需要遍历一遍数组，在把元素插入到堆中去只需要logk的时间，这个速度是很乐观的。利用堆得出前k个最大（最小）元素特别适合海量数据的处理。

我们可以先创建一个大小为k的数据容器来存储最小的k个数字。接下来我们每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器中已有k个数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。我们找出这已有的k个数中最大值，然和拿这次待插入的整数和这个最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换替换当前已有的最大值；如果带插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，因为我们容器内已经有k个数字比它小了，于是我们可以抛弃这个整数。

因此当容器满了之后，我们要做三件事情：一是在k个整数中找到最大数，二是有可能在这个容器中删除最大数，三是可能要插入一个新的数字，并保证k个整数依然是排序的。如果我们用一个二叉树来实现这个数据容器，那么我们能在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。

我们可以选择用不同的二叉树来实现这个数据容器。由于我们每次都需要找到k个整数中的最大数字，我们很容易想到用最大堆。在最大堆中，根结点的值总是大于它的子树中任意结点的值。于是我们每次可以在O(1)得到已有的k个数字中的最大值，但需要O(logk)时间完成删除以及插入操作。

我们自己从头实现一个最大堆需要一定的代码。我们还可以采用红黑树来实现我们的容器。红黑树通过把结点分为红、黑两种颜色并根据一些规则确保树是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要O(logk)。在STL中set和multiset都是基于红黑树实现的。如果面试官不反对我们用STL中的数据容器，我们就直接拿过来用吧。下面是基于STL中的multiset的参考代码

```c
typedef multiset<int, greater<int> >            intSet;
typedef multiset<int, greater<int> >::iterator  setIterator;

void GetLeastNumbers(const vector<int>& data, intSet& leastNumbers, int k)
{
    leastNumbers.clear();

    if(k < 1 || data.size() < k)
        return;

    vector<int>::const_iterator iter = data.begin();
    for(; iter != data.end(); ++ iter)
    {
        if((leastNumbers.size()) < k)
            leastNumbers.insert(*iter);

        else
        {
            setIterator iterGreatest = leastNumbers.begin();

            if(*iter < *(leastNumbers.begin()))
            {
                leastNumbers.erase(iterGreatest);
                leastNumbers.insert(*iter);
            }
        }
    }
}
```
## 线段树

线段树是一棵二叉树，他的每个节点包含了两个额外的属性`start`和`end`用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:

根节点的 `start` 和 `end` 由 `build` 方法所给出。
对于节点 A 的左儿子，有 `start=A.left, end=(A.left + A.right) / 2`。
对于节点 A 的右儿子，有 `start=(A.left + A.right) / 2 + 1, end=A.right`。
如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。
实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间` [start, end] `的线段树，返回这棵线段树的根。

线段树(又称区间树), 是一种高级数据结构，他可以支持这样的一些操作:

> - 查找给定的点包含在了哪些区间内
> - 查找给定的区间包含了哪些点

样例:
比如给定start=1, end=6，对应的线段树为：

```c
               [1,  6]
             /        \
      [1,  3]           [4,  6]
      /     \           /     \
   [1, 2]  [3,3]     [4, 5]   [6,6]
   /    \           /     \
[1,1]   [2,2]     [4,4]   [5,5]
```

### 线段树结构的定义

```c
Definition of SegmentTreeNode:
  class SegmentTreeNode {
  public:
      int start, end;
      SegmentTreeNode *left, *right;
      SegmentTreeNode(int start, int end) {
          this->start = start, this->end = end;
          this->left = this->right = NULL;
      }
  }
```
### 线段树的构造
```c
class Solution {
public:
    /**
     *@param start, end: Denote an segment / interval
     *@return: The root of Segment Tree
     */
    SegmentTreeNode * build(int start, int end) {
         // write your code here
        if(start > end)
            return nullptr;
        SegmentTreeNode *node = new SegmentTreeNode(start,end);
        if( start < end ) {
            node->left = build(node->start,(node->start+node->end)/2);
            node->right = build((node->start+node->end)/2+1,node->end);
        }
        return node;
    }
};
```
### 线段树的查询
```c
class Solution {
public:
    /**
     *@param root, start, end: The root of segment tree and
     *                         an segment / interval
     *@return: The maximum number in the interval [start, end]
     */
    int query(SegmentTreeNode *root, int start, int end) {
        // write your code here
        // 区间比根区间还大的情况
        if(start <= root->start && end >= root->end){
            return root->max;
        }
        //如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域
        //返回不影响计算最大值的数字
        if(start>root->end || end < root->start){
            return 0;
        }

        int ll = query(root->left,start,end);
        int rr = query(root->right,start,end);
        return max(ll,rr);

    }
};
```
### 线段树的更新
```c
void modify(Node *root, int idx){
        if (root == NULL)
        {
            return;
        }
        if (root->start == root->end && root->start == idx)
        {
            ++(root->cnt);
            return;
        }
        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= idx)
        {
            modify(root->left, idx);
        }
        else
        {
            modify(root->right, idx);
        }
        root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
    }
```

## 树状数组
树状数组是一个能够快速完成下术操作的数据结构：
> 给定一个初始值全为0的数列，a1,a2,a3,a4,...an
> - 给定i,计算a1+a2+...+ai
> - 给定i和x,计算ai = ai + x;

上面提到的线段树其实已经满足了上面的要求，只不过有些(大材小用了)。可以用更简单的结构实现这个要求。
![2017-04-12_161624.png](2017-04-12_161624.png)
把线段树所有的右节点去掉，只剩下左节点，然后对应的位置不变，投射到最下面一行，就形成了树状数组的结构。例如8个元素的树状数组的结构是：

|A[1]|A[2]|A[3]|A[4]|A[5]|A[6]|A[7]|A[8]|
|---|---|---|---|---|---|---|---|---|
|1|[1,2]|3|[1,4]|5|[5,6]|7|[1,8]|
|0001|0010|0011|0100|0101|0110|0111|1000|

有了上面的结构，如果想求`c[3]+c[4]+c[5]`就是`A[4]-A[2]+A[5]`;
如果想求`c[4]`,就是`A[4]-A[3]-A[2]`; 总之，一个区间内的和总可以在常数时间内通过树状数组中的值求出来。树状数组可以使用位来保存，通过寻找其中的规律，可以使用简单的位操作实现树状数组的求和和更新。上面表格的最后一行是对树状数组A进行的二进制的编码。
求树状数组的前i项和：

|i|表达式|二进制表示|
|--|--|--|
|1|A[1]|0001|
|2|A[2]|0010|
|3|A[3]+A[2]|0011+0010|
|4|A[4]|0100|
|5|A[5]+A[4]|0101+0100|
|6|A[6]+A[4]|0110+0100|
|7|A[7]+A[6]+A[4]|0111+0110+0100|
|8|A[8]|1000|

从二进制当中寻找规律，求前i项：
> 1. 初始化sum=0;
> 2. 从树状数组A[i]开始，把A[i]加入到结果中去。然后从i中减去i最低位1对应的数字。i的最低位的1对应的数字的值的大小可以用`i&(-i)`求得。
> 3. 直到i的结果为0停止。

按照上面的步骤分析上面表格中的每一行的求解：
>- 0001减去最后一位二进制1对应的数字（1）之后为0，所以最后结果是A[1]
>- 0010减去最后一位二进制1对应的数字(2)之后为0，所以最后的结果是A[2]
>- 0011减去最后以为二进制1对应的数字(1)之后为(0010,A[2]),而0010减去最后一位二进制1对应的数字(2)之后为0,所以最后的结果是A[3]+A[2]
>- 0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[4]
>- 0101减去最后以为二进制1对应的数字(1)之后为0100,0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[5]+A[4]
>- 0110 = 0110 + 0100 = A[6] + A[4]
>- 0111 = 0111 + 0110 + 0100 + A[7] + A[6] + A[4]
>- 1000 = 1000 = A[8]

上面就是BIT数组求和的详细解释，了解了这个过程，在知道如何求解一个数字最低位1对应的值，实现BIT的求和应该不难。下面看看BIT如何更新。
假如我们想更新c[2]的值，那么A中所有包含c[2]的值都可能发生变化，到底哪些值包含c[2]呢？从上面的表格我们看出，包含c[2]的A元素有A[2],A[4],A[8];下面再列一个表格，显示每个元素的更新都涉及哪些元素，这样就比较容易找到其中的规律。

|更新的值|涉及的BIT|二进制表示|
|--|--|--|
|c[1]|A[1],A[2],A[4],A[8]|0001,0010,0100,1000|
|c[2]|A[2],A[4],A[8]|0010,0100,1000|
|c[3]|A[3],A[4],A[8]|0011,0100,1000|
|c[4]|A[4],A[8]|0100,1000|
|c[5]|A[5],A[6],A[8]|0101,0110,1000|
|c[6]|A[6],A[8]|0110,1000|
|c[7]|A[7],A[8]|0111,1000|
|c[8]|A[8]|1000|

可以看到，更新的时候和求和的时候顺序似乎相反，规律是：如果要更新c[i],那么就从i开始，更新A[i]之后将i更新为`i = i+(i&(-i))`,直到最后一个元素为止。因为无论更新哪个元素，最后一个元素包含所有值的和，所以必须更新最后一个元素。
`i&(-i)`是得到i的最后一位二进制1对应的数值的大小，然后加到i上，对比上面的表格。i的更新情况是：
> - 0001(1)-0001+0001(2)-0010+0010(4)-0100+0100(8)=1000 停止
> - 0010(2)-0010+0010(4)-0100+0100(8)=1000 停止
> - 0011(3)-0011+0001(4)-0100+0100(8)=1000 停止
> - 0100(4)-0100+0100(8)=1000 停止
> - 0101(5)-0101+0001(6)-0110+0010(8)=1000 停止
> - 0110(6)-0110+0010(8)=1000 停止
> - 0111(7)-0111+0001(8)=1000 停止
> - 1000(8) = 1000 停止

树状数组的实现：
```c
#include <iostream>
#include <vector>
using namespace std;
class BIT{
public:
    vector<int> v;
    int n;
    BIT(){}
    // 构建n个元素的空树状数组
    BIT(int num){
        n = num+1; // v[0]不用，下标从1开始。
       for(int i=0;i<n;i++){
           v.push_back(0);
       }
    }
    //求前i项的和
    int sum(int i){
        int s = 0;
        while(i>0){
            s += v[i];
            i -= i & (-i);
        }
        return s;
    }
    //第i 项加上x
    void add(int i,int x){
        while(i<=n){
           v[i] += x;
            i += i&(-i);
        }
    }
    //根据传入的数组c构建它的树状数组
    void create(vector<int> &c){
        for(int i=0;i<c.size();i++){
            add(i+1,c[i]);
        }
    }

};
void printV(vector<int> a){
    for(auto aa:a){
        cout<<aa<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> c = {3,7,6,5,4,2,8,1};
    BIT *b = new BIT(c.size());
    b->create(c);
    printV(b->v);
    b->add(8,10);
    printV(b->v);
    b->add(1,1);
    printV(b->v);
    return 0;
}
```

运行结果：
```
0 3 10 6 21 4 6 8 36
0 3 10 6 21 4 6 8 46
0 4 11 6 22 4 6 8 47
```
可以看到，树状数组仅仅使用位操作就可以实现求和和更新，比线段树的开销要少很多，所以，一些能用树状数组解决的问题，不宜使用线段树。

参考博文：
http://www.cnblogs.com/wuwangchuxin0924/p/5921130.html
http://www.cnblogs.com/GeniusYang/p/5756975.html

## 并查集
前面的数据结构都是使用一棵树实现的，下面介绍使用多棵树维护的数据结构-并查集。
并查集可以高效的维护数据的分组信息，并可以快速完成以下操作：
> - 查询元素a和元素b是否属于同一个组
> - 合并元素a和元素b所在的组

并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。
