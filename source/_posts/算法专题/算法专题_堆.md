---
title: 算法专题_堆
toc: true
categories:
  - 算法
tags:
  - ACM
  - 堆
date: 2017-07-23 00:10:56
---

堆是节点上的值有大小顺序的树。大根堆是根的元素最大，孩子节点的值都要小于父亲节点的值。小
根堆是根节点的值最小，孩子节点的值都要大于父亲节点的值。

堆的优点：

> - 查找最大或最小元素很快
> - 插入或删除一个元素之后能很快调整好堆，保持最大堆或最小堆的结构

<!--more-->

堆常用来实现[优先队列]()。最大堆和最小堆的例子：

![2017-04-11_091249.png](2017-04-11_091249.png)

## 堆结构的定义

数据结构中最常使用的是二叉堆，就是每个节点最多有两个孩子节点。二叉堆就是节点有序的二叉树。

```c
class HeapNode {
public:
    int val;
    HeapNode *left, *right;
    HeapNode(int val) {
        this->val = val;
        this->left = this->right = nullptr;
    }
};
```

因为二叉堆就是节点有序的二叉树，所以堆的结构和二叉树的结构是一样的。对的存储亦可以使用数组，就像二叉树的存储那样。

## 堆的调整

每次在堆插入和删除元素的时候，都会破坏堆原有的有序性，需要调整堆。我们以大根堆为例来说明如何调整。

**插入元素**

在堆的末尾插入一个元素，然后搜索该元素的父亲节点，如果父亲节点小于自己，交换位置，继续向上，直到调整到根节点。

## 堆的应用

### 堆排序

堆排序的基本思想是利用堆这种结构维护数据的有序性。首先用所有的数据初始化一个堆。然后从堆顶开始，把无序的数字和堆最后的数字交换，重新调整堆。
如此循环直到整个堆都有序。

### 找出前K个最大的数字

思想：在一个很大的无序数组里面选择前k个最大（最小）的数据，最直观的做法是把数组里面的数据全部排好序，然后输出前面最大（最小）的k个数据。但是，排序最好需要O(nlogn)的时间，而且我们不需要前k个最大（最小）的元素是有序的。这个时候我们可以建立k个元素的最小堆(得出前k个最大值)或者最大堆(得到前k个最小值)，我们只需要遍历一遍数组，在把元素插入到堆中去只需要logk的时间，这个速度是很乐观的。利用堆得出前k个最大（最小）元素特别适合海量数据的处理。

我们可以先创建一个大小为k的数据容器来存储最小的k个数字。接下来我们每次从输入的n个整数中读入一个数。如果容器中已有的数字少于k个，则直接把这次读入的整数放入容器之中；如果容器中已有k个数字了，也就是容器已满，此时我们不能再插入新的数字而只能替换已有的数字。我们找出这已有的k个数中最大值，然和拿这次待插入的整数和这个最大值进行比较。如果待插入的值比当前已有的最大值小，则用这个数替换替换当前已有的最大值；如果带插入的值比当前已有的最大值还要大，那么这个数不可能是最小的k个整数之一，因为我们容器内已经有k个数字比它小了，于是我们可以抛弃这个整数。

因此当容器满了之后，我们要做三件事情：一是在k个整数中找到最大数，二是有可能在这个容器中删除最大数，三是可能要插入一个新的数字，并保证k个整数依然是排序的。如果我们用一个二叉树来实现这个数据容器，那么我们能在O(logk)时间内实现这三步操作。因此对于n个输入数字而言，总的时间效率就是O(nlogk)。

我们可以选择用不同的二叉树来实现这个数据容器。由于我们每次都需要找到k个整数中的最大数字，我们很容易想到用最大堆。在最大堆中，根结点的值总是大于它的子树中任意结点的值。于是我们每次可以在O(1)得到已有的k个数字中的最大值，但需要O(logk)时间完成删除以及插入操作。

我们自己从头实现一个最大堆需要一定的代码。我们还可以采用红黑树来实现我们的容器。红黑树通过把结点分为红、黑两种颜色并根据一些规则确保树是平衡的，从而保证在红黑树中查找、删除和插入操作都只需要O(logk)。在STL中set和multiset都是基于红黑树实现的。如果面试官不反对我们用STL中的数据容器，我们就直接拿过来用吧。下面是基于STL中的multiset的参考代码

```c
typedef multiset<int, greater<int> >            intSet;
typedef multiset<int, greater<int> >::iterator  setIterator;

void GetLeastNumbers(const vector<int>& data, intSet& leastNumbers, int k)
{
    leastNumbers.clear();

    if(k < 1 || data.size() < k)
        return;

    vector<int>::const_iterator iter = data.begin();
    for(; iter != data.end(); ++ iter)
    {
        if((leastNumbers.size()) < k)
            leastNumbers.insert(*iter);

        else
        {
            setIterator iterGreatest = leastNumbers.begin();

            if(*iter < *(leastNumbers.begin()))
            {
                leastNumbers.erase(iterGreatest);
                leastNumbers.insert(*iter);
            }
        }
    }
}
```
