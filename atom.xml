<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FEI&#39;s Blog</title>
  <subtitle>Talents come from diligence, and knowledge is gained by accumulation.</subtitle>
  <link href="/hexoblog/atom.xml" rel="self"/>
  
  <link href="http://ff120.github.io/hexoblog/"/>
  <updated>2017-10-08T08:41:12.076Z</updated>
  <id>http://ff120.github.io/hexoblog/</id>
  
  <author>
    <name>FF120</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大数据基础框架</title>
    <link href="http://ff120.github.io/hexoblog/2017/10/06/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%9F%BA%E7%A1%80%E6%A1%86%E6%9E%B6/"/>
    <id>http://ff120.github.io/hexoblog/2017/10/06/大数据基础框架/</id>
    <published>2017-10-06T12:21:59.000Z</published>
    <updated>2017-10-08T08:41:12.076Z</updated>
    
    <content type="html"><![CDATA[<p>大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。</p>
<a id="more"></a>
<h2 id="hdfs">HDFS</h2>
<p><code>hadoop distributed file system (HDFS)</code> 是脱胎于<code>google file system</code>的一个分布式文件系统,据说，其性能并没有达到GFS的水平，只是根据谷歌论文的原理的一个开源实现版本。 HDFS的特定有以下几点：</p>
<ol style="list-style-type: decimal">
<li>同时保存多个副本(默认三个)，提供容错机制，副本丢失能够自动恢复。</li>
<li>运行在不可靠机器上(廉价机器上)</li>
<li>适合大数据的处理，HDFS默认将文件分成64M大小的block, 将block按照键值对的方式存储在HDFS上。将映射关系保存在内存中。</li>
</ol>
<h3 id="hdfs的构成">HDFS的构成</h3>
<p><code>HDFS</code>是主从结构(<code>master/slave</code>结构)，主要由<code>NameNode</code>和<code>DataNode</code>组成。<code>NameNode</code> 是Master节点，负责整个系统的结构信息和调度控制，<code>DataNode</code>是slave节点，负责存储数据。除此之外，一般还有一个<code>SecondaryNameNode</code>节点，是<code>NameNode</code>节点的备份，负责承担一部分<code>NameNode</code>的工作，定时备份<code>NameNode</code>的数据，当<code>NameNode</code>出现故障的时候，可以从<code>SecondaryNameNode</code>恢复数据。</p>
<ul>
<li>NameNode</li>
<li>DataNode</li>
</ul>
<h3 id="写文件操作">写文件操作</h3>
<div class="figure">
<img src="26162921-2de9d28df9b54fe6a97a6fd88f1cb03f.jpg" alt="HDFS写文件示意图">
<p class="caption">HDFS写文件示意图</p>
</div>
<p>如上图，该图表示一个win7系统的电脑要把一个100M的文件写入一个HDFS文件系统。该HDFS文件系统运行在一个Hadoop集群之上，集群拥有一个NameNode(NN)节点，8个DataNode(DN)节点，有三个机架(rack1,rack2,rack3), 全部在一个机房内。</p>
<ol style="list-style-type: decimal">
<li><p>client把文件分割程64M大小(HDFS文件系统的默认大小)，生成两个文件块，一个64M， 一个36M。</p></li>
<li><p>client向NameNode发送写文件的请求。</p></li>
<li><p>NameNode收到请求之后，查询自己数据中记录的整个HDFS文件系统的信息，确定这些数据写入哪些DataNode节点中，并且记录下该信息，返回该信息给请求的主机。</p></li>
</ol>
<blockquote>
<p>假设分配的情况如下：</p>
</blockquote>
<blockquote>
<ul>
<li>block1: host2,host1,host3</li>
<li>block2: host7,host8,host4</li>
</ul>
</blockquote>
<blockquote>
<p>分配DataNode节点的规则为： 如果client为DataNode节点，那么副本1存储在与client相同的节点上，副本2存储在不同机架的节点上，副本三存储在同副本2相同机架上的不同节点； 如果client不是DataNode节点，则副本1随机选择一个节点，副本2选择不同的机架，副本3同副本2的机架的不同节点。</p>
</blockquote>
<ol start="4" style="list-style-type: decimal">
<li><p>client根据收到的写入信息,把block1写入第一个主机host2, 整个写入过程是流式写入的，数据被分割策划那个64K的小数据包写入，每次写完64K，host2将自己刚刚得到的64K数据写入host1, host1得到64K之后写入host3, 实际上客户端只需要向host2写入一次数据，数据就可以有三个备份。当第一个block写完之后，host2,host1,host3向NameNode, host2向client发送信息说明数据已经写完。</p></li>
<li><p>client收到信息之后发送第二个block，过程和第一个block一样。</p></li>
<li><p>第二个block写完之后，数据彻底写完，写文件的过程就结束了。</p></li>
</ol>
<p>通过写文件的过程和不同副本的分配策略可以看出，挂掉一个节点设置整个机架都是没有关系的，总能从其他的地方找回这些丢失的数据。</p>
<h3 id="读文件操作">读文件操作</h3>
<div class="figure">
<img src="26163017-fc613879835c402886b75e0593ca52ed.jpg" alt="HDFS读取文件示意图">
<p class="caption">HDFS读取文件示意图</p>
</div>
<p>如图，win7客户端要从HDFS文件系统上读取一个100M大小的的文件，该文件在HDFS中有两个数据块组成:block1,block2.</p>
<ol style="list-style-type: decimal">
<li><p>client 向NameNode 发送读取文件的请求。</p></li>
<li><p>NameNode收到读取文件的请求，查询自己存储的元信息，返回block1和block2的存储位置： <code>block1: host2,host1,host3; block2: host7,host8,host4</code>;</p></li>
<li><p>客户端收到NameNode的消息，去机器host2读取block1,去机器host7读取block2,读取完成之后合并成一个完整的文件，整个读文件的过程就结束了。如果client位于DataNode内，则优先读取本机架上的数据。</p></li>
</ol>
<p>参考文献：<a href="http://www.cnblogs.com/laov/p/3434917.html" target="_blank" rel="external">HDFS读写原理</a></p>
<h2 id="mapreduce">MapReduce</h2>
<p>MapReduce 是一个计算框架，就是在特定的输入上产生特定的输出。输入和输出都是<code>&lt;key,val&gt;</code>这种键值对的形式。 Mapper就是对每个个体进行操作，不涉及个体之间的相互作用，例如转换格式，分割字符串等，这样Mapper这个阶段做的工作可以在许多机器上并行的执行， Reducer执行一些需要不同条目之间协同才能完成的操作，例如计数，求和，需要遍历所有的条目才能得到结果。Reducer任务会在不同的机器上传递结果，得到最终的结果之后再返回。</p>
<div class="figure">
<img src="x.png" alt="MapReduce运行机制">
<p class="caption">MapReduce运行机制</p>
</div>
<ol style="list-style-type: decimal">
<li><p>在执行Map计算之前，先要根据文件的大小和HDFS的配置情况进行分片(input split), 假设HDFS默认的block大小是64M，而本次任务的输入有3个文件，一个10M，一个70M，一个128M，则10M的文件会被分成一片，70M的文件会被分成两片，128M的文件也会被分成两片。 分片操作仅仅计算出一个分片的长度和每个分片对应的数据的索引位置，并不改变原来的数据。</p></li>
<li><p>执行程序中定义好的Map操作，Map在各个数据节点上独立的执行，相互之间没有影响。</p></li>
<li><p>combiner阶段：目的是在本地机器上执行reduce操作，把可以在本地机器上合并的结果先执行了，避免以后需要大量传输数据(机器之间传输数据 的开销往往是分布式系统最大的瓶颈). 例如求最大值，最小值和求和等操作，可以Map之后可以现在各个数据节点求出整个数据节点的最大值，作为一个结果输出，之后的reduce操作会大大减少结果的传输负担。</p></li>
<li><p>shuffle阶段： 将Mapper阶段的输出作为Reducer阶段的输入数据。</p></li>
<li><p>Reduce阶段： 执行用户编写的reduce函数，得出结果之后存储在HDFS文件系统之上。</p></li>
</ol>
<div class="figure">
<img src="1.png" alt="Map-Shuffle-Reduce过程解析">
<p class="caption">Map-Shuffle-Reduce过程解析</p>
</div>
<p>参考文献:<a href="http://www.cnblogs.com/sharpxiajun/p/3151395.html" target="_blank" rel="external">cnblogs</a></p>
<h2 id="spark">Spark</h2>
<h3 id="弹性分布式数据集rdd">弹性分布式数据集(RDD)</h3>
<p>Spark 底层存储数据的时候使用的是Hadoop的HDFS分布是文件系统，所以可以存储任何兼容Hadoop的数据源，例如Hbase. Spark 在逻辑上把数据存储在一个一个的RDD中，一个RDD可以看作一张表格，可以保存任何类型的数据。RDD是不可改变的，任何改变RDD的操作都会返回一个全新的RDD，spark的所有操作，在逻辑上都是针对RDD的操作。 RDD支持两种操作：transformation 和 action ，类似mapReduce中的Map 和 Reduce操作。</p>
<ul>
<li><p><strong>transformation</strong>: 对RDD执行一个变换，返回一个新的RDD。可用的操作有map,filter,flatMap, groupByKey, reduceByKey 等。</p></li>
<li><p><strong>action</strong>: 在该RDD对象上执行之前定义的所有操作(包括所有的transformation操作)， 返回计算的结果。 可用的操作有reduce, collect, count, first, countByKey 等。</p></li>
</ul>
<h3 id="wordcount-程序">WordCount 程序</h3>
<p>使用spark运行一个统计单词个数的程序十分简单，这个过程可以帮助我们了解spark是如何工作的。</p>
<p>读取文本文件并生成RDD，将RDD缓存在内存中，缓存的RDD不需要从头开始计算，如果RDD没有缓存，就算过后的RDD会被立刻丢弃，每次想要得到结果都需要从头开始计算。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* SimpleApp.scala */</span></div><div class="line"><span class="keyword">import</span> org.apache.spark.SparkContext</div><div class="line"><span class="keyword">import</span> org.apache.spark.SparkContext._</div><div class="line"><span class="keyword">import</span> org.apache.spark.SparkConf</div><div class="line"></div><div class="line">object SimpleApp &#123;</div><div class="line">  <span class="function">def <span class="title">main</span><span class="params">(args: Array[String])</span> </span>&#123;</div><div class="line">    val logFile = <span class="string">"YOUR_SPARK_HOME/README.md"</span> <span class="comment">// 应该是你系统上的某些文件</span></div><div class="line">    val conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"Simple Application"</span>)</div><div class="line">    val sc = <span class="keyword">new</span> SparkContext(conf)</div><div class="line">    val logData = sc.textFile(logFile, <span class="number">2</span>).cache()</div><div class="line">    val numAs = logData.filter(line =&gt; line.contains(<span class="string">"a"</span>)).count()</div><div class="line">    val numBs = logData.filter(line =&gt; line.contains(<span class="string">"b"</span>)).count()</div><div class="line">    println(<span class="string">"Lines with a: %s, Lines with b: %s"</span>.format(numAs, numBs))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序仅仅是在 Spark README 中计算行里面包含 ‘a’ 和包含 ‘b’ 的次数.</p>
<h3 id="spark-框架的主要内容">Spark 框架的主要内容</h3>
<div class="figure">
<img src="spark-stack-new.png" alt="Spark生态系统">
<p class="caption">Spark生态系统</p>
</div>
<ul>
<li><p><code>spark streaming</code> : 基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</p></li>
<li><p><code>spark SQL</code> : 可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</p></li>
<li><p><code>spark mlib</code> : 是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</p></li>
<li><p><code>spark graphx</code> : 是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。</p></li>
<li><p><code>blinkDB</code> : 一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。</p></li>
<li><p><code>sparkR</code> : R语言的spark接口</p></li>
</ul>
<h2 id="hbase">HBASE</h2>
<p>HBase, Hadoop Database, 是Google Bigtable的开源实现，是一个面向列的，可伸缩的分布式存储系统，它的底层文件存储使用的是HDFS。</p>
<p><strong><code>HBase</code>的存储逻辑</strong></p>
<p>表由行和列组成，列被分组，若干个列组成一个列簇（row family）,表在定义的时候，就必须声明所有的列簇，但是列簇内包含几个列可以动态增加(这也体现了面向列的存储这一方面). 同一个列簇使用相同的前缀为其命名，例如<code>temperature:air</code> 和 <code>temperature:dew</code> 都是<code>temperature</code>列簇的成员, <code>HBase</code>的每个列簇称作一个<code>store</code>，同一个列簇的数据会存储在同一个目录下，可能会分割成多个文件存储。</p>
<p>每个行由一个键表示，行键是一个字节数组，行按照行键进行排序。</p>
<p>行列交叉的位置称作<code>Cell</code>，每个cell都有版本，以时间戳标识，这个标识可以自己定义。也就是说，Hbase中的每个数据都是有版本的，数据按照时间倒序排列，最新的数据排列在最前面。cell中的内容是字节数组，不带格式,HBase存储的数据都是无格式的。唯一的确定一个cell需要下面这些数据：row key(行键), column:label(列簇的前缀的列的名称)， version(版本号)， 行键用来确定是哪一行，column:label确定是哪一列，版本号确定是哪个版本的数据，这样可以唯一的确定一个单元格里的数据。</p>
<p>HBase自动把表格水平划分程若干region, 每个region都是连续的若干行数据(类似数据库的水平分割).</p>
<p><strong>HBase的物理存储结构</strong></p>
<p>一个Table最初只有一个Region,随这行的数量的增加，当超过一个既定的阈值的时候，Region就会等分为2个。 相同的Region保证存储在相同的机器上，不同的Region可以存储在不同的机器上，叫做region server。</p>
<p>每个Region存储的若干行和这些行的所有列。每个Region的内部存储是这样的：Region 由一个或者多个store组成，每个store存储一个列簇， 每个store包括一个memStore和0个或者多个storefile,storefile是存储的最小单位，以HFile的格式保存在HDFS文件系统上。</p>
<div class="figure">
<img src="QQ截图20171007212611.png" alt="HBase架构示意图">
<p class="caption">HBase架构示意图</p>
</div>
<p><strong>HBase的运行</strong></p>
<p>HBase 由一个主节点master和若干个RegionServer组成，主节点的负载较轻，主要负责引导初始安装，分配区域给已经注册的区域服务器，恢复区域服务器的故障等。 区域服务器负责自己存储的若干个区域的读写工作。</p>
<h2 id="hive">Hive</h2>
<p>hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。其优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，不必开发专门的MapReduce应用，十分适合数据仓库的统计分析</p>
<p>Hive是建立在 Hadoop 上的数据仓库基础构架。它提供了一系列的工具，可以用来进行数据提取转化加载（ETL），这是一种可以存储、查询和分析存储在 Hadoop 中的大规模数据的机制。Hive 定义了简单的类 SQL 查询语言，称为 HQL，它允许熟悉 SQL 的用户查询数据。同时，这个语言也允许熟悉 MapReduce 开发者的开发自定义的 mapper 和 reducer 来处理内建的 mapper 和 reducer 无法完成的复杂的分析工作</p>
<p>简单来讲，Hive提供了一种高级的类似SQL的语言，来执行一些以前必须要自己写Map,Reduce程序才能实现的功能，大大简化了数据处理的难度(MapReduce程序很难写)， 但是，Hive的实时性很差，适合离线处理，数据分析和数据挖掘等对实时性要求不高的任务。</p>
<h2 id="pig">Pig</h2>
<p>提供类似SQL的语言叫做<code>Pig Latin</code>, 可以把类SQL的语言转化程优化处理过的MapReduce运算。</p>
<p>Pig是一种大规模数据集的脚本语言，它实际上提供了一整套脚本语言的特性，用来处理海量的数据。</p>
<h2 id="zookeeper">Zookeeper</h2>
<p>Zookeeper的目的是提供一些工具集，用来建立安全处理局部故障的分布式应用。 使用Zookeeper, 我们可以更容易的自己实现一个分布式的应用。</p>
<p>参考文献:<a href="http://www.cnblogs.com/wuxl360/p/5817471.html" target="_blank" rel="external">1</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大数据系统最初由google公布的一篇论文引起，后来发展出hadoop和一系列工具，后来又有spark，本文介绍在大数据处理领域一些常用工具的基本原理。&lt;/p&gt;
    
    </summary>
    
      <category term="大数据" scheme="http://ff120.github.io/hexoblog/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
    
      <category term="HDFS" scheme="http://ff120.github.io/hexoblog/tags/HDFS/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_常见题目</title>
    <link href="http://ff120.github.io/hexoblog/2017/10/03/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE/"/>
    <id>http://ff120.github.io/hexoblog/2017/10/03/算法专题-常见题目/</id>
    <published>2017-10-03T03:06:18.000Z</published>
    <updated>2017-10-04T02:03:55.357Z</updated>
    
    <content type="html"><![CDATA[<p>【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】</p>
<a id="more"></a>
<h2 id="栈">栈</h2>
<h3 id="栈的压入弹出序列"><a href="https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106" target="_blank" rel="external">栈的压入弹出序列</a></h3>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPopOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pushV,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; popV)</span> </span>&#123;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="序列"><a href="http://lintcode.com/zh-cn/problem/132-pattern/#" target="_blank" rel="external">132序列</a></h3>
<p>Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list.</p>
<p>n will be less than 20,000.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find132pattern</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> third = INT32_MIN; <span class="comment">// 中间大的数</span></div><div class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        <span class="comment">// 如果找到小于第二大的数字，则小于第二大的数字，第二大的数字和最大的数字三个数字都找到，返回true;</span></div><div class="line">        <span class="keyword">if</span> (nums[i] &lt; third) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">// 如果当前数字大于栈顶元素，则找到了第二大的数字(栈顶元素)，最大的数字变成了当前数字</span></div><div class="line">            <span class="keyword">while</span> (!s.empty() &amp;&amp; nums[i] &gt; s.top()) &#123;</div><div class="line">                third = s.top(); s.pop();</div><div class="line">            &#125;</div><div class="line">        &#125; </div><div class="line">        s.push(nums[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="链表">链表</h2>
<h3 id="翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="external">翻转链表</a></h3>
<p>翻转一个链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">reverse</span><span class="params">(ListNode * head)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并k个链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="external">合并K个链表</a></h3>
<p>合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">      <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="复杂链表的复制"><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="external">复杂链表的复制</a></h3>
<p>给出一个链表，每个节点包含一个额外增加的随机指针可以指向链表中的任何节点或空的节点。</p>
<p>返回一个深拷贝的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表求和"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="external">链表求和</a></h3>
<p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">addLists2</span><span class="params">(ListNode * l1, ListNode * l2)</span> </span>&#123;</div><div class="line">      <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表的中间节点">链表的中间节点</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到链表的中间节点并返回</div><div class="line"> * @param head</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode *first = head, *second = head;</div><div class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二叉树">二叉树</h2>
<h3 id="前序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="external">前序遍历的非递归实现</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</div><div class="line">      <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="external">中序遍历的非递归实现</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode * root) &#123;</div><div class="line">       <span class="comment">// write your code here</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="后序遍历的非递归实现"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="external">后序遍历的非递归实现</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode * root) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树的最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/#" target="_blank" rel="external">二叉树的最大深度</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树的最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="external">二叉树的最小深度</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode * root)</span> </span>&#123;</div><div class="line">       <span class="comment">// write your code here</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="叶子之间的最长距离">叶子之间的最长距离</h3>
<h3 id="堆排序">堆排序</h3>
<h3 id="top-k">TOP K</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="external">数据流的中位数</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; medianII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快速排序">快速排序</h2>
<h3 id="第k大的数"><a href="http://lintcode.com/zh-cn/problem/kth-largest-element/" target="_blank" rel="external">第K大的数</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中位数"><a href="http://lintcode.com/zh-cn/problem/median/#" target="_blank" rel="external">中位数</a></h3>
<p>给定一个未排序的整数数组，找到其中位数。</p>
<p>中位数是排序后数组的中间值，如果数组的个数是偶数个，则返回排序后数组的第N/2个数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="归并排序">归并排序</h2>
<h3 id="数组的逆序对的个数"><a href="http://lintcode.com/zh-cn/problem/reverse-pairs/" target="_blank" rel="external">数组的逆序对的个数</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="字符串">字符串</h2>
<h3 id="kmp算法"><a href="http://lintcode.com/zh-cn/problem/strstr/" target="_blank" rel="external">KMP算法</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">strStr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">const</span> <span class="keyword">char</span> *target)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="字典树">字典树</h3>
<p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h3 id="哈夫曼编码">哈夫曼编码</h3>
<h2 id="一维数组">一维数组</h2>
<h3 id="出现一半以上的数">出现一半以上的数</h3>
<h3 id="数组跳跃能否达到终点">数组跳跃能否达到终点</h3>
<h2 id="大数据">大数据</h2>
<h3 id="布隆过滤器">布隆过滤器</h3>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【栈】【队列】【链表】【二叉树】【堆】【快速排序】【归并排序】【数组】【指针】&lt;/p&gt;
    
    </summary>
    
      <category term="算法专题" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>手写代码-其他</title>
    <link href="http://ff120.github.io/hexoblog/2017/09/27/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81-%E5%85%B6%E4%BB%96/"/>
    <id>http://ff120.github.io/hexoblog/2017/09/27/算法专题/手写代码-其他/</id>
    <published>2017-09-27T15:12:30.000Z</published>
    <updated>2017-10-03T02:58:41.346Z</updated>
    
    <content type="html"><![CDATA[<p>【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】</p>
<a id="more"></a>
<h3 id="二分查找">二分查找</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 不考虑重复元素</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> val)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = v.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> mid;</div><div class="line">    <span class="keyword">while</span>(i &lt;= j)&#123;</div><div class="line">       <span class="keyword">if</span>(v[mid] == val) <span class="keyword">return</span> mid;</div><div class="line">       <span class="keyword">if</span>(v[mid] &gt; val)&#123;</div><div class="line">           j = mid - <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(v[mid] &lt; val)&#123;</div><div class="line">         i = mid + <span class="number">1</span>;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 如果有重复的val,返回val的起始位置</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">binaryResearch</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> j = v.size() <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> mind;</div><div class="line">    <span class="keyword">while</span>(i &lt; j))&#123;</div><div class="line">      <span class="keyword">if</span>(v[mid] == val)&#123;</div><div class="line">        <span class="keyword">while</span>(v[mid] == val &amp;&amp; mid &gt;= <span class="number">0</span>)&#123;</div><div class="line">          mid--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p+<span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(v[mid] &gt; val)&#123;</div><div class="line">        j = mid - <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span>(v[mid] &lt; val)&#123;</div><div class="line">        i = mid + <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="冒泡排序">冒泡排序</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = v.size()<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;j;i++)&#123;</div><div class="line">            <span class="keyword">if</span>(v[i] &gt; v[i+<span class="number">1</span>]) swap(v[i],v[i+<span class="number">1</span>]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="单例模式">单例模式</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>&#123;</span></div><div class="line">    </div><div class="line">  <span class="keyword">private</span>:</div><div class="line">      <span class="keyword">static</span> Single* instance = null; <span class="comment">// 静态私有变量，属于类</span></div><div class="line">      Singleton()&#123;&#125;</div><div class="line">      Singleton(<span class="keyword">const</span> Singleton&amp;)&#123;&#125;</div><div class="line">      Singleton&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton&amp;)&#123;&#125; <span class="comment">// 防止赋值的时候拷贝</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">static</span> Singleton* getInstance() <span class="comment">// 静态方法，确保使用类可以调用</span></div><div class="line">      &#123;</div><div class="line">          <span class="keyword">if</span> (instance == <span class="literal">NULL</span>)&#123;</div><div class="line">             lock(); <span class="comment">// 线程安全的写法，如果不用确保线程安全，不需要</span></div><div class="line">             <span class="keyword">if</span>(instance == <span class="literal">NULL</span>)&#123;</div><div class="line">                 instance = <span class="keyword">new</span> Singleton();</div><div class="line">             &#125;</div><div class="line">             unlock();</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> instance;</div><div class="line">      &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>// 使用方法 <code>auto instance = Singleton::getInstance();</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_二叉树2</title>
    <link href="http://ff120.github.io/hexoblog/2017/09/23/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E6%A0%912/"/>
    <id>http://ff120.github.io/hexoblog/2017/09/23/算法专题/算法专题_二叉树2/</id>
    <published>2017-09-23T10:26:58.000Z</published>
    <updated>2017-10-03T13:04:43.870Z</updated>
    
    <content type="html"><![CDATA[<p>【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】</p>
<a id="more"></a>
<h3 id="前序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/" target="_blank" rel="external">前序遍历</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    TreeNode *left, *right;</div><div class="line">    TreeNode(<span class="keyword">int</span> val) &#123;</div><div class="line">        <span class="keyword">this</span>-&gt;val = val;</div><div class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">// 递归前序遍历</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorderTraversal(TreeNode * root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    re.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;left);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = preorderTraversal(root-&gt;right);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非递归前序遍历</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder(TreeNode* root)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    TreeNode* iter = root;</div><div class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</div><div class="line">        <span class="keyword">while</span>(iter)&#123;</div><div class="line">            <span class="comment">// 首先输出根</span></div><div class="line">            re.push_back(iter-&gt;val);</div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;</div><div class="line">        &#125;</div><div class="line">        iter = s.top();</div><div class="line">        s.pop();</div><div class="line">        iter = iter-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/" target="_blank" rel="external">中序遍历</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归中序遍历</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorderTraversal(TreeNode *root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;left);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    re.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = inorderTraversal(root-&gt;right);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 非递归中序遍历</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder(TreeNode* root)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</div><div class="line">    TreeNode* iter = root;</div><div class="line">    <span class="keyword">while</span>(iter || !s.empty())&#123;</div><div class="line">        <span class="keyword">while</span>(iter)&#123;</div><div class="line">            s.push(iter);</div><div class="line">            iter = iter-&gt;left;</div><div class="line">        &#125;</div><div class="line">        iter = s.top();</div><div class="line">        s.pop();</div><div class="line">        <span class="comment">// 输出</span></div><div class="line">        re.push_back(iter-&gt;val);</div><div class="line">        iter = iter-&gt;right;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/" target="_blank" rel="external">后序遍历</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 递归后序遍历</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postorderTraversal(TreeNode *root) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(root-&gt;left)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;left);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root-&gt;right)&#123;</div><div class="line">        <span class="keyword">auto</span> tmp = postorderTraversal(root-&gt;right);</div><div class="line">        re.insert(re.end(),tmp.begin(),tmp.end());</div><div class="line">    &#125;</div><div class="line">    re.push_back(root-&gt;val);</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 后序遍历的非递归实现</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; postOrder(TreeNode *root)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> re;</div><div class="line"></div><div class="line">    TreeNode *iter = root;</div><div class="line">    <span class="built_in">stack</span>&lt;TreeNode *&gt; s;</div><div class="line">    TreeNode *last = root;</div><div class="line">    s.push(iter);</div><div class="line">    <span class="keyword">while</span> (!s.empty())</div><div class="line">    &#123;</div><div class="line">        iter = s.top();</div><div class="line">        <span class="comment">// 1. 当前节点是叶节点(没有左右孩子)，输出</span></div><div class="line">        <span class="comment">// 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出</span></div><div class="line">        <span class="comment">// 3. 上次访问了当前节点的右孩子，输出</span></div><div class="line">        <span class="keyword">if</span>( (iter-&gt;left == <span class="literal">nullptr</span> &amp;&amp; iter-&gt;right == <span class="literal">nullptr</span>) ||</div><div class="line">                (iter-&gt;right == <span class="literal">nullptr</span> &amp;&amp; last == iter-&gt;left) ||</div><div class="line">                    (last == iter-&gt;right) )</div><div class="line">        &#123;</div><div class="line">            re.push_back(iter-&gt;val);</div><div class="line">            last = iter;</div><div class="line">            s.pop();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            <span class="comment">// 栈是后进先出的，要先处理左孩子，所以要先放入右耗资</span></div><div class="line">            <span class="keyword">if</span>(iter-&gt;right)</div><div class="line">                s.push(iter-&gt;right);</div><div class="line">            <span class="keyword">if</span>(iter-&gt;left)</div><div class="line">                s.push(iter-&gt;left);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树的路径搜索">二叉树的路径搜索</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 搜索根节点到叶子节点的所有路径 [http://lintcode.com/zh-cn/problem/binary-tree-paths/#]</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">binaryTreePaths</span><span class="params">(TreeNode *root,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;tmp)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</div><div class="line">        tmp.push_back(root-&gt;val);</div><div class="line">        vv.push_back(tmp);</div><div class="line">        tmp.clear();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        tmp.push_back(root-&gt;val);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp1(tmp);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp2(tmp);</div><div class="line">        <span class="keyword">if</span>(root-&gt;left) binaryTreePaths(root-&gt;left,tmp1);</div><div class="line">        <span class="keyword">if</span>(root-&gt;right) binaryTreePaths(root-&gt;right,tmp2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树最大深度"><a href="http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/" target="_blank" rel="external">二叉树最大深度</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 调用方式： maxDepth2(root,0)</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth2</span><span class="params">(TreeNode *root, <span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> maxDepth2(root-&gt;left,dep+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span>(root-&gt;right &amp;&amp; !root-&gt;left) <span class="keyword">return</span> maxDepth2(root-&gt;right,dep+<span class="number">1</span>);     </div><div class="line">    <span class="keyword">return</span> max(maxDepth2(root-&gt;left,dep+<span class="number">1</span>),maxDepth2(root-&gt;right,dep+<span class="number">1</span>));   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二叉树最小深度"><a href="http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#" target="_blank" rel="external">二叉树最小深度</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 最小深度 </span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">minDepth2</span><span class="params">(TreeNode* root,<span class="keyword">const</span> <span class="keyword">int</span> dep)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> dep;</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right) <span class="keyword">return</span> dep+<span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;left,dep+<span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)  <span class="keyword">return</span> minDepth2(root-&gt;right,dep+<span class="number">1</span>);</div><div class="line">    <span class="keyword">return</span> min(minDepth2(root-&gt;left,dep+<span class="number">1</span>),minDepth2(root-&gt;right,dep+<span class="number">1</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="叶子节点到叶子节点路径的搜索">叶子节点到叶子节点路径的搜索</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="built_in">vector</span>&lt;TreeNode*&gt;&gt; nodes; <span class="comment">// 存储树的结构</span></div><div class="line"><span class="built_in">map</span>&lt;TreeNode*,<span class="keyword">bool</span>&gt; visited;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* leaf,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</div><div class="line">    visited[leaf] = <span class="literal">true</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;TreeNode*&gt; tmp = nodes[leaf];</div><div class="line">    <span class="keyword">bool</span> is = <span class="literal">true</span>;</div><div class="line">    v.push_back(leaf-&gt;val);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;tmp.size();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(visited[tmp[i]] == <span class="literal">false</span>)&#123;</div><div class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1(v);</div><div class="line">            dfs(tmp[i],v1);</div><div class="line">            is = <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(is)&#123; <span class="comment">// 叶节点</span></div><div class="line">        vv.push_back(v);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="top-k-问题">top K 问题</h3>
<p>如果是最大的K个数，那么首先使用前K个数建立一个最小堆，然后从第K+1个数开始和堆顶的元素比较，如果大于堆顶的元素，就把堆顶的元素弹出，把该元素push进堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topk(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)&#123;</div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; heap; <span class="comment">// 最小堆（堆顶元素最小）</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</div><div class="line">        heap.push(v[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;v.size();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(v[i] &gt; heap.top())&#123;</div><div class="line">            heap.pop();</div><div class="line">            heap.push(v[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">while</span>(!heap.empty())&#123;</div><div class="line">        re.push_back(heap.top());</div><div class="line">        heap.pop();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数据流的中位数"><a href="http://lintcode.com/zh-cn/problem/data-stream-median/" target="_blank" rel="external">数据流的中位数</a></h3>
<p>使用大顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt;&gt;</code>) 保存前半部分的数据，使用小顶堆(<code>priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;</code>) 保存后半部分的数据, 保证大顶堆的顶 小于等于 小顶堆的顶， 那么在每次需要求当前的数据的中位数的时候，只需要两个堆顶元素就可以求出来了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span> &#123;</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</div><div class="line">    priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> n;</div><div class="line">    <span class="keyword">bool</span> is_left;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    MedianFinder() &#123;</div><div class="line">        <span class="keyword">this</span>-&gt;n = <span class="number">0</span>;</div><div class="line">        <span class="keyword">this</span>-&gt;is_left = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">        <span class="comment">// 轮流加入左右两个堆</span></div><div class="line">        <span class="keyword">if</span>(is_left)&#123;</div><div class="line">            <span class="comment">// 如果right的堆为空，可以确保左边最大的小于等于右边最小的，直接加入</span></div><div class="line">            <span class="comment">// 如果要加入的元素小于等于right的堆顶，也可以保证上述条件</span></div><div class="line">            <span class="keyword">if</span>(minHeap.empty() || num &lt;= minHeap.top())&#123;</div><div class="line">                maxHeap.push(num);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果num &gt; minHeap.top(); 不能直接加入maxHeap,因为如果这样做，就不能保证maxHeap中的所有的数字都小于等于minHeap中的数字。</span></div><div class="line">            <span class="comment">// 这个时候的做法是， 先把num加入minHeap, 在把minHeap.top()弹出，加入maxHeap;</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                minHeap.push(num);</div><div class="line">                maxHeap.push(minHeap.top());</div><div class="line">                minHeap.pop();</div><div class="line">            &#125;</div><div class="line">            is_left = !is_left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!is_left)&#123;</div><div class="line">            <span class="keyword">if</span>(maxHeap.empty() || num &gt;= maxHeap.top())&#123;</div><div class="line">                minHeap.push(num);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                maxHeap.push(num);</div><div class="line">                minHeap.push(maxHeap.top());</div><div class="line">                maxHeap.pop();</div><div class="line">            &#125;</div><div class="line">            is_left = !is_left;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">this</span>-&gt;n++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(n &gt;&gt; <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">return</span> maxHeap.top();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="合并k个排序链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists" target="_blank" rel="external">合并K个排序链表</a></h3>
<p>这里使用小顶堆这种结构保存K个链表，每次取得堆顶的元素就可以得到K个链表中最小的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">    priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,bigger&gt; minHeap;</div><div class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(lists[i]) minHeap.push(lists[i]);</div><div class="line">    &#125;</div><div class="line">    ListNode *head = <span class="literal">nullptr</span>;</div><div class="line">    ListNode *iter = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>(!minHeap.empty())&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</div><div class="line">            head = minHeap.top();</div><div class="line">            iter = head;</div><div class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</div><div class="line">                minHeap.push(minHeap.top()-&gt;next);</div><div class="line">            &#125;</div><div class="line">            minHeap.pop();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            iter-&gt;next = minHeap.top();</div><div class="line">            iter = iter-&gt;next;</div><div class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</div><div class="line">                minHeap.push(minHeap.top()-&gt;next);</div><div class="line">            &#125;</div><div class="line">            minHeap.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="堆排序">堆排序</h3>
<p>使用堆这种结构维护数据的有序性，从而进行排序的算法是堆排序。堆排序的具体步骤是： 使用要排序的整个数组建立堆。然后把最后一个元素和堆顶元素交换，堆的大小减1，调整堆，然后再把新的堆的最后一个元素和堆顶元素交换，调整堆，直到全部数据有序为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</div><div class="line">    <span class="comment">// 建立最大堆</span></div><div class="line">    make_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;());</div><div class="line">    <span class="keyword">int</span> index = v.size();</div><div class="line">    <span class="keyword">while</span>(index &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="comment">// 交换堆顶和堆尾的元素，重新调整堆</span></div><div class="line">        pop_heap(v.begin(),v.begin()+index,less&lt;<span class="keyword">int</span>&gt;());</div><div class="line">        index--;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】&lt;/p&gt;
    
    </summary>
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/categories/ACM/"/>
    
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_字典树(Trie树)</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/23/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E5%AD%97%E5%85%B8%E6%A0%91-Trie%E6%A0%91/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/23/算法专题-字典树-Trie树/</id>
    <published>2017-08-23T01:58:56.000Z</published>
    <updated>2017-10-03T13:04:44.011Z</updated>
    
    <content type="html"><![CDATA[<p>一种字符串前缀的匹配技术。</p>
<a id="more"></a>
<h2 id="字典树">字典树</h2>
<h2 id="字典树的应用">字典树的应用</h2>
<h3 id="异或今日头条2017秋招真题">异或（今日头条2017秋招真题）</h3>
<p><a href="http://exercise.acmcoder.com/online/online_judge_ques?ques_id=3338&amp;konwledgeId=158" target="_blank" rel="external">异或（今日头条2017秋招真题）</a></p>
<p>题目描述</p>
<p>给定整数m以及n个数字A1, A2, …, An，将数列A中所有元素两两异或，共能得到n(n-1)/2个结果。请求出这些结果中大于m的有多少个。</p>
<p>输入 第一行包含两个整数n, m。 第二行给出n个整数A1, A2, …, An。 样例输入 3 10 6 5 10 输出 输出仅包括一行，即所求的答案。 样例输出 2 时间限制 C/C++语言：1000MS其它语言：3000MS<br>
内存限制 C/C++语言：65536KB其它语言：589824K</p>
<p>思路：</p>
<ol style="list-style-type: decimal">
<li>从最高位开始建立字典树，左子树表示二进制0，右子树表示二进制位1. 每个节点统计在n个数字中对应的二进制位上有多少个对应的0或者1.</li>
<li><p>查询每个数字a和m，比较a和m对应的位，有如下情况 2.1 a = 0, m = 0, 这个时候 b=0 , a^b = 0 不能确定谁大，继续查找下一位 2.2 a = 0, m = 1, 这个时候 b=0 , 肯定有a^b &lt; m, 不满足条件，跳过； b = 1, 继续查找下一位 2.3 a = 1, m = 0, 这个时候 b=0 , 肯定有a^b &gt; m, 满足条件，直接将对应的count加在结果上， b=1,继续查找下一位 2.4 a = 1, m = 1, 这个时候 b=0 , 继续查找下一位，b = 1,肯定不满足条件，</p></li>
<li><p>最后的结果除以2返回， 因为我们既统计了a与b的异或，也统计了b与a的异或。</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TrieTree</span>* <span class="title">next</span>[2]&#123;</span><span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;</div><div class="line">    TrieTree():count(<span class="number">1</span>)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">TrieTree* <span class="title">buildTrieTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>)</span></span></div><div class="line">&#123;</div><div class="line">    TrieTree* trieTree = <span class="keyword">new</span> TrieTree();</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</div><div class="line">    &#123;</div><div class="line">        TrieTree* cur = trieTree;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">16</span>;j&gt;=<span class="number">0</span>;--j)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> digit = (<span class="built_in">array</span>[i] &gt;&gt; j) &amp; <span class="number">1</span>;</div><div class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[digit])</div><div class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> TrieTree();</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++(cur-&gt;next[digit]-&gt;count);</div><div class="line">            cur = cur-&gt;next[digit];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> trieTree;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">queryTrieTree</span><span class="params">(TrieTree*&amp; trieTree, <span class="keyword">const</span> <span class="keyword">int</span> a, <span class="keyword">const</span> <span class="keyword">int</span> m, <span class="keyword">const</span> <span class="keyword">int</span> index)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == trieTree)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"></div><div class="line">    TrieTree* cur = trieTree;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=index;i&gt;=<span class="number">0</span>;--i)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(<span class="number">1</span>==aDigit &amp;&amp; <span class="number">1</span>==mDigit)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>])</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            cur = cur-&gt;next[<span class="number">0</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">1</span>==mDigit)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span>(<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>])</div><div class="line">                <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            cur = cur-&gt;next[<span class="number">1</span>];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">1</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">0</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">0</span>]-&gt;count;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  queryTrieTree(cur-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> val0+val1;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="number">0</span> == aDigit &amp;&amp; <span class="number">0</span> == mDigit)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val0 =  queryTrieTree(cur-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</div><div class="line">            <span class="keyword">long</span> <span class="keyword">long</span> val1 =  (<span class="literal">NULL</span> == cur-&gt;next[<span class="number">1</span>]) ? <span class="number">0</span> : cur-&gt;next[<span class="number">1</span>]-&gt;count;</div><div class="line">            <span class="keyword">return</span> val0+val1;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; <span class="built_in">array</span>, <span class="keyword">const</span> <span class="keyword">int</span>&amp; m)</span></span></div><div class="line">&#123;</div><div class="line">    TrieTree* trieTree = buildTrieTree(<span class="built_in">array</span>);</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(<span class="keyword">int</span>)<span class="built_in">array</span>.size();++i)</div><div class="line">    &#123;</div><div class="line">        result += queryTrieTree(trieTree,<span class="built_in">array</span>[i],m,<span class="number">16</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result /<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n,m;</div><div class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>(n);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;++i)</div><div class="line">            <span class="built_in">cin</span>&gt;&gt;<span class="built_in">array</span>[i];</div><div class="line">        <span class="built_in">cout</span>&lt;&lt; solve(<span class="built_in">array</span>,m) &lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXBIT = <span class="number">17</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></div><div class="line">    ll count = <span class="number">0</span>;</div><div class="line">    trieTree* next[<span class="number">2</span>] = &#123;<span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</div><div class="line">    trieTree() : count(<span class="number">0</span>)&#123;&#125;</div><div class="line">    trieTree(<span class="keyword">int</span> c) : count(c)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr)</span></span>&#123;</div><div class="line">    trieTree* root = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.size(); ++i) &#123;</div><div class="line">        <span class="keyword">int</span> index = MAXBIT; <span class="comment">// int 整形最多32位</span></div><div class="line">        trieTree* cur = root;</div><div class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">int</span> digit = (arr[i] &gt;&gt; index) &amp; <span class="number">1</span>; <span class="comment">// 从低位到高位第index+1位的值</span></div><div class="line">            <span class="keyword">if</span>(cur-&gt;next[digit] == <span class="literal">nullptr</span>)&#123;</div><div class="line">                cur-&gt;next[digit] = <span class="keyword">new</span> trieTree(<span class="number">1</span>);</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                cur-&gt;next[digit]-&gt;count ++;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;next[digit];</div><div class="line">            index--;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 查询trie树中有多少个数字满足a^b&gt;m</div><div class="line"> * @param root</div><div class="line"> * @param a</div><div class="line"> * @param m</div><div class="line"> * @param index</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ll <span class="title">queryTree</span><span class="params">(trieTree* root,<span class="keyword">int</span> a, <span class="keyword">int</span> m, <span class="keyword">int</span> index)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &gt;= <span class="number">0</span>; --i) &#123;</div><div class="line">        <span class="keyword">int</span> aDigit = (a &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">        <span class="keyword">int</span> mDigit = (m &gt;&gt; i) &amp; <span class="number">1</span>;</div><div class="line">        <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</div><div class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] != <span class="literal">nullptr</span>)&#123;</div><div class="line">                v0 = root-&gt;next[<span class="number">1</span>]-&gt;count;</div><div class="line">            &#125;</div><div class="line">            v1 = queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> v0 + v1;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">0</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">1</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">0</span>)&#123;</div><div class="line">            ll v0 = <span class="number">0</span> , v1 = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] != <span class="literal">nullptr</span>)&#123;</div><div class="line">                v0 = root-&gt;next[<span class="number">0</span>]-&gt;count;</div><div class="line">            &#125;</div><div class="line">            v1 = queryTree(root-&gt;next[<span class="number">1</span>],a,m,i<span class="number">-1</span>);</div><div class="line">            <span class="keyword">return</span> v0 + v1;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aDigit == <span class="number">1</span> &amp;&amp; mDigit == <span class="number">1</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(root-&gt;next[<span class="number">0</span>] == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">            <span class="keyword">return</span> queryTree(root-&gt;next[<span class="number">0</span>],a,m,i<span class="number">-1</span>);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"error"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> m)</span></span>&#123;</div><div class="line">    trieTree* root = createTree(v);</div><div class="line">    ll result = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</div><div class="line">        result += queryTree(root,v[i],m,MAXBIT);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result / <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n, m ;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; v[i];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;solve(v,m)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="统计子目录">统计子目录</h3>
<p><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="external">统计子目录</a></p>
<p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p>
<p>/hihocoder/offer22/solutions/p1</p>
<p>/hihocoder/challenge30/p1/test</p>
<p>/game/moba/dota2/uninstall</p>
<p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p>
<p>/hihocoder</p>
<p>/hihocoder/offer22</p>
<p>/hihocoder/offer22/solutions</p>
<p>/hihocoder/challenge30</p>
<p>/hihocoder/challenge30/p1</p>
<p>/game</p>
<p>/game/moba</p>
<p>/game/moba/dota2/</p>
<p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p>
<p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p>
<p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p>
<p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p>
<p>输出 一个整数代表不同子目录的数目。</p>
<p>样例输入 3<br>
/hihocoder/offer22/solutions/p1<br>
/hihocoder/challenge30/p1/test<br>
/game/moba/dota2/uninstall 样例输出 8</p>
<p>思路： 用每个目录的名字建立字典树，根是空字符，然后统计整棵树节点的数目，最后返回节点的数目-1.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></div><div class="line">    <span class="built_in">string</span> description;</div><div class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</div><div class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</div><div class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 层次遍历统计节点数目</div><div class="line"> * @param root</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(trieTree* root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; nodes, next;</div><div class="line">    nodes.push_back(root);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!nodes.empty())&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nodes.size(); ++i) &#123;</div><div class="line">            next.insert(next.end(),nodes[i]-&gt;sons.begin(),nodes[i]-&gt;sons.end());</div><div class="line">        &#125;</div><div class="line">        re += nodes.size();</div><div class="line">        nodes = next;</div><div class="line">        next.clear();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 递归遍历节点数目</div><div class="line"> * @param root</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">countNode2</span><span class="params">(trieTree *root)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> re = <span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</div><div class="line">        re += countNode2(root-&gt;sons[i]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</div><div class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</div><div class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</div><div class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</div><div class="line">        index1 = index2;</div><div class="line">        index2++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(pathes.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</div><div class="line">        trieTree *cur = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</div><div class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</div><div class="line">                result++;</div><div class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</div><div class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</div><div class="line">                        index = k;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</div><div class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</div><div class="line">                    result++;</div><div class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    cur = cur-&gt;sons[index];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> re = countNode2(root) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;solve(pathes,n)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并子目录">合并子目录</h3>
<p><a href="http://hihocoder.com/problemset/solution/1157744" target="_blank" rel="external">合并子目录</a></p>
<p>描述 小Hi的电脑的文件系统中一共有N个文件，例如：</p>
<p>/hihocoder/offer23/solutions/p1</p>
<p>/hihocoder/challenge30/p1/test</p>
<p>/game/moba/dota2/uninstall</p>
<p>经过统计，小Hi认为他的电脑中子目录实在太多了，于是他决定减少子目录的数量。小Hi发现其中一些子目录只包含另一个子目录，例如/hihocoder/offer22只包含一个子目录solution，/game只包含一个子目录moba，而moba也只包含一个子目录dota2。小Hi决定把这样的子目录合并成一个子目录，并且将被合并的子目录的名字用’-’连起来作为新子目录的名字。合并之后上例的3个文件的路径会变为：</p>
<p>/hihocoder/offer23-solutions/p1</p>
<p>/hihocoder/challenge30-p1/test</p>
<p>/game-moba-dota2/uninstall</p>
<p>输入 第一行包含一个整数N (1 ≤ N ≤ 10000)</p>
<p>以下N行每行包含一个字符串，代表一个文件的绝对路径。保证路径从根目录“/”开始，并且文件名和目录名只包含小写字母和数字。</p>
<p>对于80%的数据，N个文件的绝对路径长度之和不超过10000</p>
<p>对于100%的数据，N个文件的绝对路径长度之和不超过500000</p>
<p>输出 对于输入中的每个文件，输出合并子目录之后该文件的绝对路径。</p>
<p>样例输入 3 /hihocoder/offer23/solutions/p1 /hihocoder/challenge30/p1/test /game/moba/dota2/uninstall 样例输出 /hihocoder/offer23-solutions/p1 /hihocoder/challenge30-p1/test /game-moba-dota2/uninstall</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">/*</span></div><div class="line"> * [统计子目录](http://hihocoder.com/problemset/solution/1157194)</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trieTree</span>&#123;</span></div><div class="line">    <span class="built_in">string</span> description;</div><div class="line">    <span class="built_in">vector</span>&lt;trieTree*&gt; sons;</div><div class="line">    trieTree() : description(<span class="string">""</span>)&#123;&#125;</div><div class="line">    trieTree(<span class="built_in">string</span> &amp;s) : description(s)&#123;&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; splitString(<span class="built_in">string</span> &amp;s)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; re;</div><div class="line">    <span class="keyword">if</span>(s.empty()) <span class="keyword">return</span> re;</div><div class="line">    s.push_back(<span class="string">'/'</span>);</div><div class="line">    <span class="keyword">size_t</span> index1 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">size_t</span> index2 = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(s.find(<span class="string">'/'</span>,index2) != <span class="number">-1</span>)&#123;</div><div class="line">        index2 = s.find(<span class="string">'/'</span>,index1+<span class="number">1</span>);</div><div class="line">        re.push_back(s.substr(index1+<span class="number">1</span>,index2-index1<span class="number">-1</span>));</div><div class="line">        index1 = index2;</div><div class="line">        index2++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">trieTree* <span class="title">createTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(pathes.empty()) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    trieTree *root = <span class="keyword">new</span> trieTree();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pathes.size(); ++i) &#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; path = splitString(pathes[i]);</div><div class="line">        trieTree *cur = root;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; path.size(); ++j) &#123;</div><div class="line">            <span class="keyword">if</span>(cur-&gt;sons.empty())&#123;</div><div class="line">                cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</div><div class="line">                result++;</div><div class="line">                cur = cur-&gt;sons[<span class="number">0</span>];</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="keyword">int</span> index = cur-&gt;sons.size();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cur-&gt;sons.size(); ++k) &#123;</div><div class="line">                    <span class="keyword">if</span>(cur-&gt;sons[k]-&gt;description == path[j])&#123;</div><div class="line">                        index = k;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span>(index == cur-&gt;sons.size())&#123;</div><div class="line">                    cur-&gt;sons.push_back(<span class="keyword">new</span> trieTree(path[j]));</div><div class="line">                    result++;</div><div class="line">                    cur = cur-&gt;sons[cur-&gt;sons.size()<span class="number">-1</span>];</div><div class="line">                &#125;<span class="keyword">else</span>&#123;</div><div class="line">                    cur = cur-&gt;sons[index];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">trieTree* <span class="title">reduceTree</span><span class="params">(trieTree* root)</span></span>&#123;</div><div class="line">    trieTree* re = root;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.empty()) <span class="keyword">return</span> root;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.size() &gt;= <span class="number">2</span>)&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</div><div class="line">            reduceTree(root-&gt;sons[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.size() == <span class="number">1</span>)&#123;</div><div class="line">        trieTree* next = root-&gt;sons[<span class="number">0</span>];</div><div class="line">        <span class="keyword">if</span>(next-&gt;sons.empty())&#123;</div><div class="line"><span class="comment">//            root-&gt;description = root-&gt;description + "-";</span></div><div class="line"><span class="comment">//            root-&gt;description = root-&gt;description + next-&gt;description;</span></div><div class="line"><span class="comment">//            root-&gt;sons.clear();</span></div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        &#125;</div><div class="line">        root-&gt;sons.clear();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; next-&gt;sons.size(); ++i) &#123;</div><div class="line">            root-&gt;sons.push_back(next-&gt;sons[i]);</div><div class="line">        &#125;</div><div class="line">        root-&gt;description = root-&gt;description + <span class="string">"-"</span>;</div><div class="line">        root-&gt;description = root-&gt;description + next-&gt;description;</div><div class="line">        reduceTree(root);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(trieTree* root,<span class="built_in">string</span> out)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</div><div class="line">    out += root-&gt;description + <span class="string">"/"</span>;</div><div class="line">    <span class="keyword">if</span>(root-&gt;sons.empty())&#123;</div><div class="line">        <span class="keyword">if</span>(out.find_last_of(<span class="string">'/'</span>) == out.size() - <span class="number">1</span>)&#123;</div><div class="line">            out.erase(out.size()<span class="number">-1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;out&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root-&gt;sons.size(); ++i) &#123;</div><div class="line">            printTree(root-&gt;sons[i],out);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;pathes, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">    trieTree* root = createTree(pathes);</div><div class="line">    trieTree* reduced = reduceTree(root);</div><div class="line">    <span class="built_in">string</span> out = <span class="string">""</span>;</div><div class="line">    printTree(reduced,out);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span>&gt;&gt;n;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; pathes(n,<span class="string">""</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; pathes[i];</div><div class="line">    &#125;</div><div class="line">    solve(pathes,n);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一种字符串前缀的匹配技术。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>今日头条_在线编程题</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/22/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1-%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/22/算法专题/今日头条-在线编程题/</id>
    <published>2017-08-22T08:10:10.000Z</published>
    <updated>2017-10-03T13:05:34.099Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="头条校招">头条校招</h2>
<p><a href="https://www.nowcoder.com/questionTerminal/57cf0b1050834901933e9b48daafbb9a" target="_blank" rel="external">头条校招</a></p>
<p>头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：</p>
<p>a&lt;=b&lt;=c b-a&lt;=10 c-b&lt;=10</p>
<p>所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗？ 输入描述:</p>
<p>输入的第一行包含一个整数n，表示目前已经出好的题目数量。</p>
<p>第二行给出每道题目的难度系数d1,d2,…,dn。</p>
<p>数据范围</p>
<p>对于30%的数据，1 ≤ n,di ≤ 5;</p>
<p>对于100%的数据，1 ≤ n ≤ 10^5,1 ≤ di ≤ 100。</p>
<p>在样例中，一种可行的方案是添加2个难度分别为20和50的题目，这样可以组合成两场考试：（20 20 23）和（35,40,50）。</p>
<p>输出描述:</p>
<p>输出只包括一行，即所求的答案。 示例1 输入</p>
<p>4<br>
20 35 23 40 输出</p>
<p>2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v.empty()) <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    sort(v.begin(),v.end());</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> re = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i &lt; n)&#123;</div><div class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>&lt;n)&#123;</div><div class="line">           <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">20</span>)&#123;</div><div class="line">               re = re + <span class="number">2</span>;</div><div class="line">               i = i + <span class="number">1</span>;</div><div class="line">           &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i+<span class="number">1</span>] - v[i] &gt; <span class="number">10</span>)&#123;</div><div class="line">               re = re + <span class="number">1</span>;</div><div class="line">               i = i + <span class="number">2</span>;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">if</span>(i+<span class="number">2</span> &lt; n)&#123;</div><div class="line">                   <span class="keyword">if</span>(v[i+<span class="number">2</span>] - v[i+<span class="number">1</span>] &gt; <span class="number">10</span>)&#123;</div><div class="line">                       re = re + <span class="number">1</span>;</div><div class="line">                       i = i + <span class="number">2</span>;</div><div class="line">                   &#125;<span class="keyword">else</span>&#123;</div><div class="line">                       i = i + <span class="number">3</span>;</div><div class="line">                   &#125;</div><div class="line">               &#125;<span class="keyword">else</span>&#123;</div><div class="line">                   re = re + <span class="number">1</span>;</div><div class="line">                   <span class="keyword">break</span>;</div><div class="line">               &#125;</div><div class="line">           &#125;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            re = re + <span class="number">2</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; v[i] ;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">auto</span> re = solve(v,n);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;头条校招&quot;&gt;头条校招&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.nowcoder.com/questionTerminal/57cf0b1050834901933e9b48daafbb9a&quot; target=&quot;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>阿里笔试</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/18/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E9%98%BF%E9%87%8C%E5%9C%A8%E7%BA%BF%E6%B5%8B%E8%AF%84-%E5%85%94%E5%AD%90%E7%B9%81%E6%AE%96%E9%97%AE%E9%A2%98/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/18/算法专题/阿里在线测评-兔子繁殖问题/</id>
    <published>2017-08-18T11:38:27.000Z</published>
    <updated>2017-10-03T13:04:43.763Z</updated>
    
    <content type="html"><![CDATA[<p>阿里巴巴网络技术有限公司（简称：阿里巴巴集团）是以曾担任英语教师的马云为首的18人于1999年在浙江杭州创立，他们相信互联网能够创造公平的竞争环境，让小企业通过创新与科技扩展业务，并在参与国内或全球市场竞争时处于更有利的位置</p>
<a id="more"></a>
<h2 id="兔子繁殖问题">兔子繁殖问题</h2>
<p>问题</p>
<ol style="list-style-type: decimal">
<li>猎人把一对兔子婴儿(一公一母称为一对)放到一个荒岛上，两年之后，它们生下一对小兔，之后开始每年都会生下一对小兔。生下的小兔又会以同样的方式继续繁殖。</li>
<li>兔子的寿命都是x(x&gt;=3)年，并且生命的最后一年不繁殖。</li>
<li>如果岛上的兔子多于10对，那么猎人会每年在兔子们完成繁殖或者仙逝之后，从岛上带走两对最老的兔子。 请问y年(y&gt;=3)后荒岛上所有的兔子加起来多少岁?(注意, 在条件3执行完之后)</li>
</ol>
<p>输入: 从命令行输入两行整数，第一行是x，第二行是y 输出: y年后荒岛上所有的兔子岁数的总和</p>
<p>测试数据：</p>
<table>
<thead>
<tr class="header">
<th>x</th>
<th>y</th>
<th>n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>3</td>
<td>3</td>
<td>2</td>
</tr>
<tr class="even">
<td>3</td>
<td>7</td>
<td>2</td>
</tr>
<tr class="odd">
<td>3</td>
<td>8</td>
<td>4</td>
</tr>
<tr class="even">
<td>4</td>
<td>5</td>
<td>12</td>
</tr>
<tr class="odd">
<td>5</td>
<td>6</td>
<td>26</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> x ;</div><div class="line">    <span class="keyword">int</span> y ;</div><div class="line">    x = <span class="number">10</span>;</div><div class="line">    y = <span class="number">12</span>;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = &#123;<span class="number">0</span>&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> year = <span class="number">1</span>; year &lt;= y; year++) &#123;</div><div class="line">        <span class="comment">// // 每年长一岁</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</div><div class="line">            res[i]++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// over</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (res[i] &gt;= x)</div><div class="line">                res.erase(res.begin() + i);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                i++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 生孩子</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;res.size();i++) &#123;</div><div class="line">            <span class="keyword">if</span> (res[i]&gt;= <span class="number">2</span> &amp;&amp; res[i] &lt; x)</div><div class="line">            &#123;</div><div class="line">                res.push_back(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (res.size() &gt; <span class="number">10</span>) &#123;</div><div class="line">            res.erase(res.begin());</div><div class="line">            res.erase(res.begin());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : res)</div><div class="line">        num += x;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; num * <span class="number">2</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;阿里巴巴网络技术有限公司（简称：阿里巴巴集团）是以曾担任英语教师的马云为首的18人于1999年在浙江杭州创立，他们相信互联网能够创造公平的竞争环境，让小企业通过创新与科技扩展业务，并在参与国内或全球市场竞争时处于更有利的位置&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_贪心法</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/17/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/17/算法专题/算法专题-贪心法/</id>
    <published>2017-08-17T11:57:30.000Z</published>
    <updated>2017-10-03T13:04:43.880Z</updated>
    
    <content type="html"><![CDATA[<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p>
<a id="more"></a>
<h3 id="任务安排问题">任务安排问题</h3>
<p><a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="external">Maximum Length of Pair Chain</a></p>
<p>按照结束时间排序，贪心的选择结束时间最早的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<h2 id="整数分解求乘积最大">整数分解求乘积最大</h2>
<p><a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="external">leetcode</a></p>
<p>分解策略是尽可能的分解成2，3， 尽可能均匀的分解成2，3</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;</div><div class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">6</span>) <span class="keyword">return</span> dp[n<span class="number">-2</span>];</div><div class="line">        <span class="keyword">int</span> c3 = <span class="number">0</span>, c2 = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(n - <span class="number">3</span> &gt;= <span class="number">2</span>)&#123;</div><div class="line">            n = n - <span class="number">3</span>;</div><div class="line">            c3++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>)&#123;</div><div class="line">            c2 = n / <span class="number">2</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>( n % <span class="number">3</span> == <span class="number">0</span>)&#123;</div><div class="line">            c3 = c3 + n / <span class="number">3</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">double</span> re = <span class="built_in">pow</span>(<span class="number">2.0</span>,c2) * <span class="built_in">pow</span>(<span class="number">3.0</span>,c3);</div><div class="line">        <span class="keyword">int</span> res = re;</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_hihocoder</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/13/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98-hihocoder/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/13/算法专题/算法专题-hihocoder/</id>
    <published>2017-08-13T12:19:33.000Z</published>
    <updated>2017-08-19T10:00:01.053Z</updated>
    
    <content type="html"><![CDATA[<p>hihocoder 每周编程比赛</p>
<a id="more"></a>
<h2 id="offer收割编程练习赛22"><a href="http://hihocoder.com/contest/offers22" target="_blank" rel="external">[Offer收割]编程练习赛22</a></h2>
<h3 id="顺序三元组"><a href="http://hihocoder.com/problemset/problem/1550" target="_blank" rel="external">顺序三元组</a></h3>
<p>给定一个长度为N的数组A=[A1, A2, … AN]，已知其中每个元素Ai的值都只可能是1, 2或者3。 请求出有多少下标三元组(i, j, k)满足1 ≤ i &lt; j &lt; k ≤ N且Ai &lt; Aj &lt; Ak。</p>
<p>分析：统计2前面有多少个1，2前面有多少个12就可以了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</div><div class="line"></div><div class="line"><span class="function">ll <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> n)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v.empty() || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    ll c1 = <span class="number">0</span>, c12 = <span class="number">0</span>, c123 = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="keyword">if</span>(v[i] == <span class="number">1</span>)&#123;</div><div class="line">            c1++;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] == <span class="number">2</span>)&#123;</div><div class="line">            c12 = c12 + c1;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] == <span class="number">3</span>)&#123;</div><div class="line">            c123 = c123 + c12;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="comment">// 输入数据有错</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(n,<span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;v[i];</div><div class="line">    &#125;</div><div class="line">    ll result = solve(v,n);</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;result&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并子目录"><a href="http://hihocoder.com/problemset/problem/1551" target="_blank" rel="external">合并子目录</a></h3>
<p>小Hi的电脑的文件系统中一共有N个文件，例如：</p>
<p>/hihocoder/offer22/solutions/p1</p>
<p>/hihocoder/challenge30/p1/test</p>
<p>/game/moba/dota2/uninstall</p>
<p>小Hi想统计其中一共有多少个不同的子目录。上例中一共有8个不同的子目录：</p>
<p>/hihocoder</p>
<p>/hihocoder/offer22</p>
<p>/hihocoder/offer22/solutions</p>
<p>/hihocoder/challenge30</p>
<p>/hihocoder/challenge30/p1</p>
<p>/game</p>
<p>/game/moba</p>
<p>/game/moba/dota2/</p>
<p>前缀树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="keyword">int</span> N;</div><div class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FS</span> &#123;</span></div><div class="line">    <span class="built_in">string</span> name;</div><div class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, FS*&gt; subs;</div><div class="line">    FS(<span class="keyword">const</span> <span class="built_in">string</span> &amp;n): name(n)&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; parse(<span class="keyword">const</span> <span class="built_in">string</span> &amp;path) &#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; ret;</div><div class="line">    <span class="comment">// 需要的字符串前后都有/,first_表示前面/的位置，second_表示后面.的位置</span></div><div class="line">    <span class="keyword">int</span> first_ = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> second_ = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(first_ &lt; path.size()) &#123;</div><div class="line">        second_ = path.find(<span class="string">'/'</span>, first_);</div><div class="line">        <span class="comment">// 没有找到/,退出循环</span></div><div class="line">        <span class="keyword">if</span> (second_ == <span class="number">-1</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (second_ &gt; first_) &#123;</div><div class="line">            ret.push_back(<span class="built_in">string</span>(path.begin() + first_, path.begin() + second_));</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        first_ = second_ + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> ret;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(FS *root)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</div><div class="line">    ret++;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p: root-&gt;subs) &#123;</div><div class="line">        dfs(p.second);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; N;</div><div class="line">    FS* root= <span class="keyword">new</span> FS(<span class="string">""</span>);</div><div class="line">    <span class="built_in">string</span> path;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</div><div class="line">        <span class="built_in">cin</span> &gt;&gt; path;</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; dirs = parse(path);</div><div class="line"></div><div class="line">        <span class="comment">// 构造前缀树</span></div><div class="line">        <span class="keyword">auto</span> cur = root;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> dir: dirs) &#123;</div><div class="line">            <span class="keyword">if</span> (cur-&gt;subs.count(dir) == <span class="number">0</span>) &#123;</div><div class="line">                FS *ndir = <span class="keyword">new</span> FS(dir);</div><div class="line">                cur-&gt;subs[dir] = ndir;</div><div class="line">            &#125;</div><div class="line">            cur = cur-&gt;subs[dir];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历树，统计结果</span></div><div class="line">    dfs(root);</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; ret - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="缺失的拼图"><a href="http://hihocoder.com/problemset/problem/1552" target="_blank" rel="external">缺失的拼图</a></h3>
<p>小Hi在玩一个拼图游戏。如下图所示，整个拼图是由N块小矩形组成的大矩形。现在小Hi发现其中一块小矩形不见了。给定大矩形以及N-1个小矩形的顶点坐标，你能找出缺失的那块小矩形的顶点坐标吗？</p>
<p>分析： 每个矩形用四个点的坐标来表示，那么如果不缺失矩形，每个点应该出现偶数次。缺失矩形的地方，每个点只出现奇数次，这样就能找到缺失矩形的坐标。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</div><div class="line">    freopen(<span class="string">"d:/A.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    <span class="built_in">cin</span> &gt;&gt; n;</div><div class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;,<span class="keyword">int</span>&gt; m;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</div><div class="line">        <span class="keyword">int</span> x1,y1,x2,y2;</div><div class="line">        <span class="built_in">cin</span>&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2;</div><div class="line">        m[make_pair(x1,y1)]++;</div><div class="line">        m[make_pair(x1,y2)]++;</div><div class="line">        m[make_pair(x2,y1)]++;</div><div class="line">        m[make_pair(x2,y2)]++;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xx;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; yy;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : m) &#123;</div><div class="line">        <span class="keyword">if</span>(i.second % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line">        xx.push_back(i.first.first);</div><div class="line">        yy.push_back(i.first.second);</div><div class="line">    &#125;</div><div class="line">    sort(xx.begin(),xx.end());</div><div class="line">    sort(yy.begin(),yy.end());</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;xx[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;yy[<span class="number">0</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;xx[<span class="number">3</span>]&lt;&lt;<span class="string">" "</span>&lt;&lt;yy[<span class="number">3</span>]&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hihocoder 每周编程比赛&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_归并排序</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/07/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/07/算法专题/算法专题_归并排序/</id>
    <published>2017-08-07T13:13:50.000Z</published>
    <updated>2017-10-03T02:58:20.891Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。</p>
<p>归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。</p>
<a id="more"></a>
<h2 id="归并排序的实现">归并排序的实现</h2>
<p>归并排序中最重要的操作是如何将两个有序的序列合并为一个有序的序列。</p>
<div class="figure">
<img src="2017-04-16_213443.png">

</div>
<p>这里合并两个有序序列的方法可以自己设计，我们使用逐个元素比较的方法，时间复杂度是<code>O(a1+a2)</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> a:v)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">" | "</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//合并两个有序的数组,返回新的有序的数组</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">size_t</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123;</div><div class="line">        <span class="keyword">if</span>(v1[i] &lt;= v2[j])&#123;</div><div class="line">            re.push_back(v1[i]);</div><div class="line">            i++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            re.push_back(v2[j]);</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//把剩下的放在最后</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a = i;a&lt;v1.size();a++)&#123;</div><div class="line">        re.push_back(v1[a]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a=j;a&lt;v2.size();a++)&#123;</div><div class="line">        re.push_back(v2[a]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//归并排序的非递归实现</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort2(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; group;</div><div class="line">    <span class="comment">// 一开始，每一个元素单独为一组，然后一步一步的合并相邻的组，直到最后只剩下一组。</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++) &#123;</div><div class="line">        group.push_back(&#123;v[i]&#125;);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> group_end = group.size(); <span class="comment">// 指示结果，每次归并，都是合并相邻的两组数据，所以group的元素个数每次都减少一半，为了减少开销，</span></div><div class="line">    <span class="comment">//我们每次合并之后的数组还是放在原来的数组中，用group指示数组的结束。</span></div><div class="line">    <span class="comment">//当group_end = 1的时候，所有的数组已经归并到一起了</span></div><div class="line">    <span class="keyword">while</span>(group_end &gt; <span class="number">1</span>)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> b=<span class="number">0</span>;b&lt;group_end;b++)&#123;</div><div class="line">            print(group[b]);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(j+<span class="number">1</span>&lt;group.size())&#123;</div><div class="line">            group[j/<span class="number">2</span>]  = merge(group[j],group[j+<span class="number">1</span>]);</div><div class="line">            j = j + <span class="number">2</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 个数是奇数的情况</span></div><div class="line">        <span class="keyword">if</span>(j == group_end <span class="number">-1</span> )&#123;</div><div class="line">            group[<span class="built_in">ceil</span>(group_end / <span class="number">2.0</span>)<span class="number">-1</span>] = group[group_end<span class="number">-1</span>];</div><div class="line">        &#125;</div><div class="line">        group_end = <span class="built_in">ceil</span>(group_end / <span class="number">2.0</span>);</div><div class="line">    &#125;</div><div class="line">    print(group[<span class="number">0</span>]);</div><div class="line">    <span class="keyword">return</span> group[<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>&#125;;</div><div class="line">    <span class="keyword">auto</span> a = mergeSort2(v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果: <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">49</span>  | <span class="number">38</span>  | <span class="number">65</span>  | <span class="number">97</span>  | <span class="number">76</span>  | <span class="number">13</span>  | <span class="number">27</span>  |</div><div class="line"><span class="number">38</span> <span class="number">49</span>  | <span class="number">65</span> <span class="number">97</span>  | <span class="number">13</span> <span class="number">76</span>  | <span class="number">27</span>  |</div><div class="line"><span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">97</span>  | <span class="number">13</span> <span class="number">27</span> <span class="number">76</span>  |</div><div class="line"><span class="number">13</span> <span class="number">27</span> <span class="number">38</span> <span class="number">49</span> <span class="number">65</span> <span class="number">76</span> <span class="number">97</span>  |</div></pre></td></tr></table></figure></p>
<p>归并排序的递归实现方法 ： <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  归并排序的递归实现</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end)&#123;</div><div class="line">    <span class="keyword">if</span>(start &gt;= end)&#123;</div><div class="line">        <span class="keyword">return</span> &#123;v[start]&#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</div><div class="line">    <span class="keyword">auto</span> v1 = mergeSort(v,start,mid); <span class="comment">// 递归左半部分的排序</span></div><div class="line">    <span class="keyword">auto</span> v2 = mergeSort(v,mid+<span class="number">1</span>,end); <span class="comment">// 递归右半部分的排序</span></div><div class="line">    <span class="keyword">return</span> merge(v1,v2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="归并排序的应用">归并排序的应用</h2>
<h3 id="统计数组的逆序对">统计数组的逆序对</h3>
<p>归并排序是一种稳定的排序（合并两个有序数组的时候是稳定的），所以可以用来求数组的逆序对这样的问题。</p>
<p>归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。 在合并的过程中（设<code>l&lt;=i&lt;=mid，mid+1&lt;=j&lt;=h</code>），当a[i]&lt;=a[j]时，并不产生逆序数；当a[i]&gt;a[j]时，在 前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上<code>mid-i+1</code>。因此，可以在归并 排序中的合并过程中计算逆序数.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//合并两个有序的数组,返回新的有序的数组</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v2,<span class="keyword">int</span> &amp;cc)&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; re;</div><div class="line">    <span class="keyword">size_t</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(i&lt;v1.size() &amp;&amp; j&lt;v2.size())&#123;</div><div class="line">        <span class="keyword">if</span>(v1[i] &lt;= v2[j])&#123;</div><div class="line">            re.push_back(v1[i]);</div><div class="line">            i++;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            re.push_back(v2[j]);</div><div class="line">            cc = cc + v1.size() -  i; <span class="comment">//增加统计逆序对的功能，以传递引用的方法返回结果，注意传入的参数的初始值要为0；</span></div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//把剩下的放在最后</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a = i;a&lt;v1.size();a++)&#123;</div><div class="line">        re.push_back(v1[a]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> a=j;a&lt;v2.size();a++)&#123;</div><div class="line">        re.push_back(v2[a]);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> re;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//归并排序的递归实现</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; mergeSort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> &amp;cc)&#123;</div><div class="line">  <span class="keyword">if</span>(start &gt;= end)&#123;</div><div class="line">      <span class="keyword">return</span> &#123;v[start]&#125;;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</div><div class="line">  <span class="keyword">auto</span> v1 = mergeSort(v,start,mid,cc); <span class="comment">// 递归左半部分的排序</span></div><div class="line">  <span class="keyword">auto</span> v2 = mergeSort(v,mid+<span class="number">1</span>,end,cc); <span class="comment">// 递归右半部分的排序</span></div><div class="line">  <span class="keyword">return</span> merge(v1,v2,cc);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//使用的使用定义int cc = 0; 传入函数即可。</span></div></pre></td></tr></table></figure>
<p>统计数组的逆序对，还可以使用树状数组，不过就复杂度而言，使用归并排序已经足够了。</p>
<p>另外一种归并排序的实现方法，尽量少的占用额外的空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> s1,<span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2)</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="keyword">int</span> ss1 = s1, ss2 = s2;</div><div class="line">    <span class="keyword">while</span>(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123;</div><div class="line">        <span class="keyword">if</span>(v[s1] &lt; v[s2])&#123;</div><div class="line">            tmp.push_back(v[s1]);</div><div class="line">            s1++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v[s1] &gt;= v[s2])&#123;</div><div class="line">            tmp.push_back(v[s2]);</div><div class="line">            s2++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s1 &lt;= e1)&#123;</div><div class="line">        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s2 &lt;= e2)&#123;</div><div class="line">        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ss1;i&lt;=e1;i++)&#123;</div><div class="line">        v[i] = tmp[t];</div><div class="line">        t++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ss2;i&lt;=e2;i++)&#123;</div><div class="line">        v[i] = tmp[t];</div><div class="line">        t++;</div><div class="line">    &#125;</div><div class="line">    tmp.clear();</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</div><div class="line">    mergeSort(v,start,mid);</div><div class="line">    mergeSort(v,mid+<span class="number">1</span>,end);</div><div class="line">    merge(v,start,mid,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>统计逆序对</p>
<p>在归并排序归并两个已经排好序的数组的时候，是统计逆序对的最好时机。假设两个待合并的序列为<code>v1</code>,<code>v2</code>, 有两个指针<code>s1</code>,<code>s2</code>分别指向<code>v1</code>,<code>v2</code>,当<code>v1[s1] &gt; v2[s2]</code>的时候，<code>(v1.size() - s1)</code>, 也就是从<code>s1</code>到<code>v1</code>的结尾的所有元素都会和<code>v[s2]</code>组成逆序对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> s1,<span class="keyword">int</span> e1, <span class="keyword">int</span> s2, <span class="keyword">int</span> e2, <span class="keyword">int</span> &amp;cc)</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</div><div class="line">    <span class="keyword">int</span> ss1 = s1, ss2 = s2;</div><div class="line">    <span class="keyword">while</span>(s1&lt;=e1 &amp;&amp; s2 &lt;= e2)&#123;</div><div class="line">        <span class="keyword">if</span>(v[s1] &lt;= v[s2])&#123;</div><div class="line">            tmp.push_back(v[s1]);</div><div class="line">            s1++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v[s1] &gt; v[s2])&#123;</div><div class="line">            tmp.push_back(v[s2]);</div><div class="line">            s2++;</div><div class="line">            cc += e1-s1+<span class="number">1</span>; <span class="comment">// 记录逆序对的数量</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s1 &lt;= e1)&#123;</div><div class="line">        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(s2 &lt;= e2)&#123;</div><div class="line">        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=ss1;i&lt;=e1;i++)&#123;</div><div class="line">        v[i] = tmp[t];</div><div class="line">        t++;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = ss2;i&lt;=e2;i++)&#123;</div><div class="line">        v[i] = tmp[t];</div><div class="line">        t++;</div><div class="line">    &#125;</div><div class="line">    tmp.clear();</div><div class="line">    <span class="keyword">return</span> ;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> &amp;cc)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span> ;</div><div class="line">    <span class="keyword">int</span> mid = (start+end) / <span class="number">2</span>;</div><div class="line">    mergeSort(v,start,mid,cc);</div><div class="line">    mergeSort(v,mid+<span class="number">1</span>,end,cc);</div><div class="line">    merge(v,start,mid,mid+<span class="number">1</span>,end,cc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。&lt;/p&gt;
&lt;p&gt;归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_快速排序</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/07/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/07/算法专题/算法专题_快速排序/</id>
    <published>2017-08-07T13:13:31.000Z</published>
    <updated>2017-10-03T02:54:14.936Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序是分治思想的典型应用，它的时间复杂度是<code>o(nlogn)</code>,在数据没有特殊的规律的情况下，快速排序是首选的排序方法。它的思想也经常用来出各种算法题目。</p>
<a id="more"></a>
<h2 id="快排算法">快排算法</h2>
<div class="figure">
<img src="2017-04-17_182740.png">

</div>
<p>快速排序的基本思想是每次选择一个基准元素，调整数组，使得所有比基准元素小的元素都位于左边，所有比基准元素大的元素都位于基准元素的右边，从而使得基准元素放在了正确的位置上。然后以基准元素为准，把数组分成两个部分，递归的应用上面的方法，得到最终的结果。所以，快速排序的实现也有递归的版本和非递归的版本。一般使用递归的版本就够了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="comment">// 以i指向的元素为基准元素</span></div><div class="line">    <span class="keyword">bool</span> base = <span class="literal">true</span>; <span class="comment">// base = true 表示此时 i 指向base 元素， base = false 表示此时j 指向base元素</span></div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; base)&#123;</div><div class="line">            swap(v[i],v[j]);</div><div class="line">            base = <span class="literal">false</span>;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; !base)&#123;</div><div class="line">            swap(v[i],v[j]);</div><div class="line">            base = <span class="literal">true</span>;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(base)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(!base)&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 快速排序</div><div class="line"> * @param v  待排序数组</div><div class="line"> * @param start  起始位置下标</div><div class="line"> * @param end  结束位置下标</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</div><div class="line">     <span class="keyword">if</span>(start &gt;= end) <span class="keyword">return</span>;</div><div class="line">     <span class="keyword">int</span> mid = partition(v,start,end);</div><div class="line">     quickSort(v,start,mid<span class="number">-1</span>);</div><div class="line">     quickSort(v,mid+<span class="number">1</span>,end);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="快排的应用">快排的应用</h2>
<h3 id="n个元素中查找第k小的元素on时间内">N个元素中查找第K小的元素(o(n)时间内)</h3>
<p>如果查找最小的元素，只需要遍历一遍数组即可。如果是第2小的，首先遍历一遍找到最小的，然后再遍历一遍就可以找到第二小的了。所以，朴素的解法需要的时间复杂度是o(kn),与k有关系。</p>
<p>快速排序<code>partition</code>函数的特点是每次能确定一个元素排好序之后应该在的位置。假设partition(0,n-1) = i, 我们可以获得这样的信息，[0..i-1]位置的元素都比A[i]小，而i后面的元素都比A[i]大。这样，我们每次调用<code>partition</code>都可以去掉一半元素，这样时间复杂度就能降到o(n)了。</p>
<p><a href="http://lintcode.com/en/problem/kth-largest-element/#" target="_blank" rel="external">lintcode</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">Kth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v, <span class="keyword">int</span> k)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(v.empty() || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> end = v.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">         <span class="keyword">int</span> i = partition(v,begin,end);</div><div class="line">         <span class="keyword">if</span>(i+<span class="number">1</span> == k) <span class="keyword">return</span> v[i];</div><div class="line">         <span class="keyword">if</span>(i+<span class="number">1</span> &lt; k)&#123;</div><div class="line">            begin = i + <span class="number">1</span>;</div><div class="line">         &#125;<span class="keyword">else</span>&#123;</div><div class="line">            end = i - <span class="number">1</span>;</div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="external">leetcode</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v,<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i &gt; j) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> tmp;</div><div class="line">    <span class="keyword">int</span> start = i;</div><div class="line">    <span class="keyword">int</span> end = j;</div><div class="line">    <span class="keyword">bool</span> base = <span class="literal">true</span>; <span class="comment">// 指示 i 是否指向base 元素，如果i 不指向base元素，则j肯定指向base元素。</span></div><div class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</div><div class="line">        <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; base)&#123;</div><div class="line">            tmp = v[j];</div><div class="line">            v[j] = v[i];</div><div class="line">            v[i] = tmp;</div><div class="line">            i = i + <span class="number">1</span>;</div><div class="line">            base = <span class="literal">false</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(v[i] &gt; v[j] &amp;&amp; !base)&#123;</div><div class="line">            tmp = v[j];</div><div class="line">            v[j] = v[i];</div><div class="line">            v[i] = tmp;</div><div class="line">            j = j - <span class="number">1</span>;</div><div class="line">            base = <span class="literal">true</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(base)&#123;</div><div class="line">            j--;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            i++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargestElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>, len = nums.size();</div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">int</span> pos = partition(nums, left, right);</div><div class="line">        <span class="keyword">if</span> (len - pos == k ) <span class="keyword">return</span> nums[pos];</div><div class="line">        <span class="keyword">if</span> (len - pos &lt; k) right = pos - <span class="number">1</span>;</div><div class="line">        <span class="keyword">else</span> left = pos + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找中位数">查找中位数</h3>
<p>一般的做法是排序，返回中间的数字，但是这样的时间复杂度是o(nlogn). 其实还有o(n)的算法，和上面一样，也是利用了快速排序的partition函数。</p>
<p><a href="http://lintcode.com/zh-cn/problem/median/" target="_blank" rel="external">lintcode</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">median</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">int</span> len = nums.size();</div><div class="line">    <span class="keyword">return</span> kthLargestElement(nums,len / <span class="number">2</span> + <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序是分治思想的典型应用，它的时间复杂度是&lt;code&gt;o(nlogn)&lt;/code&gt;,在数据没有特殊的规律的情况下，快速排序是首选的排序方法。它的思想也经常用来出各种算法题目。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_二叉堆</title>
    <link href="http://ff120.github.io/hexoblog/2017/08/06/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <id>http://ff120.github.io/hexoblog/2017/08/06/算法专题/算法专题_二叉堆/</id>
    <published>2017-08-06T00:53:25.000Z</published>
    <updated>2017-10-03T02:46:52.871Z</updated>
    
    <content type="html"><![CDATA[<p>堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。</p>
<p>既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是<code>i</code>,那么它的左孩子为<code>2*i</code>,右孩子为<code>2*i+1</code>,父节点为<code>i/2</code>. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1.</p>
<p>如果根节点是从0开始标号的，那么对于节点<code>i</code>, 左孩子为<code>2*i+1</code>,右孩子为<code>2*i+2</code>,父节点为<code>(i-1)/2</code>.</p>
<p><a href="2017-04-11_091249.png"></a></p>
<a id="more"></a>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 根节点从0开始标号，对于节点i，求其左孩子，右孩子和父节点</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">left</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (i&lt;&lt;<span class="number">1</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> (i&lt;&lt;<span class="number">1</span>) + <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">parent</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    <span class="keyword">return</span> (i<span class="number">-1</span>) &gt;&gt; <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="最大堆">最大堆</h2>
<p>最大堆就是满足父节点大于等于子节点的堆。最大堆的根节点是所有元素中最大的(但可能不是唯一的最大的，注意这里是大于等于)。</p>
<h3 id="维护最大堆调整最大堆">维护最大堆(调整最大堆)</h3>
<p>假设<code>A</code>是存储堆的数组,<code>A.length()</code>表示数组的大小，<code>heap_size</code>表示堆中元素的个数, 满足<code>heap_size &lt;= A.length()</code>.假设我们需要调整节点<code>i</code>以使得堆重新满足最大堆的性质(注意这个时候只有节点i是不满足最大堆的性质的)，步骤如下：</p>
<ol style="list-style-type: decimal">
<li>找出节点<code>i</code>的左右孩子<code>l</code>,<code>r</code>;</li>
<li>如果<code>l</code>,<code>r</code>超过了堆的大小，直接返回，如果A[i]大于等于<code>l</code>,<code>r</code>,直接返回</li>
<li>找到<code>l</code>,<code>r</code>中的较大者,记为<code>maxIndex</code>，和<code>A[i]</code>交换</li>
<li>令i = maxIndex, 转到1。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调整节点i,使得整个堆保持最大堆的性质</div><div class="line"> * @param A</div><div class="line"> * @param i</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = A.size();</div><div class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></div><div class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">auto</span> l = left(i);</div><div class="line">    <span class="keyword">auto</span> r = right(i);</div><div class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></div><div class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(r &gt;= heap_size )&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l]) <span class="keyword">return</span>;</div><div class="line">        maxIndex = l;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整</span></div><div class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></div><div class="line">        A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r;</div><div class="line">    &#125;</div><div class="line">    swap(A[i],A[maxIndex]);</div><div class="line">    max_heap(A,maxIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 调整节点i,使得整个堆保持最小堆的性质</div><div class="line"> * @param A </div><div class="line"> * @param i </div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">min_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> heap_size = A.size();</div><div class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></div><div class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">auto</span> l = left(i);</div><div class="line">    <span class="keyword">auto</span> r = right(i);</div><div class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></div><div class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> minIndex = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(r &gt;= heap_size ) &#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &lt;= A[l]) <span class="keyword">return</span>;</div><div class="line">        minIndex = l;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 如果节点i比它两个孩子节点都小，则满足最小堆的性质，不用调整</span></div><div class="line">        <span class="keyword">if</span>(A[i] &lt;= A[l] &amp;&amp; A[i] &lt;= A[r]) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></div><div class="line">        A[l] &lt;= A[r] ? minIndex = l : minIndex = r;</div><div class="line">    &#125;</div><div class="line">    swap(A[i],A[minIndex]);</div><div class="line">    min_heap(A,minIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="建堆">建堆</h3>
<p>如何从一个无序的数组建立一个堆是堆操作中一个基本的，但很重要的问题，它通常是很多问题的第一步。</p>
<p>根据完全二叉树的性质，一个包含n个元素的数组形成的完全二叉树中，n - ([n/2] + 1) + 1个元素是叶子节点。我们只需要针对所有的叶子节点之外的节点调用上面的重建堆的函数，就可以构建一个最大堆。 时间复杂度是O(n).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从无序数组建立最大堆</div><div class="line"> * @param A</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span> ;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</div><div class="line">        max_heap(A,i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 从无序数组建立最小堆</div><div class="line"> * @param A</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_min_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</div><div class="line">        min_heap(A,i);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="堆排序">堆排序</h2>
<p>堆排序就是利用堆的结构来维护最大值或者最小值实现排序的一种算法，这里以最大堆为例来说明。 首先把无序数组重建一个最大堆，使用上面提到的函数，这一步可以轻松的在O(n)的时间复杂度内完成。 此时A[0]存储的是这个数组的最大值，将它与数组的最后一个元素交换位置，然后堆的长度减少1，也就是数组的最后一个元素不再当作堆的元素，因为它已经在正确的位置上了，然后调整堆使之符合最大堆的性质。 重复这个步骤直到所有的元素放到了正确的位置之上。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A,<span class="keyword">int</span> heap_size,<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">    <span class="comment">// 不存在这个样的节点（节点从0开始编号）</span></div><div class="line">    <span class="keyword">if</span>(i &gt;= heap_size || i &lt; <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">auto</span> l = left(i);</div><div class="line">    <span class="keyword">auto</span> r = right(i);</div><div class="line">    <span class="comment">// 如果没有孩子节点了，不需要调整了</span></div><div class="line">    <span class="keyword">if</span>(l &gt;= heap_size ) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">if</span>(r &gt;= heap_size )&#123;</div><div class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l]) <span class="keyword">return</span>;</div><div class="line">        maxIndex = l;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="comment">// 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整</span></div><div class="line">        <span class="keyword">if</span>(A[i] &gt;= A[l] &amp;&amp; A[i] &gt;= A[r]) <span class="keyword">return</span>;</div><div class="line">        <span class="comment">// 找到两个孩子节点中较大的那一个</span></div><div class="line">        A[l] &gt;= A[r] ? maxIndex = l : maxIndex = r;</div><div class="line">    &#125;</div><div class="line">    swap(A[i],A[maxIndex]);</div><div class="line">    max_heap(A,heap_size,maxIndex);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> leaf = A.size() / <span class="number">2</span> ;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = leaf - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; --i) &#123;</div><div class="line">        max_heap(A,A.size(),i);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_with_max_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</div><div class="line">    build_max_heap(v);</div><div class="line">    <span class="keyword">int</span> heap_size = v.size();</div><div class="line">    <span class="keyword">while</span>(heap_size)&#123;</div><div class="line">        swap(v[<span class="number">0</span>],v[heap_size<span class="number">-1</span>]);</div><div class="line">        heap_size--;</div><div class="line">        max_heap(v,heap_size,<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>堆排序的时间性能是nlogn,但是实际使用的时候，快速排序的性能更好一些，一般情况下都是使用快速排序。</p>
<h2 id="优先队列">优先队列</h2>
<p>优先队列是能够<code>快速</code>的完成以下操作的数据结构：</p>
<ol style="list-style-type: decimal">
<li>返回最大值</li>
<li>返回最大值并删除该元素</li>
<li>将任意一个已在优先队列中的元素增加k.</li>
<li>插入一个任意值</li>
</ol>
<p>能够维护一个数据结构，快速的实现以上所有操作的叫做优先队列。使用堆来实现优先队列，可以保证所有的操作都可以在<code>o(lgn)</code>完成。</p>
<ol style="list-style-type: decimal">
<li>返回最大值</li>
</ol>
<p>使用最大堆实现优先队列这种结构，直接返回<code>A[0]</code>就是最大值。</p>
<ol start="2" style="list-style-type: decimal">
<li>返回最大值并删除该元素</li>
</ol>
<p>首先输出<code>A[0]</code>, 然后把最后一个元素赋值给<code>A[0]</code>,调整堆使之符合最大堆性质。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span></span>&#123;</div><div class="line">    <span class="keyword">int</span> maxV = A[<span class="number">0</span>];</div><div class="line">    A[<span class="number">0</span>] = A[A.size()<span class="number">-1</span>];</div><div class="line">    <span class="keyword">int</span> heap_size = A.size()<span class="number">-1</span>;</div><div class="line">    max_heap(A,heap_size,<span class="number">0</span>);</div><div class="line">    <span class="keyword">return</span> maxV;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="直接使用stl进行堆操作">直接使用STL进行堆操作</h2>
<p>C++11 中的STL已经有了堆的各种操作的高效实现，我们可以直接使用。既能减少自己编写出错的概率，也能使得代码更加简洁，效率更高。</p>
<h3 id="建堆-1">建堆</h3>
<p><strong>建立最大堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">// v 是一个无序的数组</span></div><div class="line">make_heap(v.begin(),v.end());</div><div class="line"><span class="comment">// 或者使用</span></div><div class="line">make_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>
<p><strong>建立最小堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">make_heap(v.begin(),v.end(),greater&lt;<span class="keyword">int</span>&gt;());</div></pre></td></tr></table></figure>
<p>make_heap()方法的第三个参数其实可以传入一个函数的实例，表示你怎样比较两个元素。例如我们可以自己实现<code>less</code>方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 大根堆</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mless</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> a &lt;= b;</div><div class="line">&#125;</div><div class="line">make_heap(v.begin(),v.end(),mless);</div><div class="line"></div><div class="line"><span class="comment">//小根堆</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mgreater</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a,<span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> a &gt;= b;</div><div class="line">&#125;</div><div class="line">make_heap(v.begin(),v.end(),mgreater);</div></pre></td></tr></table></figure>
<p>当堆中存放的数据不是简单的数字，而是复杂的结构体或者类数据的时候，自定义比较函数就十分有用了，可以自定义依据类中哪个字段生成堆。</p>
<h3 id="其他与堆有关的操作">其他与堆有关的操作</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 弹出大根堆的顶部元素，重排堆，注意这个时候顶部元素没有删除，放在了数组的最后</span></div><div class="line">pop_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</div><div class="line"></div><div class="line"><span class="comment">// 弹出小根堆的顶部元素</span></div><div class="line">pop_heap(v.begin(),v.end(),greater&lt;<span class="keyword">int</span>&gt;())</div><div class="line"></div><div class="line"><span class="comment">// 把[v.begin(), v.end()-2] 作为大根堆，v.end()-1, 也就是最后一个元素作为插入元素插入到大根堆中，重新调整好顺序</span></div><div class="line">push_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</div><div class="line"></div><div class="line"><span class="comment">// 插入小根堆</span></div><div class="line">push_heap(v.begin(),v.end(),less&lt;<span class="keyword">int</span>&gt;())</div></pre></td></tr></table></figure>
<h3 id="优先队列-1">优先队列</h3>
<p><code>priority_queue&lt;Type, Container, Functional&gt;</code> 实现了优先队列的结构和相应的操作方法，可以用他来实现大根堆，小根堆，优先队列等数据结构。</p>
<p><strong>大根堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</div><div class="line"><span class="comment">// 或者使用完整的声明形式</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; less&lt;<span class="keyword">int</span>&gt;()&gt; q;</div><div class="line"></div><div class="line"><span class="comment">// 从无序数组建立大顶堆</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">30</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</div><div class="line">    q.push(v[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 弹出最大元素</span></div><div class="line">q.pop()</div></pre></td></tr></table></figure>
<p><strong>小根堆</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt; &gt; q;</div><div class="line"></div><div class="line"><span class="comment">// 从无序数组建立小顶堆</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">14</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">30</span>&#125;;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); ++i) &#123;</div><div class="line">    q.push(v[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 弹出最大元素</span></div><div class="line">q.pop()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。&lt;/p&gt;
&lt;p&gt;既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是&lt;code&gt;i&lt;/code&gt;,那么它的左孩子为&lt;code&gt;2*i&lt;/code&gt;,右孩子为&lt;code&gt;2*i+1&lt;/code&gt;,父节点为&lt;code&gt;i/2&lt;/code&gt;. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1.&lt;/p&gt;
&lt;p&gt;如果根节点是从0开始标号的，那么对于节点&lt;code&gt;i&lt;/code&gt;, 左孩子为&lt;code&gt;2*i+1&lt;/code&gt;,右孩子为&lt;code&gt;2*i+2&lt;/code&gt;,父节点为&lt;code&gt;(i-1)/2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;2017-04-11_091249.png&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_链表2</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/26/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E9%93%BE%E8%A1%A82/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/26/算法专题/算法专题_链表2/</id>
    <published>2017-07-26T10:46:20.000Z</published>
    <updated>2017-10-03T02:19:16.820Z</updated>
    
    <content type="html"><![CDATA[<p>【翻转链表】【删除重复元素】【判断有环】【合并链表】【复杂链表的复制】【…】</p>
<a id="more"></a>
<h3 id="反转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list/" target="_blank" rel="external">反转链表</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 1. 如果是空链表，或者只有一个元素，直接返回头节点</div><div class="line">* 2. pre --&gt; head, iter --&gt; head-&gt;next, pre-&gt;next = nullptr;</div><div class="line">* pre 指向第一个元素，iter指向第二个节点(可能为空，为空说明到达了链表的结尾)，断开前两个节点之间的连接</div><div class="line">* 3. while(iter!=nullptr) 转换pre iter指向的节点的连接。</div><div class="line">* 首先用一个新的节点变量存储iter的下一个节点信息，node = iter-&gt;next</div><div class="line">* iter-&gt;next = pre;</div><div class="line">* pre = iter;</div><div class="line">* iter = node;</div><div class="line">*/</div><div class="line"><span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> head;</div><div class="line">    ListNode* pre = head;</div><div class="line">    ListNode* iter = head-&gt;next;</div><div class="line">    pre-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>(iter)&#123;</div><div class="line">        ListNode* next = iter-&gt;next;</div><div class="line">        iter-&gt;next = pre;</div><div class="line">        pre = iter;</div><div class="line">        iter = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pre;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="局部翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-linked-list-ii/" target="_blank" rel="external">局部翻转链表</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">reverseBetween</span><span class="params">(ListNode * head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 翻转从m到n之间的链表，连接在原来的链表上</span></div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next || m &lt;=<span class="number">0</span> || n &lt;=<span class="number">0</span> || m &gt;= n) <span class="keyword">return</span> head;</div><div class="line">    <span class="comment">// 1. 增加一个头节点</span></div><div class="line">    ListNode* g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    g-&gt;next = head;</div><div class="line">    head = g;</div><div class="line"></div><div class="line">    ListNode* pre_start = head;</div><div class="line">    ListNode* end_next = head;</div><div class="line">    <span class="comment">// 1. 找到第m个节点的前一个节点</span></div><div class="line">    m = m - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(pre_start &amp;&amp; m--)&#123;</div><div class="line">        pre_start = pre_start-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2. 找到第n个节点的后一个节点</span></div><div class="line">    n = n + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(end_next &amp;&amp; n--)&#123;</div><div class="line">        end_next = end_next-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(m &gt;<span class="number">0</span> || n&gt;<span class="number">0</span>) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    <span class="comment">// 3. 翻转m 到 n之间的链表</span></div><div class="line">    ListNode* stmp = pre_start-&gt;next;</div><div class="line">    ListNode* start = pre_start-&gt;next;</div><div class="line">    ListNode* end = start-&gt;next;</div><div class="line">    start-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>(end != end_next)&#123;</div><div class="line">        ListNode* tmp = end-&gt;next;</div><div class="line">        end-&gt;next = start;</div><div class="line">        start = end;</div><div class="line">        end = tmp;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 4. 连接到原来的链表上</span></div><div class="line">    pre_start-&gt;next = start;</div><div class="line">    stmp-&gt;next = end;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="k组翻转链表"><a href="http://lintcode.com/zh-cn/problem/reverse-nodes-in-k-group/" target="_blank" rel="external">K组翻转链表</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">// 每K个节点翻转一下链表</span></div><div class="line">    <span class="keyword">if</span>(!head || k &lt;= <span class="number">1</span>) <span class="keyword">return</span> head;</div><div class="line">    <span class="comment">// 增加一个头节点</span></div><div class="line">    ListNode* g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    g-&gt;next = head;</div><div class="line">    head = g;</div><div class="line"></div><div class="line">    ListNode* pre_start = head;</div><div class="line">    ListNode* end_next = head;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</div><div class="line">        <span class="comment">// 1. 找到第K个节点的下一个节点</span></div><div class="line">        <span class="keyword">int</span> cc = k + <span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span>(end_next &amp;&amp; cc--)&#123;</div><div class="line">            end_next = end_next-&gt;next;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span>(cc &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 不足K个节点的部分不翻转</span></div><div class="line">        </div><div class="line">        <span class="comment">// 2. 翻转K个节点</span></div><div class="line">        ListNode* start = pre_start-&gt;next;</div><div class="line">        ListNode* stmp = pre_start-&gt;next;</div><div class="line">        ListNode* end = start-&gt;next;</div><div class="line">        <span class="keyword">while</span>(end &amp;&amp; end != end_next)&#123;</div><div class="line">            ListNode* tmp = end-&gt;next;</div><div class="line">            end-&gt;next = start;</div><div class="line">            start = end;</div><div class="line">            end = tmp;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//3. 连接到原来的链表</span></div><div class="line">        pre_start-&gt;next = start;</div><div class="line">        stmp-&gt;next = end_next;</div><div class="line"></div><div class="line">        <span class="comment">//4. 维护pre_start, end_start在正确的位置上，执行下一次循环</span></div><div class="line">        pre_start = end_next = stmp;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除链表中倒数第n个节点"><a href="http://lintcode.com/zh-cn/problem/remove-nth-node-from-end-of-list/#" target="_blank" rel="external">删除链表中倒数第n个节点</a></h3>
<p>使用两个指针，遍历一遍链表就能解决；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">*  删除倒数第K个节点，我们需要找到倒数第K+1个节点</div><div class="line">* 1. 设链表的长度是n, 1&lt;=k&lt;=n</div><div class="line">* 2. 用两个间隔是K的指针，当第二个指针指向链表的null元素的时候，第一个指针指向导数第K+1个节点</div><div class="line">* 3. 在链表的第一个节点的前面添加一个节点guard; first --&gt; guard</div><div class="line">* 4. second = guard-&gt;next; second向后移动K步，如果在K大于0的时候循环结束，表示没有导数第K个元素，返回原来的链表</div><div class="line">* 循环退出的时候，first 和second间隔K个节点，此时同时移动first second, second到达链表结尾的时候，first指向导数第K+1个节点，</div><div class="line">* 5. 删除节点： first-&gt;next = first-&gt;next-&gt;next;</div><div class="line">*/</div><div class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    ListNode *g = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    g-&gt;next = head;</div><div class="line">    head = g;</div><div class="line">    ListNode* first = g;</div><div class="line">    ListNode* second = g-&gt;next;</div><div class="line">    <span class="keyword">while</span>(second &amp;&amp; n--)&#123;</div><div class="line">        second = second -&gt; next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// n超过了链表的长度</span></div><div class="line">    <span class="keyword">while</span>(second)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next;</div><div class="line">    &#125;</div><div class="line">    first-&gt;next = first-&gt;next-&gt;next;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断链表是否有环"><a href="http://lintcode.com/zh-cn/problem/linked-list-cycle/" target="_blank" rel="external">判断链表是否有环</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 1. head=null 或者 head-&gt;next = null，肯定无环</div><div class="line">* 2. first = second = head;</div><div class="line">* 3. do&#123;&#125;while();  first == second时候循环结束，说明链表有环；</div><div class="line">* 4. 一旦找到环，把first = head, 然后一步一步的移动first second, 再次相遇的地方就是环的入口。</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ListNode* first = head;</div><div class="line">    ListNode* second = head;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next-&gt;next;</div><div class="line">    &#125;<span class="keyword">while</span>(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; second != first);</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(!first || !second || !second-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="comment">// 找到入口节点</span></div><div class="line">    first = head;</div><div class="line">    <span class="keyword">while</span>(first != second)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断链表是否相交"><a href="http://lintcode.com/zh-cn/problem/intersection-of-two-linked-lists/" target="_blank" rel="external">判断链表是否相交</a></h3>
<p>两种思路： 一种先遍历一遍两个链表，得出每个链表的长度，将尾部对其，判断</p>
<p>另外一种，将一个链表的尾部连接到其头结点，从另外一个链表的头节点开始遍历，转换成判断链表是否有环的问题。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head,ListNode* &amp;enter)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!head || !head-&gt;next || !head-&gt;next-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ListNode* first = head;</div><div class="line">    ListNode* second = head;</div><div class="line">    <span class="keyword">do</span>&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next-&gt;next;</div><div class="line">    &#125;<span class="keyword">while</span>(first &amp;&amp; second &amp;&amp; second-&gt;next &amp;&amp; first != second);</div><div class="line">    <span class="keyword">if</span>(!first || !second || !second-&gt;next) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="comment">// 找到入口节点</span></div><div class="line">    first = head;</div><div class="line">    <span class="keyword">while</span>(first != second)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next;</div><div class="line">    &#125;</div><div class="line">    enter = first;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(!headA || !headB) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    ListNode* iterA = headA;</div><div class="line">    <span class="keyword">while</span>(iterA-&gt;next !=<span class="literal">nullptr</span>)&#123;</div><div class="line">        iterA = iterA-&gt;next;</div><div class="line">    &#125;</div><div class="line">    iterA-&gt;next = headA;</div><div class="line">    ListNode* enter;</div><div class="line">    hasCycle(headB,enter);</div><div class="line">    <span class="keyword">return</span> enter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="合并k个排序的链表"><a href="http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/" target="_blank" rel="external">合并K个排序的链表</a></h3>
<ol style="list-style-type: decimal">
<li><p>第一方法，用一个数组保存K个链表的头指针，每次都比较K个元素的大小，选出最小的元素，链接到新的链表的结尾，然后该链表向下一个节点移动一位。</p></li>
<li><p>利用上面的思路，每次都要从K个元素中选择最小的元素，可以使用一个K个元素的最小堆实现，降低时间复杂度。</p></li>
<li><p>利用归并的思想，两两合并；</p></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一种方法</span></div><div class="line"></div><div class="line"><span class="comment">// 每次找出最小值的方式</span></div><div class="line"> <span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ListNode* guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode* head = guard;</div><div class="line"></div><div class="line">    <span class="comment">// current 指向K个链表的头指针</span></div><div class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; currents;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> link : lists)&#123;</div><div class="line">        <span class="keyword">if</span>(link != <span class="literal">nullptr</span>)</div><div class="line">            currents.push_back(link);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">while</span>(!currents.empty())&#123;</div><div class="line">        <span class="keyword">int</span> minV = INT32_MAX;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currents.size();++i)&#123;</div><div class="line">            <span class="comment">// 去掉已经为空的链表</span></div><div class="line">            <span class="keyword">if</span>(currents[i] == <span class="literal">nullptr</span>)&#123;</div><div class="line">                currents.erase(currents.begin()+i);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(currents[i]-&gt;val &lt; minV)&#123;</div><div class="line">                index = i;</div><div class="line">                minV = currents[i]-&gt;val;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        guard-&gt;next = currents[index];</div><div class="line">        guard = guard-&gt;next;</div><div class="line">        <span class="keyword">if</span>(currents[index]-&gt;next != <span class="literal">nullptr</span>)</div><div class="line">            currents[index] = currents[index]-&gt;next;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            currents.erase(currents.begin()+index);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二种方法， 最小堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第二种方法， 最小堆</span></div><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">    priority_queue&lt;ListNode*,<span class="built_in">vector</span>&lt;ListNode*&gt;,bigger&gt; minHeap;</div><div class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lists.size();i++)&#123;</div><div class="line">        <span class="keyword">if</span>(lists[i]) minHeap.push(lists[i]);</div><div class="line">    &#125;</div><div class="line">    ListNode *head = <span class="literal">nullptr</span>;</div><div class="line">    ListNode *iter = <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>(!minHeap.empty())&#123;</div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)&#123;</div><div class="line">            head = minHeap.top();</div><div class="line">            iter = head;</div><div class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</div><div class="line">                minHeap.push(minHeap.top()-&gt;next);</div><div class="line">            &#125;</div><div class="line">            minHeap.pop();</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            iter-&gt;next = minHeap.top();</div><div class="line">            iter = iter-&gt;next;</div><div class="line">            <span class="keyword">if</span>(minHeap.top()-&gt;next)&#123;</div><div class="line">                minHeap.push(minHeap.top()-&gt;next);</div><div class="line">            &#125;</div><div class="line">            minHeap.pop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三种方法,归并排序的方式</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第三种方法,归并排序的方式</span></div><div class="line"><span class="comment">// 通过调用合并两个排序链表的方式实现</span></div><div class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    ListNode* guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode* head = guard;</div><div class="line">    <span class="keyword">while</span>(l1 &amp;&amp; l2)&#123;</div><div class="line">        <span class="keyword">if</span>(l1-&gt;val &gt; l2-&gt;val)&#123;</div><div class="line">            guard-&gt;next = l2;</div><div class="line">            guard = guard-&gt;next;</div><div class="line">            l2 = l2-&gt;next;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            guard-&gt;next = l1;</div><div class="line">            guard = guard-&gt;next;</div><div class="line">            l1 = l1-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(l1)&#123;</div><div class="line">        guard-&gt;next = l1;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(l2)&#123;</div><div class="line">        guard-&gt;next = l2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> n = lists.size();</div><div class="line">    <span class="built_in">vector</span>&lt;ListNode*&gt; left((n+<span class="number">1</span>)/<span class="number">2</span>),right(n-(n+<span class="number">1</span>)/<span class="number">2</span>);</div><div class="line">    copy(lists.begin(),lists.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>,left.begin());</div><div class="line">    copy(lists.begin()+(n+<span class="number">1</span>)/<span class="number">2</span>,lists.end(),right.begin());</div><div class="line">    <span class="keyword">return</span> mergeTwoLists(mergeKLists(left),mergeKLists(right));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面采用的是自顶向下的递归归并的方式，下面采用非递归的自底向上的方法来实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单的实现一个数据的归并求和</span></div><div class="line"><span class="comment">// 自底向上归并</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;v)</span></span>&#123;</div><div class="line">    <span class="keyword">size_t</span> end = v.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span>(end &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="string">""</span>;</div><div class="line">    <span class="keyword">if</span>(end == <span class="number">0</span>) <span class="keyword">return</span> v[<span class="number">0</span>];</div><div class="line">    <span class="keyword">while</span>(end &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=end;i+=<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt;= end)&#123;</div><div class="line">                v[index] = add(v[i],v[i+<span class="number">1</span>]);</div><div class="line">                index++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                v[index] = v[i];</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        end = index - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> v[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode *&gt; &amp;lists)</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span>(lists.empty()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">1</span>) <span class="keyword">return</span> lists[<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span>(lists.size() == <span class="number">2</span>) <span class="keyword">return</span> mergeTwoLists(lists[<span class="number">0</span>],lists[<span class="number">1</span>]);</div><div class="line"></div><div class="line">    <span class="keyword">size_t</span> end = lists.size() - <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(end &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=end;i+=<span class="number">2</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(i+<span class="number">1</span> &lt;= end)&#123;</div><div class="line">                lists[index] = mergeTwoLists(lists[i],lists[i+<span class="number">1</span>]);</div><div class="line">                index++;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                lists[index] = lists[i];</div><div class="line">                index++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        end = index - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> lists[<span class="number">0</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="带随机指针链表的复制复杂链表的复制"><a href="http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/" target="_blank" rel="external">带随机指针链表的复制|复杂链表的复制</a></h3>
<p>使用O（1）的额外空间完成链表的复制，基本思路是把拷贝的新节点链接在原来节点的后面，设置完随机指针之后再断开与原来旧链表的连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function">RandomListNode *<span class="title">copyRandomList</span><span class="params">(RandomListNode *head)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(!head) <span class="keyword">return</span> head;</div><div class="line">    RandomListNode* iter = head;</div><div class="line">    <span class="comment">// 1. 复制每个节点连接在原来节点的后面</span></div><div class="line">    <span class="keyword">while</span>(iter)&#123;</div><div class="line">        RandomListNode* node = <span class="keyword">new</span> RandomListNode(iter-&gt;label);</div><div class="line">        node-&gt;next = iter-&gt;next;</div><div class="line">        iter-&gt;next = node;</div><div class="line">        iter = node-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 2. 设置随机指针</span></div><div class="line">    RandomListNode* newHead = head-&gt;next;</div><div class="line">    head-&gt;next-&gt;random = head-&gt;random==<span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : head-&gt;random-&gt;next;</div><div class="line">    iter = newHead-&gt;next;</div><div class="line">    <span class="keyword">while</span>(iter)&#123;</div><div class="line">        RandomListNode* next = iter-&gt;next-&gt;next;</div><div class="line">        iter-&gt;next-&gt;random = iter-&gt;random == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : iter-&gt;random-&gt;next;</div><div class="line">        iter = next;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 3. 断开和旧链表的连接</span></div><div class="line">    iter = newHead;</div><div class="line">    <span class="keyword">while</span>(iter-&gt;next)&#123;</div><div class="line">        iter-&gt;next = iter-&gt;next-&gt;next;</div><div class="line">        iter = iter-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除链表元素"><a href="http://lintcode.com/zh-cn/problem/remove-linked-list-elements/" target="_blank" rel="external">删除链表元素</a></h3>
<p>删除链表节点为某个值的所有元素。(某个值可能有多个，也可能全部都是)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">removeElements</span><span class="params">(ListNode *head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">       <span class="comment">// Write your code here</span></div><div class="line">       ListNode *guard=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       guard-&gt;next = head;</div><div class="line">       head = guard;</div><div class="line"></div><div class="line">       ListNode *pre = guard;</div><div class="line">       ListNode *tmp = guard-&gt;next;</div><div class="line">       <span class="keyword">while</span>(tmp)&#123;</div><div class="line">           <span class="keyword">if</span>(tmp-&gt;val == val)&#123;</div><div class="line">               pre-&gt;next = tmp-&gt;next;</div><div class="line">               tmp = tmp-&gt;next;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               pre = tmp;</div><div class="line">               tmp = tmp -&gt; next;</div><div class="line">           &#125;</div><div class="line"></div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> head-&gt;next;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>不使用哨兵的方法，在要求不使用额外空间的时候可以用这种方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">removeElements</span><span class="params">(ListNode *head, <span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">       <span class="comment">// Write your code here</span></div><div class="line">       <span class="comment">// 删除链表中等于给定值val的所有节点</span></div><div class="line">       <span class="keyword">while</span>(head &amp;&amp; head-&gt;val == val)&#123;</div><div class="line">           head = head-&gt;next;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">       ListNode *pre = head;</div><div class="line">       ListNode *c = head-&gt;next; <span class="comment">// 头结点已经不可能==val了，因为前面已经删除了</span></div><div class="line">       <span class="keyword">while</span>(c)&#123;</div><div class="line">           <span class="keyword">if</span>(c-&gt;val == val)&#123;</div><div class="line">               pre-&gt;next = c-&gt;next;</div><div class="line">               c-&gt;next= <span class="literal">nullptr</span>;</div><div class="line">               c = pre-&gt;next;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               pre = c;</div><div class="line">               c = c-&gt;next;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在o1时间复杂度删除链表节点"><a href="http://lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/" target="_blank" rel="external">在O(1)时间复杂度删除链表节点</a></h3>
<p>思路：给出要删除的节点，是不可能在O(1)的时间内删除该节点的，因为想要删除该节点，必须找到它前面的节点，这个操作只能从头遍历(在没有指向前面的指针的情况下)，复杂度不可能是O(1). 但是可以把要删除的节点后面的节点的值赋给要删除的节点，再删除要删除的节点后面的节点，这样’看起来’好像删除了当前的节点。实际上在计算机内存中真正的变化是要删除的节点的值变成了它后面节点的值.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode *node)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        node-&gt;val = node-&gt;next-&gt;val;</div><div class="line">        node-&gt;next = node-&gt;next-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素"><a href="http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list/" target="_blank" rel="external">删除排序链表中的重复元素</a></h3>
<p>给定一个排序链表，删除所有重复的元素每个重复元素只留下一个。</p>
<p>遇到不同的元素的时候再删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">        ListNode *pre = head;</div><div class="line">        ListNode *current = head-&gt;next;</div><div class="line">        <span class="keyword">while</span>(current)&#123;</div><div class="line">            <span class="keyword">if</span>(pre-&gt;val == current-&gt;val)&#123;</div><div class="line">                current = current-&gt;next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                pre-&gt;next = current;</div><div class="line">                pre = current;</div><div class="line">                current = current-&gt;next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 链表结尾有重复元素的情况</span></div><div class="line">        pre-&gt;next = current;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一旦遇到相同的元素就删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">        <span class="comment">// 给定一个排序链表，删除所有重复的元素每个元素只留下一个。</span></div><div class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">        <span class="keyword">if</span>(head-&gt;next-&gt;next == <span class="literal">nullptr</span> &amp;&amp; head-&gt;val == head-&gt;next-&gt;val) <span class="keyword">return</span> head-&gt;next;</div><div class="line">        ListNode *pre = head;</div><div class="line">        ListNode *c = head-&gt;next;</div><div class="line">        <span class="keyword">while</span>(c)&#123;</div><div class="line">            <span class="keyword">if</span>(pre-&gt;val == c-&gt;val)&#123;</div><div class="line">                pre-&gt;next = c-&gt;next;</div><div class="line">                c = c-&gt;next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                pre = pre-&gt;next;</div><div class="line">                c = c-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除排序链表中的重复元素2"><a href="http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="external">删除排序链表中的重复元素2</a></h3>
<p>给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">       <span class="comment">//给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</span></div><div class="line">       ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">       guard-&gt;next = head;</div><div class="line">       head = guard;</div><div class="line"></div><div class="line">       ListNode *pre = guard;</div><div class="line">       ListNode *start = guard-&gt;next;</div><div class="line">       ListNode *end = guard-&gt;next;</div><div class="line">       <span class="keyword">while</span>(end)&#123;</div><div class="line">           <span class="keyword">while</span>(end &amp;&amp; start-&gt;val == end-&gt;val)&#123;</div><div class="line">               end = end-&gt;next;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">if</span>(start-&gt;next == end)&#123;</div><div class="line">               pre = start;</div><div class="line">               start = end;</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               pre-&gt;next = end;</div><div class="line">               start = end;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不使用哨兵节点的方案</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode * <span class="title">deleteDuplicates</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="comment">//给定一个排序链表，删除所有重复的元素只留下原链表中没有重复的元素。</span></div><div class="line">    ListNode *pre = head;</div><div class="line">    ListNode *start = head;</div><div class="line">    ListNode *end = head;</div><div class="line">    <span class="keyword">while</span>(end)&#123;</div><div class="line">        <span class="keyword">while</span>(end &amp;&amp; start-&gt;val == end-&gt;val)&#123;</div><div class="line">            end = end-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(start-&gt;next == end)&#123;</div><div class="line">            pre = start;</div><div class="line">            start = end;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">if</span>(pre == start &amp;&amp; pre == head)&#123;</div><div class="line">                head = end;</div><div class="line">                pre = end;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>    pre-&gt;next = end;</div><div class="line">            start = end;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="删除单向链表中倒数第k个节点">删除单向链表中倒数第K个节点</h3>
<p>例如：<code>head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;5--&gt;6</code> K=2 返回：<code>head--&gt;1--&gt;2--&gt;3--&gt;4--&gt;6</code></p>
<p>思路一： 先遍历一遍链表，统计链表有多少个元素。然后就可以知道倒数第K个元素就是 正数第n-k+1个元素，从head开始移动指针，移动n-k次就是要删除的节点。 删除一个节点，只需要把原来指向这个元素的指针指向它后面的元素就可以了。所以我们要做的 操作就是从head开始，移动n-k-1次，找到要删除的节点前面的节点a,然后执行a-&gt;next = a-&gt;next-&gt;next</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">    ListNode *tmp = head;</div><div class="line">    <span class="keyword">while</span>(tmp)&#123;</div><div class="line">        len ++;</div><div class="line">        tmp = tmp-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(len &lt; n) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">if</span>(len == n) <span class="keyword">return</span> head-&gt;next;</div><div class="line"></div><div class="line">    tmp = head;</div><div class="line">    <span class="keyword">int</span> count = len + <span class="number">1</span> - n  ;<span class="comment">// 正数第count个节点</span></div><div class="line">    count = count - <span class="number">2</span>;</div><div class="line">    <span class="keyword">while</span>(count--)&#123;</div><div class="line">        tmp = tmp-&gt;next;</div><div class="line">    &#125;</div><div class="line">    tmp-&gt;next = tmp-&gt;next-&gt;next;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>思路二：使用两个间隔K个元素的指针遍历一遍链表，当前面的指针走到尾节点的时候，后面的节点指向的就是倒数第K个节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">removeNthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">    ListNode *first = head;</div><div class="line">    ListNode *second = head;</div><div class="line">    <span class="keyword">int</span> count = n + <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(first &amp;&amp; count--)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(first == <span class="literal">nullptr</span>) <span class="keyword">return</span> head-&gt;next; <span class="comment">// 删除第一个节点</span></div><div class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>; <span class="comment">// 没有导数第n个节点</span></div><div class="line">    <span class="keyword">while</span>(first)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next;</div><div class="line">    &#125;</div><div class="line">    second-&gt;next = second-&gt;next-&gt;next;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="查找链表的中间节点">查找链表的中间节点</h3>
<p>思路： 设置两个指针同时指向头部，一个指针每次移动两步，一个指针每次移动一步，这样在快的指针走到尽头的时候，慢的指针恰好走到了中部。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到链表的中间节点并返回</div><div class="line"> * @param head</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode *first = head, *second = head;</div><div class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序使用单链表实现">插入排序（使用单链表实现）</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">insertionSortList</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="comment">// 使用链表实现插入排序</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    ListNode *guard = <span class="keyword">new</span> ListNode(INT32_MIN);</div><div class="line">    guard-&gt;next = head;</div><div class="line">    head = guard;</div><div class="line"></div><div class="line">    ListNode *sorted = guard;</div><div class="line">    ListNode *ends = guard-&gt;next;</div><div class="line">    ListNode *unsorted = ends-&gt;next;</div><div class="line">    ends-&gt;next = <span class="literal">nullptr</span>; <span class="comment">// 链表断开</span></div><div class="line">    <span class="keyword">while</span>(unsorted)&#123;</div><div class="line">        <span class="comment">// 找到插入的位置</span></div><div class="line">        <span class="keyword">while</span>(sorted != ends)&#123;</div><div class="line">            <span class="keyword">if</span>(unsorted-&gt;val &gt;= sorted-&gt;val &amp;&amp; unsorted-&gt;val &lt; sorted-&gt;next-&gt;val)&#123;</div><div class="line">                <span class="comment">// 插入到iter1后面</span></div><div class="line">                ListNode *tmp = unsorted;</div><div class="line">                unsorted = unsorted-&gt;next;</div><div class="line">                tmp-&gt;next = sorted-&gt;next;</div><div class="line">                sorted-&gt;next = tmp;</div><div class="line">                sorted = guard;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">            sorted = sorted-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(sorted == ends &amp;&amp; unsorted-&gt;val &gt;= ends-&gt;val)&#123;</div><div class="line">            ends-&gt;next = unsorted;</div><div class="line">            unsorted = unsorted-&gt;next;</div><div class="line">            ends = ends-&gt;next;</div><div class="line">            ends-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">            sorted = guard;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="快速排序单链表实现">快速排序(单链表实现)</h3>
<p>快速排序一般的思想是首尾两个指针相向运动，但是单链表没有向前的指针，这要求我们换一种思路。如何从前往后遍历找到支点的位置。假设支点的值是value. 我们需要遍历一遍链表，使得所有小于value的值都在前面，所有大于value的值都在后面，这个时候就找到的value应该在的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 单链表实现快排</span></div></pre></td></tr></table></figure>
<h3 id="交换链表当中两个节点"><a href="http://lintcode.com/zh-cn/problem/swap-two-nodes-in-linked-list/" target="_blank" rel="external">交换链表当中两个节点</a></h3>
<p>给你一个链表以及两个权值v1和v2，交换链表中权值为v1和v2的这两个节点。保证链表中节点权值各不相同，如果没有找到对应节点，那么什么也不用做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">swapNodes</span><span class="params">(ListNode* head, <span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</div><div class="line">    <span class="comment">// Write your code here</span></div><div class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">    <span class="comment">// add a guard</span></div><div class="line">    ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    guard-&gt;next = head;</div><div class="line">    head = guard;</div><div class="line"></div><div class="line">    <span class="comment">//search the value</span></div><div class="line">    ListNode *pre_v1=<span class="literal">nullptr</span>;</div><div class="line">    ListNode *pre_v2=<span class="literal">nullptr</span>;</div><div class="line">    ListNode *pre_tmp=guard;</div><div class="line">    ListNode *tmp=pre_tmp-&gt;next;</div><div class="line">    <span class="keyword">while</span>(tmp)&#123;</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;val==v1)&#123;</div><div class="line">            pre_v1 = pre_tmp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(tmp-&gt;val==v2)&#123;</div><div class="line">            pre_v2 = pre_tmp;</div><div class="line">        &#125;</div><div class="line">        pre_tmp = tmp;</div><div class="line">        tmp = tmp-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// not find v1 or v2</span></div><div class="line">    <span class="keyword">if</span>(pre_v1==<span class="literal">nullptr</span> || pre_v2==<span class="literal">nullptr</span>)&#123;</div><div class="line">        <span class="keyword">return</span> head-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// swap the two nodes</span></div><div class="line">    ListNode *v1s = pre_v1-&gt;next;</div><div class="line">    ListNode *v2s = pre_v2-&gt;next;</div><div class="line">    ListNode *next_v1 = v1s-&gt;next;</div><div class="line">    ListNode *next_v2 = v2s-&gt;next;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(pre_v1 == v2s)&#123;</div><div class="line">        pre_v2-&gt;next = v1s;</div><div class="line">        v1s-&gt;next = v2s;</div><div class="line">        v2s-&gt;next = next_v1;</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pre_v2 == v1s)&#123;</div><div class="line">        pre_v1-&gt;next = v2s;</div><div class="line">        v2s-&gt;next = v1s;</div><div class="line">        v1s-&gt;next = next_v2;</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        v1s-&gt;next = next_v2;</div><div class="line">        v2s-&gt;next = next_v1;</div><div class="line">        pre_v1-&gt;next = v2s;</div><div class="line">        pre_v2-&gt;next = v1s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="两两交换链表中的节点"><a href="http://lintcode.com/zh-cn/problem/swap-nodes-in-pairs/" target="_blank" rel="external">两两交换链表中的节点</a></h3>
<p>给一个链表，两两交换其中的节点，然后返回交换后的链表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">        <span class="comment">// Write your code here</span></div><div class="line">        <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line"></div><div class="line">        ListNode *guard = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">        guard-&gt;next = head;</div><div class="line">        head = guard;</div><div class="line"></div><div class="line">        ListNode *pres1 = guard;</div><div class="line">        ListNode *s1 = guard-&gt;next;</div><div class="line">        ListNode *s2 = guard-&gt;next-&gt;next;</div><div class="line">        <span class="keyword">while</span>(s1!=<span class="literal">nullptr</span> &amp;&amp; s2!=<span class="literal">nullptr</span>)&#123;</div><div class="line">            pres1-&gt;next = s2;</div><div class="line">            s1-&gt;next = s2-&gt;next;</div><div class="line">            s2-&gt;next = s1;</div><div class="line">            <span class="keyword">if</span>(s1-&gt;next==<span class="literal">nullptr</span> || s1-&gt;next-&gt;next==<span class="literal">nullptr</span>)&#123;</div><div class="line">                <span class="keyword">return</span> head-&gt;next;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                pres1 = s1;</div><div class="line">                s1 = s1-&gt;next;</div><div class="line">                s2 = s2-&gt;next-&gt;next-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> head-&gt;next;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="旋转链表"><a href="http://lintcode.com/zh-cn/problem/rotate-list/" target="_blank" rel="external">旋转链表</a></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">rotateRight</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    <span class="comment">//给定一个链表，旋转链表，使得每个节点向右移动k个位置，其中k是一个非负数</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span> || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode *end = head;</div><div class="line">    <span class="keyword">int</span> len = <span class="number">1</span>;</div><div class="line">    <span class="keyword">while</span>(end-&gt;next)&#123;</div><div class="line">        end = end-&gt;next;</div><div class="line">        len++;</div><div class="line">    &#125;</div><div class="line">    k = k % len;</div><div class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">return</span> head;</div><div class="line">    <span class="keyword">int</span> index = (len - <span class="number">1</span> - k) % len;</div><div class="line">    ListNode *tmp = head;</div><div class="line">    <span class="keyword">while</span>(tmp &amp;&amp; index --)&#123;</div><div class="line">        tmp = tmp-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(index == <span class="number">-1</span>)&#123;</div><div class="line">        end-&gt;next = head;</div><div class="line">        head = tmp-&gt;next;</div><div class="line">        tmp-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="首尾交错重排链表"><a href="http://lintcode.com/zh-cn/problem/reorder-list/" target="_blank" rel="external">首尾交错重排链表</a></h3>
<p>给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到链表的中间节点并返回</div><div class="line"> * @param head</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ListNode* <span class="title">findMiddle</span><span class="params">(ListNode* head)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode *first = head, *second = head;</div><div class="line">    <span class="keyword">while</span>(second-&gt;next &amp;&amp; second-&gt;next-&gt;next)&#123;</div><div class="line">        first = first-&gt;next;</div><div class="line">        second = second-&gt;next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> first;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 反转链表</div><div class="line"> * @param head</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ListNode *<span class="title">reverse</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">if</span>(head==<span class="literal">nullptr</span> || head-&gt;next==<span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">    ListNode *iter =head;</div><div class="line">    ListNode *next_iter = head-&gt;next;</div><div class="line">    iter-&gt;next=<span class="literal">nullptr</span>;</div><div class="line">    <span class="keyword">while</span>(next_iter)&#123;</div><div class="line">        ListNode *tmp = next_iter-&gt;next;</div><div class="line">        next_iter-&gt;next = iter;</div><div class="line">        iter = next_iter;</div><div class="line">        next_iter = tmp;</div><div class="line">    &#125;</div><div class="line">    head = iter;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 交叉合并两个链表</div><div class="line"> * @param l1</div><div class="line"> * @param l2</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果其中一个链表为空，直接返回另外一个链表就是结果</span></div><div class="line">    <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</div><div class="line">    <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</div><div class="line">    ListNode *head = l1;</div><div class="line">    l1 = l1-&gt;next;</div><div class="line">    ListNode *iter = head;</div><div class="line">    <span class="keyword">bool</span> odd = <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> || l2 != <span class="literal">nullptr</span>)&#123;</div><div class="line">        <span class="keyword">if</span>(!odd)&#123;</div><div class="line">            <span class="keyword">if</span>(l2)&#123;</div><div class="line">                iter-&gt;next = l2;</div><div class="line">                l2 = l2-&gt;next;</div><div class="line">                iter = iter-&gt;next;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(odd)&#123;</div><div class="line">            <span class="keyword">if</span>(l1)&#123;</div><div class="line">                iter-&gt;next = l1;</div><div class="line">                l1 = l1-&gt;next;</div><div class="line">                iter = iter-&gt;next;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        odd = !odd;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode* <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</div><div class="line">    <span class="comment">// 给定一个单链表L: L0→L1→…→Ln-1→Ln,重新排列后为：L0→Ln→L1→Ln-1→L2→Ln-2→…必须在不改变节点值的情况下进行原地操作</span></div><div class="line">    <span class="comment">// 找到中间节点， 反转后半段，然后交叉拼接起来，可以确保不适用额外的空间</span></div><div class="line">    ListNode* middle = findMiddle(head);</div><div class="line">    ListNode* head2 = reverse(middle-&gt;next);</div><div class="line">    middle-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    head = mergeTwoLists(head,head2);</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="回文链表"><a href="http://lintcode.com/zh-cn/problem/palindrome-linked-list/" target="_blank" rel="external">回文链表</a></h3>
<p>判断一个链表中的值是否是回文</p>
<p>找到中间节点，把后面的链表反转，然后与前面的逐个节点比较，如果完全一样或者只有最后一个节点不一样，则是回文的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</div><div class="line">    <span class="comment">// Write your code here</span></div><div class="line">    <span class="keyword">if</span>(head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    ListNode *middle = findMiddle(head);</div><div class="line">    ListNode *head2 = reverse(middle-&gt;next);</div><div class="line">    middle-&gt;next = <span class="literal">nullptr</span>;</div><div class="line">    ListNode *iter1 = head, *iter2 = head2;</div><div class="line">    <span class="keyword">while</span>(iter1 &amp;&amp; iter2)&#123;</div><div class="line">        <span class="keyword">if</span>(iter1-&gt;val != iter2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        iter1 = iter1-&gt;next;</div><div class="line">        iter2 = iter2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(iter1 &amp;&amp; iter1-&gt;next == <span class="literal">nullptr</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(iter2 &amp;&amp; iter2-&gt;next == <span class="literal">nullptr</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(iter1 == <span class="literal">nullptr</span> &amp;&amp; iter2 == <span class="literal">nullptr</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表求和"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers/" target="_blank" rel="external">链表求和</a></h3>
<p>你有两个用链表代表的整数，其中每个节点包含一个数字。数字存储按照在原来整数中相反的顺序，使得第一个数字位于链表的开头。写出一个函数将两个整数相加，用链表形式返回和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">addLists</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span>(l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</div><div class="line">    <span class="keyword">if</span>(l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</div><div class="line">    <span class="comment">// 链表求和</span></div><div class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</div><div class="line">    ListNode *head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</div><div class="line">    ListNode *iter = head;</div><div class="line">    <span class="keyword">int</span> number;</div><div class="line">    <span class="keyword">while</span>(l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>)&#123;</div><div class="line">        number = (l1-&gt;val + l2-&gt;val + carry ) % <span class="number">10</span> ;</div><div class="line">        carry = (l1-&gt;val + l2-&gt;val + carry ) / <span class="number">10</span> ;</div><div class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</div><div class="line">        iter-&gt;next = node;</div><div class="line">        iter = iter-&gt;next;</div><div class="line">        l1 = l1-&gt;next;</div><div class="line">        l2 = l2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(l1)&#123;</div><div class="line">        number = (l1-&gt;val + carry) % <span class="number">10</span>;</div><div class="line">        carry = (l1-&gt;val + carry) / <span class="number">10</span>;</div><div class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</div><div class="line">        iter-&gt;next = node;</div><div class="line">        iter = iter-&gt;next;</div><div class="line">        l1 = l1-&gt;next;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span>(l2)&#123;</div><div class="line">        number = (l2-&gt;val + carry) % <span class="number">10</span>;</div><div class="line">        carry = (l2-&gt;val + carry) / <span class="number">10</span>;</div><div class="line">        ListNode *node = <span class="keyword">new</span> ListNode(number);</div><div class="line">        iter-&gt;next = node;</div><div class="line">        iter = iter-&gt;next;</div><div class="line">        l2 = l2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(carry)&#123;</div><div class="line">        ListNode *node = <span class="keyword">new</span> ListNode(carry);</div><div class="line">        iter-&gt;next = node;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head-&gt;next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="链表求和-ii"><a href="http://lintcode.com/zh-cn/problem/add-two-numbers-ii/#" target="_blank" rel="external">链表求和 II</a></h3>
<p>假定用一个链表表示两个数，其中每个节点仅包含一个数字。假设这两个数的数字顺序排列，请设计一种方法将两个数相加，并将其结果表现为链表的形式。</p>
<p>先翻转链表，求和，在翻转回去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ListNode *<span class="title">addLists2</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> reverse(addLists(reverse(l1),reverse(l2)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;【翻转链表】【删除重复元素】【判断有环】【合并链表】【复杂链表的复制】【…】&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
  <entry>
    <title>英语</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/24/%E8%8B%B1%E8%AF%AD/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/24/英语/</id>
    <published>2017-07-24T14:26:56.000Z</published>
    <updated>2017-07-31T15:02:23.848Z</updated>
    
    <content type="html"><![CDATA[<p>英语语言方面相关的内容，包括专业术语，缩写，常用短语，小故事。 <a id="more"></a></p>
<h2 id="常用短语">常用短语</h2>
<ol style="list-style-type: decimal">
<li>提供极有用的信息 – provide invalueable information</li>
<li>右利手的被试 – right-handed participants</li>
<li>构建于Matlab内部的 – with in-house MATLAB scripts</li>
<li>提供机制方面的解释能力 – afford mechanistic interpretability</li>
<li>相比于传统的方法 – over conventional method</li>
<li>外部的|内部的 – extrinsic|intrinsic</li>
<li>把…归因为… – ascribes</li>
<li>变量未知和随机 – unknown and stochastic</li>
<li>在括号里的 – in brackets</li>
</ol>
<h2 id="广告">广告</h2>
<p><strong>DAU</strong>, dailyactive user, 日活跃用户</p>
<p><strong>MAU</strong>, monthactive user, 月活跃用户</p>
<p><strong>CPM</strong>, cost per mille, 前人展现成本，按照看到的人数付费。</p>
<p><strong>CPC</strong>, cost per click, 按照点击广告的用户数量付费。</p>
<p><strong>CPA</strong>, cost per action, 按照回应付费，即用户不仅仅点击了广告，还回应了(注册、互动、下载、下单、购买)。</p>
<p><strong>pv</strong>, pageview, 页面浏览量或点击量</p>
<p><strong>uv</strong>, uniquevisitor,统计访问网站的不同IP数量</p>
<h2 id="其他">其他</h2>
<p><strong>IP</strong>, intellectual property, 知识产权</p>
<p><strong>ACG</strong>, animation, comic, game, 动画，漫画，游戏</p>
<p><strong>KOL</strong>, key opinion leader, 有话语权的人</p>
<p><strong>UGC</strong>, user generated content, 用户生成内容</p>
<p><strong>TMT</strong>, technology, media, telecom, 数字新媒体。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;英语语言方面相关的内容，包括专业术语，缩写，常用短语，小故事。
    
    </summary>
    
      <category term="英语" scheme="http://ff120.github.io/hexoblog/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
      <category term="English" scheme="http://ff120.github.io/hexoblog/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>Visual Studio Code使用技巧</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/24/%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/Visual-Studio-Code%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/24/工具的使用/Visual-Studio-Code使用技巧/</id>
    <published>2017-07-24T13:31:40.000Z</published>
    <updated>2017-07-31T15:02:04.751Z</updated>
    
    <content type="html"><![CDATA[<p>Visual Studio Code 是微软出的一个文本编辑工具，与SublimeText, Atom, Vim定位是一样的，都是带扩展功能的文本编辑器，可以安装多种扩张插件，实现IDE的功能。</p>
<a id="more"></a>
<p>Visual Studio Code 与Atom相比，最大的优点就是响应速度快，如果使用Windows系统，Visual Studio Code无疑是首选。使用习惯与Atom, SumlimeText都是一样的。</p>
<p>安装地址：<a href="https://code.visualstudio.com/" target="_blank" rel="external">VSCode</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Visual Studio Code 是微软出的一个文本编辑工具，与SublimeText, Atom, Vim定位是一样的，都是带扩展功能的文本编辑器，可以安装多种扩张插件，实现IDE的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://ff120.github.io/hexoblog/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://ff120.github.io/hexoblog/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>机器学习_Numpy使用技巧</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%93%E9%A2%98/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-Numpy%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/23/机器学习专题/机器学习-Numpy使用技巧/</id>
    <published>2017-07-23T01:50:10.000Z</published>
    <updated>2017-07-31T15:02:04.892Z</updated>
    
    <content type="html"><![CDATA[<p>NumPy的主要对象是齐次多维数组。表由相同类型的元素组成（通常为数字），由一个正整数元组索引。在NumPy中维数被称为轴，轴数称为秩。例如，一个三维空间中点的坐标[1,2,1]是一个秩为1的数组，因为其轴数为1，轴的长度为3。在下图中，数组的秩为2（2维），第二维的长度为3。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[ 1., 0., 0.],</div><div class="line"> [ 0., 1., 2.]]</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="随机打乱数据">随机打乱数据</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line">random_y = np.random.permutation(y)</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NumPy的主要对象是齐次多维数组。表由相同类型的元素组成（通常为数字），由一个正整数元组索引。在NumPy中维数被称为轴，轴数称为秩。例如，一个三维空间中点的坐标[1,2,1]是一个秩为1的数组，因为其轴数为1，轴的长度为3。在下图中，数组的秩为2（2维），第二维的长度为3。 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[[ 1., 0., 0.],&lt;/div&gt;&lt;div class=&quot;line&quot;&gt; [ 0., 1., 2.]]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="编程语言" scheme="http://ff120.github.io/hexoblog/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="python" scheme="http://ff120.github.io/hexoblog/tags/python/"/>
    
      <category term="numpy" scheme="http://ff120.github.io/hexoblog/tags/numpy/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_并查集</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/23/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/23/算法专题/算法专题_并查集/</id>
    <published>2017-07-22T16:22:37.000Z</published>
    <updated>2017-07-23T00:47:50.452Z</updated>
    
    <content type="html"><![CDATA[<p>并查集可以高效的维护数据的分组信息，并可以快速完成以下操作：</p>
<blockquote>
<ul>
<li>查询元素a和元素b是否属于同一个组</li>
<li>合并元素a和元素b所在的组</li>
</ul>
</blockquote>
<p>并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。</p>
<a id="more"></a>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;并查集可以高效的维护数据的分组信息，并可以快速完成以下操作：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;查询元素a和元素b是否属于同一个组&lt;/li&gt;
&lt;li&gt;合并元素a和元素b所在的组&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;并查集使用一棵树来维护一个分组的信息，多棵树构成的森林表示这个完整的数据结构。如果查询a和b是否属于同一组，只需要向上搜索直到树根，看a和b的树根是否一样就可以了。如果要合并a和b所在的分组，只需要把a和b连在一起就可以了，通常是把a和b所在树的树根连在一起。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
      <category term="并查集" scheme="http://ff120.github.io/hexoblog/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_树状数组</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/23/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/23/算法专题/算法专题_树状数组/</id>
    <published>2017-07-22T16:18:24.000Z</published>
    <updated>2017-07-31T15:02:22.597Z</updated>
    
    <content type="html"><![CDATA[<p>树状数组是一个能够快速完成下术操作的数据结构：</p>
<blockquote>
<ul>
<li>给定一个初始值全为0的数列，a1,a2,a3,a4,…an</li>
<li>给定i,计算a1+a2+…+ai</li>
<li>给定i和x,计算ai = ai + x;</li>
</ul>
</blockquote>
<a id="more"></a>
<p>上面提到的线段树其实已经满足了上面的要求，只不过有些(大材小用了)。可以用更简单的结构实现这个要求。</p>
<div class="figure">
<img src="2017-04-12_161624.png" alt="2017-04-12_161624.png">
<p class="caption">2017-04-12_161624.png</p>
</div>
<p>把线段树所有的右节点去掉，只剩下左节点，然后对应的位置不变，投射到最下面一行，就形成了树状数组的结构。例如8个元素的树状数组的结构是：</p>
<table>
<thead>
<tr class="header">
<th>A[1]</th>
<th>A[2]</th>
<th>A[3]</th>
<th>A[4]</th>
<th>A[5]</th>
<th>A[6]</th>
<th>A[7]</th>
<th>A[8]</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>[1,2]</td>
<td>3</td>
<td>[1,4]</td>
<td>5</td>
<td>[5,6]</td>
<td>7</td>
<td>[1,8]</td>
<td></td>
</tr>
<tr class="even">
<td>0001</td>
<td>0010</td>
<td>0011</td>
<td>0100</td>
<td>0101</td>
<td>0110</td>
<td>0111</td>
<td>1000</td>
<td></td>
</tr>
</tbody>
</table>
<p>有了上面的结构，如果想求<code>c[3]+c[4]+c[5]</code>就是<code>A[4]-A[2]+A[5]</code>; 如果想求<code>c[4]</code>,就是<code>A[4]-A[3]-A[2]</code>; 总之，一个区间内的和总可以在常数时间内通过树状数组中的值求出来。树状数组可以使用位来保存，通过寻找其中的规律，可以使用简单的位操作实现树状数组的求和和更新。上面表格的最后一行是对树状数组A进行的二进制的编码。 求树状数组的前i项和：</p>
<table>
<thead>
<tr class="header">
<th>i</th>
<th>表达式</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>A[1]</td>
<td>0001</td>
</tr>
<tr class="even">
<td>2</td>
<td>A[2]</td>
<td>0010</td>
</tr>
<tr class="odd">
<td>3</td>
<td>A[3]+A[2]</td>
<td>0011+0010</td>
</tr>
<tr class="even">
<td>4</td>
<td>A[4]</td>
<td>0100</td>
</tr>
<tr class="odd">
<td>5</td>
<td>A[5]+A[4]</td>
<td>0101+0100</td>
</tr>
<tr class="even">
<td>6</td>
<td>A[6]+A[4]</td>
<td>0110+0100</td>
</tr>
<tr class="odd">
<td>7</td>
<td>A[7]+A[6]+A[4]</td>
<td>0111+0110+0100</td>
</tr>
<tr class="even">
<td>8</td>
<td>A[8]</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>从二进制当中寻找规律，求前i项：</p>
<blockquote>
<ol style="list-style-type: decimal">
<li>初始化sum=0;</li>
<li>从树状数组A[i]开始，把A[i]加入到结果中去。然后从i中减去i最低位1对应的数字。i的最低位的1对应的数字的值的大小可以用<code>i&amp;(-i)</code>求得。</li>
<li>直到i的结果为0停止。</li>
</ol>
</blockquote>
<p>按照上面的步骤分析上面表格中的每一行的求解：</p>
<blockquote>
<ul>
<li>0001减去最后一位二进制1对应的数字（1）之后为0，所以最后结果是A[1]</li>
<li>0010减去最后一位二进制1对应的数字(2)之后为0，所以最后的结果是A[2]</li>
<li>0011减去最后以为二进制1对应的数字(1)之后为(0010,A[2]),而0010减去最后一位二进制1对应的数字(2)之后为0,所以最后的结果是A[3]+A[2]</li>
<li>0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[4]</li>
<li>0101减去最后以为二进制1对应的数字(1)之后为0100,0100减去最后以为二进制1对应的数字(4)之后为0,所以最后的结果是A[5]+A[4]</li>
<li>0110 = 0110 + 0100 = A[6] + A[4]</li>
<li>0111 = 0111 + 0110 + 0100 + A[7] + A[6] + A[4]</li>
<li>1000 = 1000 = A[8]</li>
</ul>
</blockquote>
<p>上面就是BIT数组求和的详细解释，了解了这个过程，在知道如何求解一个数字最低位1对应的值，实现BIT的求和应该不难。下面看看BIT如何更新。 假如我们想更新c[2]的值，那么A中所有包含c[2]的值都可能发生变化，到底哪些值包含c[2]呢？从上面的表格我们看出，包含c[2]的A元素有A[2],A[4],A[8];下面再列一个表格，显示每个元素的更新都涉及哪些元素，这样就比较容易找到其中的规律。</p>
<table>
<thead>
<tr class="header">
<th>更新的值</th>
<th>涉及的BIT</th>
<th>二进制表示</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>c[1]</td>
<td>A[1],A[2],A[4],A[8]</td>
<td>0001,0010,0100,1000</td>
</tr>
<tr class="even">
<td>c[2]</td>
<td>A[2],A[4],A[8]</td>
<td>0010,0100,1000</td>
</tr>
<tr class="odd">
<td>c[3]</td>
<td>A[3],A[4],A[8]</td>
<td>0011,0100,1000</td>
</tr>
<tr class="even">
<td>c[4]</td>
<td>A[4],A[8]</td>
<td>0100,1000</td>
</tr>
<tr class="odd">
<td>c[5]</td>
<td>A[5],A[6],A[8]</td>
<td>0101,0110,1000</td>
</tr>
<tr class="even">
<td>c[6]</td>
<td>A[6],A[8]</td>
<td>0110,1000</td>
</tr>
<tr class="odd">
<td>c[7]</td>
<td>A[7],A[8]</td>
<td>0111,1000</td>
</tr>
<tr class="even">
<td>c[8]</td>
<td>A[8]</td>
<td>1000</td>
</tr>
</tbody>
</table>
<p>可以看到，更新的时候和求和的时候顺序似乎相反，规律是：如果要更新c[i],那么就从i开始，更新A[i]之后将i更新为<code>i = i+(i&amp;(-i))</code>,直到最后一个元素为止。因为无论更新哪个元素，最后一个元素包含所有值的和，所以必须更新最后一个元素。<code>i&amp;(-i)</code>是得到i的最后一位二进制1对应的数值的大小，然后加到i上，对比上面的表格。i的更新情况是：</p>
<blockquote>
<ul>
<li>0001(1)-0001+0001(2)-0010+0010(4)-0100+0100(8)=1000 停止</li>
<li>0010(2)-0010+0010(4)-0100+0100(8)=1000 停止</li>
<li>0011(3)-0011+0001(4)-0100+0100(8)=1000 停止</li>
<li>0100(4)-0100+0100(8)=1000 停止</li>
<li>0101(5)-0101+0001(6)-0110+0010(8)=1000 停止</li>
<li>0110(6)-0110+0010(8)=1000 停止</li>
<li>0111(7)-0111+0001(8)=1000 停止</li>
<li>1000(8) = 1000 停止</li>
</ul>
</blockquote>
<p>树状数组的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BIT</span>&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</div><div class="line">    <span class="keyword">int</span> n;</div><div class="line">    BIT()&#123;&#125;</div><div class="line">    <span class="comment">// 构建n个元素的空树状数组</span></div><div class="line">    BIT(<span class="keyword">int</span> num)&#123;</div><div class="line">        n = num+<span class="number">1</span>; <span class="comment">// v[0]不用，下标从1开始。</span></div><div class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line">           v.push_back(<span class="number">0</span>);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//求前i项的和</span></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</div><div class="line">            s += v[i];</div><div class="line">            i -= i &amp; (-i);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//第i 项加上x</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</div><div class="line">        <span class="keyword">while</span>(i&lt;=n)&#123;</div><div class="line">           v[i] += x;</div><div class="line">            i += i&amp;(-i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//根据传入的数组c构建它的树状数组</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">create</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;c)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;c.size();i++)&#123;</div><div class="line">            add(i+<span class="number">1</span>,c[i]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">printV</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> aa:a)&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;aa&lt;&lt;<span class="string">" "</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c = &#123;<span class="number">3</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</div><div class="line">    BIT *b = <span class="keyword">new</span> BIT(c.size());</div><div class="line">    b-&gt;create(c);</div><div class="line">    printV(b-&gt;v);</div><div class="line">    b-&gt;add(<span class="number">8</span>,<span class="number">10</span>);</div><div class="line">    printV(b-&gt;v);</div><div class="line">    b-&gt;add(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">    printV(b-&gt;v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">0 3 10 6 21 4 6 8 36</div><div class="line">0 3 10 6 21 4 6 8 46</div><div class="line">0 4 11 6 22 4 6 8 47</div></pre></td></tr></table></figure>
<p>可以看到，树状数组仅仅使用位操作就可以实现求和和更新，比线段树的开销要少很多，所以，一些能用树状数组解决的问题，不宜使用线段树。</p>
<p>参考博文：</p>
<p>http://www.cnblogs.com/wuwangchuxin0924/p/5921130.html http://www.cnblogs.com/GeniusYang/p/5756975.html</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树状数组是一个能够快速完成下术操作的数据结构：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;给定一个初始值全为0的数列，a1,a2,a3,a4,…an&lt;/li&gt;
&lt;li&gt;给定i,计算a1+a2+…+ai&lt;/li&gt;
&lt;li&gt;给定i和x,计算ai = ai + x;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
      <category term="树状数组" scheme="http://ff120.github.io/hexoblog/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>算法专题_线段树</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/23/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98_%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/23/算法专题/算法专题_线段树/</id>
    <published>2017-07-22T16:15:49.000Z</published>
    <updated>2017-10-03T13:04:43.072Z</updated>
    
    <content type="html"><![CDATA[<p>线段树是一棵二叉树，他的每个节点包含了两个额外的属性<code>start</code>和<code>end</code>用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:</p>
<p>根节点的 <code>start</code> 和 <code>end</code> 由 <code>build</code> 方法所给出。 对于节点 A 的左儿子，有 <code>start=A.left, end=(A.left + A.right) / 2</code>。 对于节点 A 的右儿子，有 <code>start=(A.left + A.right) / 2 + 1, end=A.right</code>。 如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。 实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间<code>[start, end]</code>的线段树，返回这棵线段树的根。</p>
<a id="more"></a>
<p>线段树(又称区间树), 是一种高级数据结构，他可以支持这样的一些操作:</p>
<blockquote>
<ul>
<li>查找给定的点包含在了哪些区间内</li>
<li>查找给定的区间包含了哪些点</li>
</ul>
</blockquote>
<p>样例: 比如给定start=1, end=6，对应的线段树为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">               [<span class="number">1</span>,  <span class="number">6</span>]</div><div class="line">             /        \</div><div class="line">      [<span class="number">1</span>,  <span class="number">3</span>]           [<span class="number">4</span>,  <span class="number">6</span>]</div><div class="line">      /     \           /     \</div><div class="line">   [<span class="number">1</span>, <span class="number">2</span>]  [<span class="number">3</span>,<span class="number">3</span>]     [<span class="number">4</span>, <span class="number">5</span>]   [<span class="number">6</span>,<span class="number">6</span>]</div><div class="line">   /    \           /     \</div><div class="line">[<span class="number">1</span>,<span class="number">1</span>]   [<span class="number">2</span>,<span class="number">2</span>]     [<span class="number">4</span>,<span class="number">4</span>]   [<span class="number">5</span>,<span class="number">5</span>]</div></pre></td></tr></table></figure>
<h2 id="线段树结构的定义">线段树结构的定义</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Definition of SegmentTreeNode:</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SegmentTreeNode</span> &#123;</span></div><div class="line">  <span class="keyword">public</span>:</div><div class="line">      <span class="keyword">int</span> start, end;</div><div class="line">      SegmentTreeNode *left, *right;</div><div class="line">      SegmentTreeNode(<span class="keyword">int</span> start, <span class="keyword">int</span> end) &#123;</div><div class="line">          <span class="keyword">this</span>-&gt;start = start, <span class="keyword">this</span>-&gt;end = end;</div><div class="line">          <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="线段树的构造">线段树的构造</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *@param start, end: Denote an segment / interval</div><div class="line">     *@return: The root of Segment Tree</div><div class="line">     */</div><div class="line">    <span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">         <span class="comment">// write your code here</span></div><div class="line">        <span class="keyword">if</span>(start &gt; end)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">        SegmentTreeNode *node = <span class="keyword">new</span> SegmentTreeNode(start,end);</div><div class="line">        <span class="keyword">if</span>( start &lt; end ) &#123;</div><div class="line">            node-&gt;left = build(node-&gt;start,(node-&gt;start+node-&gt;end)/<span class="number">2</span>);</div><div class="line">            node-&gt;right = build((node-&gt;start+node-&gt;end)/<span class="number">2</span>+<span class="number">1</span>,node-&gt;end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>自底向上构造线段树<a href="http://lintcode.com/zh-cn/problem/segment-tree-build-ii/" target="_blank" rel="external">online judge</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; A)</span> </span>&#123;</div><div class="line">       <span class="comment">// write your code here</span></div><div class="line">       <span class="keyword">if</span> (A.size() &lt;= <span class="number">0</span>) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> build(<span class="number">0</span>, A.size() - <span class="number">1</span>, A);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   <span class="function">SegmentTreeNode * <span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</div><div class="line">       <span class="comment">// write your code here</span></div><div class="line">       <span class="keyword">if</span> (start &gt; end) &#123;</div><div class="line">           <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">       &#125;</div><div class="line">       SegmentTreeNode *root = <span class="keyword">new</span> SegmentTreeNode(start, end, <span class="number">0</span>);</div><div class="line">       <span class="keyword">if</span> (start != end) &#123;</div><div class="line">           root-&gt;left = build(start, (start + end) / <span class="number">2</span>, nums);</div><div class="line">           root-&gt;right = build((start + end) / <span class="number">2</span> + <span class="number">1</span>, end, nums);</div><div class="line">           root-&gt;max = max(root-&gt;left-&gt;max, root-&gt;right-&gt;max);</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">else</span> &#123;</div><div class="line">           root-&gt;max = nums[start];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> root;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h2 id="线段树的查询">线段树的查询</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *@param root, start, end: The root of segment tree and</div><div class="line">     *                         an segment / interval</div><div class="line">     *@return: The maximum number in the interval [start, end]</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(SegmentTreeNode *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        <span class="comment">// 区间比根区间还大的情况</span></div><div class="line">        <span class="keyword">if</span>(start &lt;= root-&gt;start &amp;&amp; end &gt;= root-&gt;end)&#123;</div><div class="line">            <span class="keyword">return</span> root-&gt;max;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果左边界已经大于等于又边界  或者  右边界已经大于等于左边界， 则不存在的这样的区域</span></div><div class="line">        <span class="comment">//返回不影响计算最大值的数字</span></div><div class="line">        <span class="keyword">if</span>(start&gt;root-&gt;end || end &lt; root-&gt;start)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> ll = query(root-&gt;left,start,end);</div><div class="line">        <span class="keyword">int</span> rr = query(root-&gt;right,start,end);</div><div class="line">        <span class="keyword">return</span> max(ll,rr);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="线段树的更新">线段树的更新</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</div><div class="line">        &#123;</div><div class="line">            ++(root-&gt;cnt);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (mid &gt;= idx)</div><div class="line">        &#123;</div><div class="line">            modify(root-&gt;left, idx);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            modify(root-&gt;right, idx);</div><div class="line">        &#125;</div><div class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h2 id="统计前面比自己大的数有多少个">统计前面比自己大的数有多少个</h2>
<p>使用线段树存储每个区间有多少个数字。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</div><div class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</div><div class="line">            cnt(<span class="number">0</span>) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start, end;</div><div class="line">    Node *left, *right;</div><div class="line">    <span class="keyword">int</span> cnt;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (start &gt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (start == end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">    Node *root = <span class="keyword">new</span> Node(start, end);</div><div class="line">    root-&gt;left = build(start, mid);</div><div class="line">    root-&gt;right = build(mid + <span class="number">1</span>, end);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</div><div class="line">    &#123;</div><div class="line">        ++(root-&gt;cnt);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (mid &gt;= idx)</div><div class="line">    &#123;</div><div class="line">        modify(root-&gt;left, idx);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        modify(root-&gt;right, idx);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> root-&gt;cnt;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (mid &gt;= end)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> query(root-&gt;left, start, end);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (mid &lt; start)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> query(root-&gt;right, start, end);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</div><div class="line">    <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> leftRes + rightRes;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</div><div class="line">    <span class="comment">// write your code here</span></div><div class="line">    <span class="keyword">int</span> len = A.size();</div><div class="line">    Node *root = build(<span class="number">0</span>, <span class="number">2</span>*len);</div><div class="line">    <span class="keyword">int</span> maxV = INT32_MIN;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; ++j) &#123;</div><div class="line">        maxV = max(maxV,A[j]);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">int</span> cnt = query(root,A[i] + <span class="number">1</span>, maxV);</div><div class="line">        res.push_back(cnt);</div><div class="line">        modify(root, A[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> res;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">5</span>&#125;;</div><div class="line">    <span class="keyword">auto</span> re = countOfSmallerNumberII(v);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="统计前面比自己小的数字有多少个">统计前面比自己小的数字有多少个</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    Node(<span class="keyword">int</span> _start, <span class="keyword">int</span> _end) :</div><div class="line">            start(_start), end(_end), left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>),</div><div class="line">            cnt(<span class="number">0</span>) &#123;&#125;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> start, end;</div><div class="line">    Node *left, *right;</div><div class="line">    <span class="keyword">int</span> cnt;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="comment">/**</span></div><div class="line">      * @param A: An integer array</div><div class="line">      * @return: Count the number of element before this element 'ai' is</div><div class="line">      *          smaller than it and return count number array</div><div class="line">      */</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countOfSmallerNumberII(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A) &#123;</div><div class="line">        <span class="comment">// write your code here</span></div><div class="line">        Node *root = build(<span class="number">0</span>, <span class="number">20000</span>);</div><div class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> cnt = query(root, <span class="number">0</span>, A[i] - <span class="number">1</span>);</div><div class="line">            res.push_back(cnt);</div><div class="line">            modify(root, A[i]);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="function">Node *<span class="title">build</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (start &gt; end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (start == end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(start, end);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line">        Node *root = <span class="keyword">new</span> Node(start, end);</div><div class="line">        root-&gt;left = build(start, mid);</div><div class="line">        root-&gt;right = build(mid + <span class="number">1</span>, end);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> root;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(Node *root, <span class="keyword">int</span> idx)</span></span>&#123;</div><div class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (root-&gt;start == root-&gt;end &amp;&amp; root-&gt;start == idx)</div><div class="line">        &#123;</div><div class="line">            ++(root-&gt;cnt);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (mid &gt;= idx)</div><div class="line">        &#123;</div><div class="line">            modify(root-&gt;left, idx);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">            modify(root-&gt;right, idx);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        root-&gt;cnt = root-&gt;left-&gt;cnt + (root-&gt;right ? root-&gt;right-&gt;cnt : <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(Node *root, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (root-&gt;end &lt; start || root-&gt;start &gt; end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (root-&gt;start &gt;= start &amp;&amp; root-&gt;end &lt;= end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> root-&gt;cnt;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> mid = root-&gt;start + ((root-&gt;end - root-&gt;start) &gt;&gt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">if</span> (mid &gt;= end)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> query(root-&gt;left, start, end);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (mid &lt; start)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">return</span> query(root-&gt;right, start, end);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> leftRes = query(root-&gt;left, start, mid);</div><div class="line">        <span class="keyword">int</span> rightRes = query(root-&gt;right, mid + <span class="number">1</span>, end);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> leftRes + rightRes;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;线段树是一棵二叉树，他的每个节点包含了两个额外的属性&lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;用于表示该节点所代表的区间。start和end都是整数，并按照如下的方式赋值:&lt;/p&gt;
&lt;p&gt;根节点的 &lt;code&gt;start&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 由 &lt;code&gt;build&lt;/code&gt; 方法所给出。 对于节点 A 的左儿子，有 &lt;code&gt;start=A.left, end=(A.left + A.right) / 2&lt;/code&gt;。 对于节点 A 的右儿子，有 &lt;code&gt;start=(A.left + A.right) / 2 + 1, end=A.right&lt;/code&gt;。 如果 start 等于 end, 那么该节点是叶子节点，不再有左右儿子。 实现一个 build 方法，接受 start 和 end 作为参数, 然后构造一个代表区间&lt;code&gt;[start, end]&lt;/code&gt;的线段树，返回这棵线段树的根。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
      <category term="线段树" scheme="http://ff120.github.io/hexoblog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>N皇后问题</title>
    <link href="http://ff120.github.io/hexoblog/2017/07/20/%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>http://ff120.github.io/hexoblog/2017/07/20/算法专题/N皇后问题/</id>
    <published>2017-07-20T06:58:58.000Z</published>
    <updated>2017-07-31T15:02:22.534Z</updated>
    
    <content type="html"><![CDATA[<p>在一个N*N的棋盘上放置N个皇后，要求任意两个皇后不能在同一行、同一列和同一对角线上，求有多少种放置的方法。</p>
<a id="more"></a>
<p>该问题的基本思路是搜索所有的状态。先在第一行的第一个位置放置皇后，然后在第二行找一个合法的位置，接着在第三行找一个合法的位置，一旦达到最后一行，就产生了一个解，如果到某一行的时候没有解了，就回溯到上一行，移动刚才放置的皇后到下一个可行的位置，继续向下搜索。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 判断在棋盘的row,col位置是否可以放置皇后</div><div class="line"> * @param C  c[i]=j 表示第i行第j列有皇后</div><div class="line"> * @param row</div><div class="line"> * @param col</div><div class="line"> * @return</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C,<span class="keyword">int</span> &amp;row,<span class="keyword">int</span> &amp;col)</span></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</div><div class="line">        <span class="comment">// 在col列已经有皇后</span></div><div class="line">        <span class="keyword">if</span>(C[i] == col) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        <span class="comment">// 对角线上的皇后行坐标相减总是等于列坐标</span></div><div class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-row) == <span class="built_in">abs</span>(C[i]-col)) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * @param C</div><div class="line"> * @param row</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;C,<span class="keyword">int</span> row,<span class="keyword">int</span> &amp;sum)</span></span>&#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> N = C.size();</div><div class="line">    <span class="keyword">if</span>(row == N)&#123;</div><div class="line">        sum++;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//测试每一列</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j) &#123;</div><div class="line">        <span class="keyword">if</span>(isValid(C,row,j))&#123;</div><div class="line">            C[row] = j; <span class="comment">//(row,j) 放置一个皇后</span></div><div class="line">            dfs(C,row+<span class="number">1</span>,sum);</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">continue</span>; <span class="comment">// 不行就尝试下一个位置</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//N皇后问题</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; C(n,<span class="number">-1</span>);</div><div class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">    dfs(C,<span class="number">0</span>,sum);</div><div class="line">    <span class="keyword">return</span> sum;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">cout</span>&lt;&lt;totalNQueens(<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于放置和不放置皇后只需要一个标识，所以可以使用位来标记，这样可以大大节省空间，也可以使用位运算来加速算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一个N*N的棋盘上放置N个皇后，要求任意两个皇后不能在同一行、同一列和同一对角线上，求有多少种放置的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://ff120.github.io/hexoblog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ACM" scheme="http://ff120.github.io/hexoblog/tags/ACM/"/>
    
  </entry>
  
</feed>
