---
title: 动态规划
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-05 14:58:57
---
动态规划方法就是有规律的记忆化搜索方法。一般可以从穷竭搜索中总结出来。
动态规划还可以解决许多排列组合问题。
<!-- more -->
## 0-1背包问题
![QQ截图20170406094558.png](QQ截图20170406094558.png)
### 使用穷竭搜索
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
/**
 * 0--1 背包问题
 * 从第start个物体开始，总重量为weight的背包，返回最大的价值
 * @return
 */
int rec(int start,int weight,vector<int> w,vector<int> v,vector<int> &ob){
    cout<<"rec("<<start<<","<<weight<<")"<<endl;
    int result = 0;
    // 物体的最大个数是w.size()-1,如果超过这个，返回0，含义是从第n个
    //物体开始，得到的价值是0，因为不能放入进去
    if(start == w.size()) {return result;}
    //如果当前物体的重量已经大于总重量，那么一定不能放入背包，
    //一旦放入重量就超过了
    if(w[start] > weight){
        result = rec(start+1,weight,w,v,ob);
    }
    //如果当前物体的重量小于等于最大的重量，那么这个物体可以放入背包，
    //尝试放入和不放入两种情况，选择较大的那个；
//    if(w[start] <= weight){
//        result = max(rec(start+1,weight,w,v),rec(start+1,weight-w[start],w,v)+v[start]);
//    }
    // 记录物品是否放入了背包
    if(w[start] <= weight){
        int noput = rec(start+1,weight,w,v,ob);
        int putted = rec(start+1,weight-w[start],w,v,ob)+v[start];
        if(putted > noput){
            result = putted;
            cout<<"==="<<"rec("<<start<<","<<weight<<")"<<"==="<<endl;
            ob.push_back(start);
        }else{
            result = noput;
        }
    }
    return result;
}
void print(vector<int> v){
    for(auto a : v){
        cout<<a<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> w = {2,1,3,2};
    vector<int> v = {3,2,4,2};
    int weight = 5;
    vector<int> ob;
    cout<<rec(0,weight,w,v,ob)<<endl;
    print(ob);
    return 0;
}
```
### 使用动态规划
动态规划的递推公式实际上可以从上面的穷竭搜索中得到。
rec(i,j) 表示从第i个物体开始，在不超过j的重量的情况下，最大的价值是多少
设置dp[i][j] = rec(i,j); 则可以知道dp[n][j] = 0; 因为最多只有n-1个物体；
`dp[i][j] = dp[i+1][j]`         当第i个物体的重量大于j的时候；
`dp[i][i] = max( dp[i+1][j] , dp[i+1][j-w[i]]+v[i] ) `           当第i个物体能够装进去的时候，分别尝试装入和不装入，取最大值。
```C++
/**
 * 背包问题的动态规划解法
 * @param w
 * @param v
 * @param weight
 * @return
 */
int dp(vector<int> w,vector<int> v,int weight){
    int n = w.size();
    vector<vector<int>> dp(n+1,vector<int>(weight+1));
    for(int i=n;i>=0;i--){
        for(int j=0;j<weight+1;j++){
            if(w[i] > j){
                dp[i][j] = dp[i+1][j];
            }else{
                dp[i][j] = max(dp[i+1][j],dp[i+1][j-w[i]] + v[i]);
            }
        }
    }
    print2(dp);
    return dp[0][weight];
}
```

### 使用状态转移的观点
```C++
/**
 * 从状态转移的观点来看
 * dp[i][j] 表示挑选出从0到i物体，总重量不超过j的状态。dp[0][j]表示选择0个物品时的重大价值
 * dp[1][j] 表示选择物体1时候，总重量不超过j的最大的价值
 * 所以有dp[0][j] = 0;
 * dp[i][j] = dp[i-1][j] 当i-1物体不能放入背包时
 * dp[i][j] = dp[i-1][j-w[i]] + v[i] 当i-1物体可以放入背包的时候
 * dp[0][j]
 * @param w
 * @param v
 * @param weight
 * @return
 */
int dp2(vector<int> w,vector<int> v,int weight){
    int n = w.size();
    vector<vector<int>> dp(n+1,vector<int>(weight+1));
    for(int i=0;i<n;i++){
        for(int j=0;j<weight+1;j++){
            if(w[i] > j){
                dp[i+1][j] = dp[i][j];
            }else{
                dp[i+1][j] = max(dp[i][j],dp[i][j-w[i]] + v[i]);
            }
        }
    }
    print2(dp);
    return dp[n][weight];
}
```

## 完全背包问题
![QQ截图20170406095153.png](QQ截图20170406095153.png)
完全背包问题可以这样建立递推关系；
dp[i][j] 表示前i-1个物体放入背包，总重量不超过j的情况下的最大价值。i=0时表示没有物体。
w[i] 和 v[i] 表示第i个物体的重量和价值。注意这里dp中的i和w,v中的i相差1.也就是dp[i+1]对应的物体的重量和价值分别是w[i],v[i];
```C
dp[i+1][j] := dp[i][j]  第i个物体不放入背包
           := dp[i][j-1*w[i]] + v[i] 第i个物体放入1次的时候
		   := dp[i][j-2*w[i]] + 2*v[i] 第i个物体放入2次的时候
		   ...

```
上面的递推关系虽然容易理解，却存在这循环，有重复计算的地方。递推关系还可以定义如下：

>dp[i+1][j] = dp[i][j]   ; 第i个物体无法放入背包的情况
>dp[i+1][j] = d[i+1][j-w[i]]  + v[i]   ; 如果第i个物体可以放入背包，那么最大价值等于 在dp[i+1][j-w[i]]的基础上再放入一个i物品，这时的价值是dp[i+1][j-w[i]] + v[i];
>所以最后的递推关系可以写成：
>dp[0][j] = 0;
>dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]] + v[i])		   


完全背包问题


```C++
/**
 * 完全背包问题
 * @param w
 * @param v
 * @param weight
 * @return
 */
int dp3(vector<int> w,vector<int> v,int weight){
    int n = w.size();
    vector<vector<int>> dp(n+1,vector<int>(weight+1));
    for(int i=0;i<n;i++){
        for(int j=0;j<=weight;j++){
            if(j<w[i]){
                dp[i+1][j] = dp[i][j];
            }else{
                dp[i+1][j] = max(dp[i][j],dp[i+1][j-w[i]]+v[i]);
            }

        }
    }
    print2(dp);
    return dp[n][weight];
}
```

以上背包的问题的时间复杂度都可以优化到O（nW）也就是物品数量 * 背包容量，空间复杂度可以优化到O（n）.
一般情况下，这样的时间复杂度足够了。但是针对下面这道题，时间复杂度就不够用了，需要另外寻找解题的方法。
> 有n个重量和价值分别为w[i],v[i]的物品，装入容量为W的背包，求最大价值。
> 限制条件：
> n : 1--100 ; w[i] : 1--10000000 ; v[i] : 1--100;  W : 1--1000000000

原来背包问题的时间复杂度是O(nW),但是本题'故意'把W设置的很大，使得不能使用原来的方法求解。
仔细分析数据的取值范围发现，v[i]的范围比较小，我们可以转换思路，求解总重量不超过W的情况下价值的最大值，
就是求解相同价值下的总重量的最小值。
dp[i][j] 表示前i-1个物体在价值不超过j的时候的总重量的最小值。
dp[0][j] = INF; 把不存在最小值的情况设置为最大值，这样是方便用min();
dp[0][0] = 0 ; 
dp[i+1][j] = min(dp[i][j],dp[i][j-v[i]]+w[i])
```C++
/**
 * 0-1背包的变种
 * @return 
 */
int dp4(vector<int> w,vector<int> v,int weight){
    int n = w.size();
    vector<vector<int>> dp(n+1,vector<int>(weight+1));
    dp[0][0] = 0;
    for(int i=0;i<n;i++){
        for(int j=0;j<=weight;j++){
            if(j<v[i]){
                dp[i+1][j] = dp[i][j];
            }else{
                dp[i+1][j] = min(dp[i][j],dp[i+1][j-v[i]]+w[i]);
            }

        }
    }
    print2(dp);
    return dp[n][weight];
}
```