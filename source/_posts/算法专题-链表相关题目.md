---
title: 算法专题_链表相关题目
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-07-26 18:46:20
---

各个在线OJ系统涉及到的链表相关的算法题目和分析解答。

<!-- more -->

### 删除链表元素

删除链表节点为某个值的所有元素。

[删除链表中的元素](http://lintcode.com/zh-cn/problem/remove-linked-list-elements/)

```c
ListNode *removeElements(ListNode *head, int val) {
       // Write your code here
       ListNode *guard=new ListNode(0);
       guard->next = head;
       head = guard;

       ListNode *pre = guard;
       ListNode *tmp = guard->next;
       while(tmp){
           if(tmp->val == val){
               pre->next = tmp->next;
               tmp = tmp->next;
           }else{
               pre = tmp;
               tmp = tmp -> next;
           }

       }
       return head->next;
   }
```

### O(1)时间删除链表元素

思路：给出要删除的节点，是不可能在O(1)的时间内删除该节点的，因为想要删除该节点，必须找到它前面的节点，这个操作只能从头遍历(在没有指向前面的指针的情况下)，复杂度不可能是O(1). 但是可以把要删除的节点后面的节点的值赋给要删除的节点，再删除要删除的节点后面的节点，这样'看起来'好像删除了当前的节点。实际上在计算机内存中真正的变化是要删除的节点的值变成了它后面节点的值.

[在O(1)时间复杂度删除链表节点](http://lintcode.com/zh-cn/problem/delete-node-in-the-middle-of-singly-linked-list/)

```c
void deleteNode(ListNode *node) {
        // write your code here
        node->val = node->next->val;
        node->next = node->next->next;
}
```

### 删除排序链表中的重复元素

给定一个排序链表，删除所有重复的元素每个元素只留下一个。

[删除排序链表中的重复元素](http://lintcode.com/zh-cn/problem/remove-duplicates-from-sorted-list/)

```c
ListNode *deleteDuplicates(ListNode *head) {
        // write your code here
        if(head == nullptr || head->next == nullptr) return head;
        ListNode *pre = head;
        ListNode *current = head->next;
        while(current){
            if(pre->val == current->val){
                current = current->next;
            }else{
                pre->next = current;
                pre = current;
                current = current->next;
            }

        }
        // 链表结尾有重复元素的情况
        pre->next = current;
        return head;
}
```

### 删除单向链表中倒数第K个节点

例如：`head-->1-->2-->3-->4-->5-->6`  K=2
返回：`head-->1-->2-->3-->4-->6`

思路一： 先遍历一遍链表，统计链表有多少个元素。然后就可以知道倒数第K个元素就是
正数第n-k+1个元素，从head开始移动指针，移动n-k次就是要删除的节点。
删除一个节点，只需要把原来指向这个元素的指针指向它后面的元素就可以了。所以我们要做的
操作就是从head开始，移动n-k-1次，找到要删除的节点前面的节点a,然后执行a->next = a->next->next

```c
ListNode *removeNthFromEnd(ListNode *head, int n) {
    // write your code here
    int len = 0;
    ListNode *tmp = head;
    while(tmp){
        len ++;
        tmp = tmp->next;
    }
    if(len < n) return nullptr;
    if(len == n) return head->next;

    tmp = head;
    int count = len + 1 - n  ;// 正数第count个节点
    count = count - 2;
    while(count--){
        tmp = tmp->next;
    }
    tmp->next = tmp->next->next;
    return head;
}
```

思路二：使用两个间隔K个元素的指针遍历一遍链表，当前面的指针走到尾节点的时候，后面的节点指向的就是倒数第K个节点。

```c
ListNode *removeNthFromEnd(ListNode *head, int n) {
    // write your code here
    if(head == nullptr) return nullptr;
    ListNode *first = head;
    ListNode *second = head;
    int count = n + 1;
    while(first && count--){
        first = first->next;
    }
    if(first == nullptr) return head->next; // 删除第一个节点
    if(count > 0) return nullptr; // 没有导数第n个节点
    while(first){
        first = first->next;
        second = second->next;
    }
    second->next = second->next->next;
    return head;
}
```
### 删除双向链表的倒数第K个节点

双向链表删除某个节点，需要知道该节点前的节点或者该节点后面的节点
设a为要删除的节点的前一个节点，则删除后面的节点的方式是：
```c
a->next = a->next->next;
a->next->next->pre = a->next->pre;
```
设b为要删除的节点的后一个节点，则删除前面的节点的方式是：
```c
b->pre = b->pre->pre;
b->pre->pre->next = b;
```
如果双向链表是有首尾头节点的，直接从尾头结点开始计数即可。
如果没有尾头结点，处理方式可以参考单链表删除倒数第K个节点的方法。

```c

```

### 删除链表的中间节点

### 删除链表的a/b处的节点

### 打印两个有序单链表的公共部分（值相同的部分）

例如：a : `1-->2-->3-->4-->5`
      b : `10->3-->4-->20-->30`
打印 3-->4
思路： 因为是有序的链表，所以问题很简单。开始的时候l1 = head1;l2 = head2;
然后比较l1和l2指向的值的大小，谁小就向前移动谁，相等的话记录下来，最后一起打印出来。
如果是打印最长的公共部分，定义一个max变量，每次比较一下，最后打印那个最长的公共部分就行了。
```c

```

### 使用链表求两个数的和
![](2017-04-12_220956.png)
```c
ListNode *addLists(ListNode *l1, ListNode *l2) {
       // write your code here
       if(!l1) return l2;
       if(!l2) return l1;
       int j = 0; // 记录进位
       int gsum = 0; // 忽略进位的加和结果
       ListNode *head; // 结果链表
       ListNode *rr;
       int count = 0; // 用来标记得到的是否是的一个节点
       while(l1 || l2){
           int a; int b; int sum = 0;
           if(l1){a=l1->val;} else{a=0;}
           if(l2){b=l2->val;} else{b=0;}

           sum = a + b + j;
           if(sum >= 10){
               j = 1;
               gsum = sum - 10;
           }else{
               j = 0;
               gsum = sum;
           }

           ListNode *tmp = new ListNode(gsum);
           if(count == 0){
               head = tmp;
               rr = head;
               count ++;
           }else{
              rr->next = tmp;
              rr = rr->next;
              count++;
           }
           if(l1){l1 = l1->next;}
           if(l2){l2 = l2->next;}
       }
       //如果最高位还有进位
       if(j){
           rr->next = new ListNode(j);
       }
       return head;
   }
   ```
### 合并两个有序的链表

![](2017-04-12_223751.png)
```c
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    // write your code here
    // 如果其中一个链表为空，直接返回另外一个链表就是结果
    if(l1 == nullptr) return l2;
    if(l2 == nullptr) return l1;
    ListNode *result;
    ListNode *head;
    int count = 0;//用来记录是否是第一个节点，因为结果需要返回链表的头部
    while(l1 != nullptr||l2 != nullptr){
        // 当l1,l2都有值的时候，比较哪个元素小，哪个小就把它加入结果链表，同时该链表的指针向后移动
        if(l1 && l2){
            if(l1->val <= l2->val){
                if(count == 0){
                    head = l1;
                    result = head;
                    l1 = l1->next;
                    count++;
                }else{
                    result->next = l1;
                    l1 = l1->next;
                    result = result->next;
                }
            }else{
                if(count == 0){
                    head = l2;
                    result = head;
                    l2 = l2->next;
                    count++;
                }else{
                    result->next = l2;
                    l2 = l2->next;
                    result = result->next;
                }
            }
        }
        //当其中某一链表已经没有元素的时候，直接把另外的链表的元素放在结果链表的最后即可
        else if(l1){
            result->next = l1;
            break;
        }
        else if(l2){
            result->next = l2;
            break;
        }else{break;}

    }
    return head;

}
```

### 复杂链表的深度复制
[牛客网OJ](https://www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba?tpId=13&tqId=11178&tPage=2&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```c
/**
 * 复杂链表的复制(牛客网-剑指offer)
 */
struct RandomListNode {
    int label;
    struct RandomListNode *next, *random;
    RandomListNode(int x) :
            label(x), next(NULL), random(NULL) {
    }
};

RandomListNode* Clone(RandomListNode* pHead)
{
    // 克隆每一个节点链接在原来的节点后面
    if(pHead == nullptr) return nullptr;
    RandomListNode *iter = pHead;
    while(iter){
        RandomListNode *newNode = new RandomListNode(iter->label);
        newNode->next = iter->next;
        iter->next = newNode;
        iter = newNode->next;
    }

    // 链接随机指针
    iter = pHead;
    while(iter){
        if(iter->random){
            iter->next->random = iter->random->next;

        }
        iter = iter->next->next;
    }

    // 拆分出新的链表
    RandomListNode *newHead = pHead->next;
    RandomListNode *new_iter = newHead;
    iter = pHead;
    while(iter){
        iter->next = new_iter->next;
        iter = iter->next;
        if(iter){
            new_iter->next = iter->next;
            new_iter = new_iter->next;
        }
    }
    return newHead;
}
```
