---
title: 算法专题_二叉树2
toc: true
categories:
  - ACM
tags:
  - 算法
date: 2017-09-23 18:26:58
---

【前序遍历】【中序遍历】【后序遍历】【路径搜索】【公共祖先】【堆】【top K】【线段树】【树状数组】【并查集】

<!-- more -->

### [前序遍历](http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/)

```c
class TreeNode {
public:
    int val;
    TreeNode *left, *right;
    TreeNode(int val) {
        this->val = val;
        this->left = this->right = NULL;
    }
};
// 递归前序遍历
vector<int> preorderTraversal(TreeNode * root) {
    vector<int> re;
    if(!root) return re;

    re.push_back(root->val);
    if(root->left){
        auto tmp = preorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    if(root->right){
        auto tmp = preorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    return re;
}

// 非递归前序遍历
vector<int> preorder(TreeNode* root){
    vector<int> re;
    if(!root) return re;

    stack<TreeNode*> s;
    TreeNode* iter = root;
    while(iter || !s.empty()){
        while(iter){
            // 首先输出根
            re.push_back(iter->val);
            s.push(iter);
            iter = iter->left;
        }
        iter = s.top();
        s.pop();
        iter = iter->right;
    }
    return re;
}
```

### [中序遍历](http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/)

```c
// 递归中序遍历
vector<int> inorderTraversal(TreeNode *root) {
    vector<int> re;
    if(!root) return re;

    if(root->left){
        auto tmp = inorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    re.push_back(root->val);
    if(root->right){
        auto tmp = inorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    return re;
}

// 非递归中序遍历
vector<int> inorder(TreeNode* root){
    vector<int> re;
    if(!root) return re;

    stack<TreeNode*> s;
    TreeNode* iter = root;
    while(iter || !s.empty()){
        while(iter){
            s.push(iter);
            iter = iter->left;
        }
        iter = s.top();
        s.pop();
        // 输出
        re.push_back(iter->val);
        iter = iter->right;
    }
    return re;
}
```

### [后序遍历](http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/)

```c
// 递归后序遍历
vector<int> postorderTraversal(TreeNode *root) {
    vector<int> re;
    if(!root) return re;

    if(root->left){
        auto tmp = postorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    if(root->right){
        auto tmp = postorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    re.push_back(root->val);
    return re;
}
// 后序遍历的非递归实现
vector<int> postOrder(TreeNode *root)
{
    vector<int> re;
    if(!root) return re;

    TreeNode *iter = root;
    stack<TreeNode *> s;
    TreeNode *last = root;
    s.push(iter);
    while (!s.empty())
    {
        iter = s.top();
        // 1. 当前节点是叶节点(没有左右孩子)，输出
        // 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出
        // 3. 上次访问了当前节点的右孩子，输出
        if( (iter->left == nullptr && iter->right == nullptr) ||
                (iter->right == nullptr && last == iter->left) ||
                    (last == iter->right) )
        {
            re.push_back(iter->val);
            last = iter;
            s.pop();
        }
        else
        {
            // 栈是后进先出的，要先处理左孩子，所以要先放入右耗资
            if(iter->right)
                s.push(iter->right);
            if(iter->left)
                s.push(iter->left);
        }
    }
    return re;
}
```

### 二叉树的路径搜索

```c
// 搜索根节点到叶子节点的所有路径
vector<vector<int>> vv;
void binaryTreePaths(TreeNode *root,vector<int> &tmp) {
    // write your code here
    if(!root->left && !root->right){
        tmp.push_back(root->val);
        vv.push_back(tmp);
        tmp.clear();
        return;
    }else{
        tmp.push_back(root->val);
        vector<int> tmp1(tmp);
        vector<int> tmp2(tmp);
        if(root->left) binaryTreePaths(root->left,tmp1);
        if(root->right) binaryTreePaths(root->right,tmp2);
    }
}
```

### [二叉树最大深度](http://lintcode.com/zh-cn/problem/maximum-depth-of-binary-tree/)

```c
// 调用方式： maxDepth2(root,0)
int maxDepth2(TreeNode *root, const int dep){
    if(!root) return dep;
    if(!root->left && !root->right) return dep+1;
    if(root->left && !root->right) return maxDepth2(root->left,dep+1);
    if(root->right && !root->left) return maxDepth2(root->right,dep+1);     
    return max(maxDepth2(root->left,dep+1),maxDepth2(root->right,dep+1));   
}
```

### [二叉树最小深度](http://lintcode.com/zh-cn/problem/minimum-depth-of-binary-tree/#)

```c
// 最小深度 
int minDepth2(TreeNode* root,const int dep){
    if(!root) return dep;
    if(!root->left && !root->right) return dep+1;
    if(root->left && !root->right)  return minDepth2(root->left,dep+1);
    if(!root->left && root->right)  return minDepth2(root->right,dep+1);
    return min(minDepth2(root->left,dep+1),minDepth2(root->right,dep+1));
}
```

###  叶子节点到叶子节点路径的搜索

```c
map<TreeNode*,vector<TreeNode*>> nodes; // 存储树的结构
map<TreeNode*,bool> visited;
vector<vector<int>> vv;
void dfs(TreeNode* leaf,vector<int> &v){
    visited[leaf] = true;
    vector<TreeNode*> tmp = nodes[leaf];
    bool is = true;
    v.push_back(leaf->val);
    for(int i=0;i<tmp.size();i++){
        if(visited[tmp[i]] == false){
            vector<int> v1(v);
            dfs(tmp[i],v1);
            is = false;
        }
    }
    if(is){ // 叶节点
        vv.push_back(v);
    }
    return;
}
```

### top K 问题

如果是最大的K个数，那么首先使用前K个数建立一个最小堆，然后从第K+1个数开始和堆顶的元素比较，如果大于堆顶的元素，就把堆顶的元素弹出，把该元素push进堆。

```c
vector<int> topk(vector<int> &v, int k){
    priority_queue<int,vector<int>,greater<int>> heap; // 最小堆（堆顶元素最小）
    for(int i=0;i<k;i++){
        heap.push(v[i]);
    }
    for(int i=k;i<v.size();i++){
        if(v[i] > heap.top()){
            heap.pop();
            heap.push(v[i]);
        }

    }
    vector<int> re;
    while(!heap.empty()){
        re.push_back(heap.top());
        heap.pop();
    }
    return re;
}
```

### [数据流的中位数](http://lintcode.com/zh-cn/problem/data-stream-median/)

使用大顶堆(`priority_queue<int,vector<int>,less<int>>`) 保存前半部分的数据，使用小顶堆(`priority_queue<int,vector<int>,greater<int>>`) 保存后半部分的数据, 保证大顶堆的顶 小于等于 小顶堆的顶， 那么在每次需要求当前的数据的中位数的时候，只需要两个堆顶元素就可以求出来了。

```c
class MedianFinder {
private:
    priority_queue<int,vector<int>,less<int>> maxHeap;
    priority_queue<int,vector<int>,greater<int>> minHeap;
    long long n;
    bool is_left;
public:
    MedianFinder() {
        this->n = 0;
        this->is_left = true;
    }

    void addNum(int num) {
        // 轮流加入左右两个堆
        if(is_left){
            // 如果right的堆为空，可以确保左边最大的小于等于右边最小的，直接加入
            // 如果要加入的元素小于等于right的堆顶，也可以保证上述条件
            if(minHeap.empty() || num <= minHeap.top()){
                maxHeap.push(num);
            }
            // 如果num > minHeap.top(); 不能直接加入maxHeap,因为如果这样做，就不能保证maxHeap中的所有的数字都小于等于minHeap中的数字。
            // 这个时候的做法是， 先把num加入minHeap, 在把minHeap.top()弹出，加入maxHeap;
            else{
                minHeap.push(num);
                maxHeap.push(minHeap.top());
                minHeap.pop();
            }
            is_left = !is_left;
        }
        if(!is_left){
            if(maxHeap.empty() || num >= maxHeap.top()){
                minHeap.push(num);
            }else{
                maxHeap.push(num);
                minHeap.push(maxHeap.top());
                maxHeap.pop();
            }
            is_left = !is_left;
        }
        this->n++;
    }

    double findMedian() {
        if(n >> 1){
            return (maxHeap.top() + minHeap.top()) / 2.0;
        }else{
            return maxHeap.top();
        }
    }
};
```

### [合并K个排序链表](http://lintcode.com/zh-cn/problem/merge-k-sorted-lists)

这里使用小顶堆这种结构保存K个链表，每次取得堆顶的元素就可以得到K个链表中最小的。

```c
ListNode *mergeKLists(vector<ListNode *> &lists) {
    priority_queue<ListNode*,vector<ListNode*>,bigger> minHeap;
    if(lists.empty()) return nullptr;
    for(int i=0;i<lists.size();i++){
        if(lists[i]) minHeap.push(lists[i]);
    }
    ListNode *head = nullptr;
    ListNode *iter = nullptr;
    while(!minHeap.empty()){
        if(head == nullptr){
            head = minHeap.top();
            iter = head;
            if(minHeap.top()->next){
                minHeap.push(minHeap.top()->next);
            }
            minHeap.pop();
        }else{
            iter->next = minHeap.top();
            iter = iter->next;
            if(minHeap.top()->next){
                minHeap.push(minHeap.top()->next);
            }
            minHeap.pop();
        }
    }
    return head;
}
```

### 堆排序

使用堆这种结构维护数据的有序性，从而进行排序的算法是堆排序。堆排序的具体步骤是： 使用要排序的整个数组建立堆。然后把最后一个元素和堆顶元素交换，堆的大小减1，调整堆，然后再把新的堆的最后一个元素和堆顶元素交换，调整堆，直到全部数据有序为止。

```c
void heapSort(vector<int> &v){
    // 建立最大堆
    make_heap(v.begin(),v.end(),less<int>());
    int index = v.size();
    while(index > 0){
        // 交换堆顶和堆尾的元素，重新调整堆
        pop_heap(v.begin(),v.begin()+index,less<int>());
        index--;
    }
}
```