---
title: 手写代码-其他
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-09-27 23:12:30
---

【快速排序】【第K大的数】【归并排序】【逆序对】【二分查找】【冒泡排序】【单例模式】

<!-- more -->

### 快速排序

包括两个部分， 一趟排序函数 `int partition(v[],i,j)`,实现快速排序的一趟排序，效果是将基准元素移动到正确的位置上,假设返回值是`pos`,在`pos`前面的数字都比`pos`小，后面的都比`pos`大。

另外一个部分是主函数`quickSort(vector<int> &v,int start, int end)`,用递归的方法调用上面的函数实现排序。

```c
int partition(vector<int> &v,int i,int j){
    // 以i指向的元素为基准元素
    bool base = true; // base = true 表示此时 i 指向base 元素， base = false 表示此时j 指向base元素
    while(i < j){
        if(v[i] > v[j] && base){
            swap(v[i],v[j]);
            base = false;
            i++;
        }
        if(v[i] > v[j] && !base){
            swap(v[i],v[j]);
            base = true;
            j--;
        }
        if(base){
            j--;
        }
        if(!base){
            i++;
        }
    }
    return i;
}
/**
 * 快速排序
 * @param v  待排序数组
 * @param start  起始位置下标
 * @param end  结束位置下标
 */
void quickSort(vector<int> &v,int start, int end){
     if(start >= end) return;
     int mid = partition(v,start,end);
     quickSort(v,start,mid-1);
     quickSort(v,mid+1,end);
}

```

### 第K小的数

`int partition(vector<int> &v,int i,int j)` 返回一趟快排之后基准元素的位置，其前面的都小于它，后面的都大于它，换言之，假设函数的返回值是`pos`,那么`v[pos]`就是第`pos+1`小的数。 根据K 和 pos的关系，可以确定下次应该递归哪一边，这样就不用像快速排序那样两边都递归了，所以它的时间复杂度是接近O(n)的。

```c
int Kth(vector<int> &v, int k){
    if(v.empty() || k <= 0) return -1;
    int begin = 0;
    int end = v.size() - 1;
    while(true){
         int i = partition(v,begin,end);
         if(i+1 == k) return v[i];
         if(i+1 < k){
            begin = i + 1;
         }else{
            end = i - 1;
         }
    }
}
```

### 归并排序

也是分为两个部分，一个是`merge(v1[],v2[])`, 负责把两个排序好的数组合并成一个排序好的数组。

另外一个是主函数，首先把待排序的数组分成相等的两个部分，然后两个部分分别调用自身函数，再调用`merge`函数合并两个结果，最终得到排序好的数组。

```c
void merge(vector<int> &v,int s1,int e1, int s2, int e2){
    vector<int> tmp;
    int ss1 = s1, ss2 = s2;
    while(s1<=e1 && s2 <= e2){
        if(v[s1] < v[s2]){
            tmp.push_back(v[s1]);
            s1++;
        }
        if(v[s1] >= v[s2]){
            tmp.push_back(v[s2]);
            s2++;
        }
    }
    if(s1 <= e1){
        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1);
    }
    if(s2 <= e2){
        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1);
    }
    int t = 0;
    for(int i=ss1;i<=e1;i++){
        v[i] = tmp[t];
        t++;
    }
    for(int i = ss2;i<=e2;i++){
        v[i] = tmp[t];
        t++;
    }
    tmp.clear();
    return ;
}
void mergeSort(vector<int> &v,int start,int end){
    if(start >= end) return;
    int mid = (start+end) / 2;
    mergeSort(v,start,mid);
    mergeSort(v,mid+1,end);
    merge(v,start,mid,mid+1,end);
}
```

### 统计逆序对

在归并排序归并两个已经排好序的数组的时候，是统计逆序对的最好时机。假设两个待合并的序列为`v1`,`v2`, 有两个指针`s1`,`s2`分别指向`v1`,`v2`,当`v1[s1] > v2[s2]`的时候，`(v1.size() - s1)`, 也就是从`s1`到`v1`的结尾的所有元素都会和`v[s2]`组成逆序对。

```c
void merge(vector<int> &v,int s1,int e1, int s2, int e2, int &cc){
    vector<int> tmp;
    int ss1 = s1, ss2 = s2;
    while(s1<=e1 && s2 <= e2){
        if(v[s1] <= v[s2]){
            tmp.push_back(v[s1]);
            s1++;
        }
        if(v[s1] > v[s2]){
            tmp.push_back(v[s2]);
            s2++;
            cc += e1-s1+1; // 记录逆序对的数量
        }
    }
    if(s1 <= e1){
        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1);
    }
    if(s2 <= e2){
        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1);
    }
    int t = 0;
    for(int i=ss1;i<=e1;i++){
        v[i] = tmp[t];
        t++;
    }
    for(int i = ss2;i<=e2;i++){
        v[i] = tmp[t];
        t++;
    }
    tmp.clear();
    return ;
}
void mergeSort(vector<int> &v,int start,int end,int &cc){
    if(start >= end) return ;
    int mid = (start+end) / 2;
    mergeSort(v,start,mid,cc);
    mergeSort(v,mid+1,end,cc);
    merge(v,start,mid,mid+1,end,cc);
}
```

### 二分查找

```c
// 不考虑重复元素
int binarySearch(vector<int> &v, int val){
    if(v.empty()) return -1;
    int i = 0;
    int j = v.size() - 1;
    int mid;
    while(i <= j){
       if(v[mid] == val) return mid;
       if(v[mid] > val){
           j = mid - 1;
       }
       if(v[mid] < val){
         i = mid + 1;
       }
    }
    return -1;
}

// 如果有重复的val,返回val的起始位置
int binaryResearch(){
    if(v.empty()) return -1;
    int i=0;
    int j = v.size() -1;
    int mind;
    while(i < j)){
      if(v[mid] == val){
        while(v[mid] == val && mid >= 0){
          mid--;
        }
        return p+1;
      }
      if(v[mid] > val){
        j = mid - 1;
      }
      if(v[mid] < val){
        i = mid + 1;
      }
    }
}
```

### 冒泡排序

```c
void sort(vector<int> &v){
    for(int j = v.size()-1;j>=1;j--){
        for(int i=0;i<j;i++){
            if(v[i] > v[i+1]) swap(v[i],v[i+1]);
        }
    }
}
```

### 单例模式

```c
class Singleton{
    
  private:
      static Single* instance = null; // 静态私有变量，属于类
      Singleton(){}
      Singleton(const Singleton&){}
      Singleton& operator=(const Singleton&){} // 防止赋值的时候拷贝
  public:
      static Singleton* getInstance() // 静态方法，确保使用类可以调用
      {
          if (instance == NULL){
             lock(); // 线程安全的写法，如果不用确保线程安全，不需要
             if(instance == NULL){
                 instance = new Singleton();
             }
             unlock();
          }
          return instance;
      }
};
```



// 使用方法
auto instance = Singleton::getInstance();
```