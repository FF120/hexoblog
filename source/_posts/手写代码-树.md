---
title: 手写代码-树
toc: true
categories:
  - ACM
tags:
  - 算法
date: 2017-09-23 18:26:58
---

AAAAAAAAAAAAAAAAA

<!-- more -->

### 二叉树的遍历

```c
class TreeNode {
public:
    int val;
    TreeNode *left, *right;
    TreeNode(int val) {
        this->val = val;
        this->left = this->right = NULL;
    }
};
// 递归前序遍历 [http://lintcode.com/zh-cn/problem/binary-tree-preorder-traversal/]
vector<int> preorderTraversal(TreeNode * root) {
    vector<int> re;
    if(!root) return re;

    re.push_back(root->val);
    if(root->left){
        auto tmp = preorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    if(root->right){
        auto tmp = preorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    return re;
}
// 递归中序遍历[http://lintcode.com/zh-cn/problem/binary-tree-inorder-traversal/]
vector<int> inorderTraversal(TreeNode *root) {
    vector<int> re;
    if(!root) return re;

    if(root->left){
        auto tmp = inorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    re.push_back(root->val);
    if(root->right){
        auto tmp = inorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    return re;
}
// 递归后序遍历[http://lintcode.com/zh-cn/problem/binary-tree-postorder-traversal/]
vector<int> postorderTraversal(TreeNode *root) {
    vector<int> re;
    if(!root) return re;

    if(root->left){
        auto tmp = postorderTraversal(root->left);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    if(root->right){
        auto tmp = postorderTraversal(root->right);
        re.insert(re.end(),tmp.begin(),tmp.end());
    }
    re.push_back(root->val);
    return re;
}
// 非递归前序遍历
vector<int> preorder(TreeNode* root){
    vector<int> re;
    if(!root) return re;

    stack<TreeNode*> s;
    TreeNode* iter = root;
    while(iter || !s.empty()){
        while(iter){
            // 首先输出根
            re.push_back(iter->val);
            s.push(iter);
            iter = iter->left;
        }
        iter = s.top();
        s.pop();
        iter = iter->right;
    }
    return re;
}
// 非递归中序遍历
vector<int> inorder(TreeNode* root){
    vector<int> re;
    if(!root) return re;

    stack<TreeNode*> s;
    TreeNode* iter = root;
    while(iter || !s.empty()){
        while(iter){
            s.push(iter);
            iter = iter->left;
        }
        iter = s.top();
        s.pop();
        // 输出
        re.push_back(iter->val);
        iter = iter->right;
    }
    return re;
}

// 后序遍历的非递归实现
vector<int> postOrder(TreeNode *root)
{
    vector<int> re;
    if(!root) return re;

    TreeNode *iter = root;
    stack<TreeNode *> s;
    TreeNode *last = root;
    s.push(iter);
    while (!s.empty())
    {
        iter = s.top();
        // 1. 当前节点是叶节点(没有左右孩子)，输出
        // 2. 上次访问了当前节点的左孩子，而且当前节点没有右孩子，输出
        // 3. 上次访问了当前节点的右孩子，输出
        if( (iter->left == nullptr && iter->right == nullptr) ||
                (iter->right == nullptr && last == iter->left) ||
                    (last == iter->right) )
        {
            re.push_back(iter->val);
            last = iter;
            s.pop();
        }
        else
        {
            // 栈是后进先出的，要先处理左孩子，所以要先放入右耗资
            if(iter->right)
                s.push(iter->right);
            if(iter->left)
                s.push(iter->left);
        }
    }
    return re;
}
```

### 二叉树的路径搜索

```c
// 搜索根节点到叶子节点的所有路径
vector<vector<int>> vv;
void binaryTreePaths(TreeNode *root,vector<int> &tmp) {
    // write your code here
    if(!root->left && !root->right){
        tmp.push_back(root->val);
        vv.push_back(tmp);
        tmp.clear();
        return;
    }else{
        tmp.push_back(root->val);
        vector<int> tmp1(tmp);
        vector<int> tmp2(tmp);
        if(root->left) binaryTreePaths(root->left,tmp1);
        if(root->right) binaryTreePaths(root->right,tmp2);
    }
}

// 最大深度

// 最小深度

// 两个叶子之间最长的节点数目

// 最大苹果数

```