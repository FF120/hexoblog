---
title: 算法专题_栈和队列
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-12 10:07:18
---
栈是一种实现了后进先出的规则的数据结构。C++里面有实现stack.
使用的时候`include <stack>`,支持的操作有push,pop,top;需要注意的是，pop的作用是弹出栈顶元素，而不会返回栈顶元素，
实现返回栈顶元素并弹出的操作应该是`int a = s.top(); s.pop();`.
<!-- more -->
## 带有getMin()的栈
实现一个可以在O(1)时间内得到最小值的栈结构。支持`pop(),push(),tip(),getMin()`四种操作。
思路：使用两个栈来模拟这个栈，一个栈用来保存实际的数据，一个栈用来保存对应数据的最小值。
每次入栈和出栈操作的时候，判断最小值有没有发生变化，如果没有发生变化，直接弹出数据，如果发生了变化，更新存储最大值最小值的栈。
```c
class StackWithGetMin2{
public:
    stack<int> data;
    stack<int> min_data;
    void push(int val){
        data.push(val);
        if(!min_data.empty()){
            if(min_data.top()>=val){
                min_data.push(val);
            }
        }
        else{
           min_data.push(val);
       }
    }
    int pop(){
        auto v = data.top();
        if(v > min_data.top()){
            data.pop();
            return v;
        }else{
            data.pop();
            min_data.pop();
            return v;
        }
    }
    int getMin(){
      if(min_data.empty){throw new exception;}
      else{
         return min_data.top();
      }
    }
    int top(){
        return data.top();
    }
};

```
## 用一个栈排序另外一个栈,排好后的数据在原栈里面
```c
void sortStack(stack<int> s){
    stack<int> help;
    help.push( s.top() );
    s.pop();
    auto v = s.top();
    if(help.top()>v){
        help.push(v);
        s.pop();
    }
    else{
        while(help.top()<=v){
            auto temp = help.top();
            help.pop();
            s.push(temp);
        }
        help.push(v);
    }

}
```
## 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
```c
bool IsPopOrder(vector<int> pushV,vector<int> popV) {
       if(pushV.size() != popV.size()) return false;
       stack<int> s1;
       //找到第一个相同的元素
       size_t i = 0;
       while(pushV[i] != popV[0] && i<pushV.size()){
           s1.push(pushV[i]);
           i++;
       }
       s1.push(pushV[i]); //此时是s1栈顶和popV的第一个元素相同；
       i++;//i指向下一元素；
       for(size_t j=0;j<=popV.size();j++){
           if( j<popV.size() && popV[j] == s1.top() ){
              s1.pop();
           }else if(i<pushV.size()){
               s1.push(pushV[i]);
               j--;
               i++;
           }else if( j== popV.size() && s1.empty()){
               return true;
           }else{
               return false;
           }
       }
       return false;
   }
```
