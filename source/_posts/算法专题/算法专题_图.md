---
title: 算法专题：图问题
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-06 15:02:35
---
图由顶点(vertex), 边(edge)组成，所以常用(V,E)来表示图。
图分为两种：有向图和无向图。
<!-- more-->

## 图的表示方法
![QQ截图20170406150818.png](QQ截图20170406150818.png)
### 邻接矩阵表示法
邻接矩阵表示就是一个二维的矩阵V[i][j]
V[i][j] = 1 表示有一条边从节点i连接节点j
![QQ截图20170406151130.png](QQ截图20170406151130.png)

### 邻接表表示法
邻接表就是把每个节点直接连接的节点都列举出来。
![QQ截图20170406151320.png](QQ截图20170406151320.png)
![QQ截图20170406151352.png](QQ截图20170406151352.png)

## 图的遍历方法

### 深度优先遍历
深度优先遍历用递归实现，借助栈的结构。
![QQ截图20170406151926.png](QQ截图20170406151926.png)
深度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。
```C++

```
### 广度优先遍历
广度优先遍历一般使用队列结构，适用于解决最短路径问题。一般遍历解的状态都是使用
深度优先遍历，因为深度优先遍历可以使用递归函数实现，比较方便。
![QQ截图20170406152025.png](QQ截图20170406152025.png)
![QQ截图20170406152051.png](QQ截图20170406152051.png)
广度优先搜索的C++语言的实现，图的存储使用邻接矩阵的方式。
```C++

```

## 图相关的经典问题

### 二分图的判定
给一个图的顶点着色，相邻的顶点着不同颜色，需要的最少的颜色数，叫做最小着色数。
最小着色数是2的图叫做二分图。
判断一个图是否是二分图，只需要从任意一个节点开始，遍历这个图，给当前节点和相邻节点然不同的色，然后判断有没有相邻的节点同色即可。
```C++

```
