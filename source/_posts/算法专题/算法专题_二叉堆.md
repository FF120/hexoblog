---
title: 算法专题_二叉堆(堆排序)
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-08-06 08:53:25
---
堆，或者更准确的叫作二叉堆，是一种特殊的完全二叉树，通常分为最大堆和最小堆。最大堆是指堆顶的元素最大，堆顶的左右孩子的值小于等于它，然后左右子树也满足这个条件。最小堆是指堆顶的元素最小，左右孩子大于等于堆顶元素，左右子树也满足这个条件。 可以看到，堆是递归定义了，而且是一种完全二叉树。节点之间是有大小次序关系的。但是左右子树是没有顺序的。而二叉搜索树左右孩子是有次序的，不能颠倒。

既然堆是完全二叉树，就可以使用数组来简便的表示一棵树。假设一个节点的下标是`i`,那么它的左孩子为`2*i`,右孩子为`2*i+1`,父节点为`i/2`. 本文主要介绍二叉堆的构建，调整和有关应用(堆排序和优先队列)。注意这里假设根节点的标号是1.

如果根节点是从0开始标号的，那么对于节点`i`, 左孩子为`2*i+1`,右孩子为`2*i+2`,父节点为`(i-1)/2`.



<!-- more -->

```c 
// 根节点从0开始标号，对于节点i，求其左孩子，右孩子和父节点
inline int left(int i){
    return (i<<1) + 1;
}
inline int right(int i){
    return (i<<1) + 2;
}
inline int parent(int i){
    if(i == 0) return -1;
    return (i-1) >> 1;
}
```

## 最大堆

最大堆就是满足父节点大于等于子节点的堆。最大堆的根节点是所有元素中最大的(但可能不是唯一的最大的，注意这里是大于等于)。

### 维护最大堆(调整最大堆)

假设`A`是存储堆的数组,`A.length()`表示数组的大小，`heap_size`表示堆中元素的个数, 满足`heap_size <= A.length()`.假设我们需要调整节点`i`以使得堆重新满足最大堆的性质(注意这个时候只有节点i是不满足最大堆的性质的)，步骤如下：

1. 找出节点`i`的左右孩子`l`,`r`;
2. 如果`l`,`r`超过了堆的大小，直接返回，如果A[i]大于等于`l`,`r`,直接返回
3. 找到`l`,`r`中的较大者,记为`maxIndex`，和`A[i]`交换
4. 令i = maxIndex, 转到1。

```c
/**
 * 调整节点i,使得整个堆保持最大堆的性质
 * @param A
 * @param i
 */
void max_heap(vector<int> &A,int i){
    int heap_size = A.size();
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int maxIndex = -1;
    if(r >= heap_size ){
        if(A[i] >= A[l]) return;
        maxIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整
        if(A[i] >= A[l] && A[i] >= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] >= A[r] ? maxIndex = l : maxIndex = r;
    }
    swap(A[i],A[maxIndex]);
    max_heap(A,maxIndex);
}
```

```c
/**
 * 调整节点i,使得整个堆保持最小堆的性质
 * @param A 
 * @param i 
 */
void min_heap(vector<int> &A,int i){
    int heap_size = A.size();
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int minIndex = -1;
    if(r >= heap_size ) {
        if(A[i] <= A[l]) return;
        minIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都小，则满足最小堆的性质，不用调整
        if(A[i] <= A[l] && A[i] <= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] <= A[r] ? minIndex = l : minIndex = r;
    }
    swap(A[i],A[minIndex]);
    min_heap(A,minIndex);
}
```

### 建堆

如何从一个无序的数组建立一个堆是堆操作中一个基本的，但很重要的问题，它通常是很多问题的第一步。

根据完全二叉树的性质，一个包含n个元素的数组形成的完全二叉树中，n - ([n/2] + 1) + 1个元素是叶子节点。我们只需要针对所有的叶子节点之外的节点调用上面的重建堆的函数，就可以构建一个最大堆。 时间复杂度是O(n).

```c
/**
 * 从无序数组建立最大堆
 * @param A
 */
void build_max_heap(vector<int> &A){
    int leaf = A.size() / 2 ;
    for (int i = leaf - 1; i >= 0 ; --i) {
        max_heap(A,i);
    }
}
```

```c
/**
 * 从无序数组建立最小堆
 * @param A
 */
void build_min_heap(vector<int> &A){
    int leaf = A.size() / 2;
    for (int i = leaf - 1; i >= 0 ; --i) {
        min_heap(A,i);
    }
}
```

## 堆排序

堆排序就是利用堆的结构来维护最大值或者最小值实现排序的一种算法，这里以最大堆为例来说明。 首先把无序数组重建一个最大堆，使用上面提到的函数，这一步可以轻松的在O(n)的时间复杂度内完成。 此时A[0]存储的是这个数组的最大值，将它与数组的最后一个元素交换位置，然后堆的长度减少1，也就是数组的最后一个元素不再当作堆的元素，因为它已经在正确的位置上了，然后调整堆使之符合最大堆的性质。 重复这个步骤直到所有的元素放到了正确的位置之上。

```c
void max_heap(vector<int> &A,int heap_size,int i){
    // 不存在这个样的节点（节点从0开始编号）
    if(i >= heap_size || i < 0) return;
    auto l = left(i);
    auto r = right(i);
    // 如果没有孩子节点了，不需要调整了
    if(l >= heap_size ) return;
    int maxIndex = -1;
    if(r >= heap_size ){
        if(A[i] >= A[l]) return;
        maxIndex = l;
    }else{
        // 如果节点i比它两个孩子节点都大，则满足最大堆的性质，不用调整
        if(A[i] >= A[l] && A[i] >= A[r]) return;
        // 找到两个孩子节点中较大的那一个
        A[l] >= A[r] ? maxIndex = l : maxIndex = r;
    }
    swap(A[i],A[maxIndex]);
    max_heap(A,heap_size,maxIndex);
}

void build_max_heap(vector<int> &A){
    int leaf = A.size() / 2 ;
    for (int i = leaf - 1; i >= 0 ; --i) {
        max_heap(A,A.size(),i);
    }
}

void sort_with_max_heap(vector<int> &v){
    build_max_heap(v);
    int heap_size = v.size();
    while(heap_size){
        swap(v[0],v[heap_size-1]);
        heap_size--;
        max_heap(v,heap_size,0);
    }
}
```

堆排序的时间性能是nlogn,但是实际使用的时候，快速排序的性能更好一些，一般情况下都是使用快速排序。

## 优先队列

优先队列是能够`快速`的完成以下操作的数据结构：

1. 返回最大值
2. 返回最大值并删除该元素
3. 将任意一个已在优先队列中的元素增加k.
4. 插入一个任意值


能够维护一个数据结构，快速的实现以上所有操作的叫做优先队列。使用堆来实现优先队列，可以保证所有的操作都可以在`o(lgn)`完成。

1. 返回最大值

使用最大堆实现优先队列这种结构，直接返回`A[0]`就是最大值。

2. 返回最大值并删除该元素

首先输出`A[0]`, 然后把最后一个元素赋值给`A[0]`,调整堆使之符合最大堆性质。

```c
int maxP(vector<int> &A){
    int maxV = A[0];
    A[0] = A[A.size()-1];
    int heap_size = A.size()-1;
    max_heap(A,heap_size,0);
    return maxV;
}

```

3. 将任意一个已在优先队列中的元素增加k.

这里涉及到另外一个通用的技术，就是修改了堆的某个节点之后，如何调整堆使之重新符合堆的性质。对于最大堆来说， 如果某个节点的值增大了，那么就晚上追溯，看父节点的值，如果父节点小于它，交换位置继续，直到顶。 如果某个节点的值减小了，向下追溯，直到叶子节点。 如果想要插入一个新的值，等价于现在堆的末尾加上一个最小值，然后把这个最小值增大到与插入的值相等的情况。 所以， 插入和修改只要实现修改就可以了。

```c

```

4. 插入一个任意值

```c

```

## 直接使用STL进行堆操作

C++11 中的STL已经有了堆的各种操作的高效实现，我们可以直接使用。既能减少自己编写出错的概率，也能使得代码更加简洁，效率更高。

### 建堆

**建立最大堆**

```c
#include <iostream>
#include <vector>
#include <queue>
using namespace std;
// v 是一个无序的数组
make_heap(v.begin(),v.end());
// 或者使用
make_heap(v.begin(),v.end(),less<int>());
```

**建立最小堆**

```c
make_heap(v.begin(),v.end(),greater<int>());
```

make_heap()方法的第三个参数其实可以传入一个函数的实例，表示你怎样比较两个元素。例如我们可以自己实现`less`方法。

```c
// 大根堆
bool mless(const int &a,const int &b){
    return a <= b;
}
make_heap(v.begin(),v.end(),mless);

//小根堆
bool mgreater(const int &a,const int &b){
    return a >= b;
}
make_heap(v.begin(),v.end(),mgreater);
```

当堆中存放的数据不是简单的数字，而是复杂的结构体或者类数据的时候，自定义比较函数就十分有用了，可以自定义依据类中哪个字段生成堆。

### 其他与堆有关的操作

```c
// 弹出大根堆的顶部元素，重排堆，注意这个时候顶部元素没有删除，放在了数组的最后
pop_heap(v.begin(),v.end(),less<int>())

// 弹出小根堆的顶部元素
pop_heap(v.begin(),v.end(),greater<int>())

// 把[v.begin(), v.end()-2] 作为大根堆，v.end()-1, 也就是最后一个元素作为插入元素插入到大根堆中，重新调整好顺序
push_heap(v.begin(),v.end(),less<int>())

// 插入小根堆
push_heap(v.begin(),v.end(),less<int>())
```

### 优先队列

`priority_queue<Type, Container, Functional>` 实现了优先队列的结构和相应的操作方法，可以用他来实现大根堆，小根堆，优先队列等数据结构。

**大根堆**

```c
priority_queue<int> q;
// 或者使用完整的声明形式
priority_queue<int,vector<int> less<int>()> q;

// 从无序数组建立大顶堆
vector<int> v = {5,4,10,14,7,9,3,2,8,30};
for (int i = 0; i < v.size(); ++i) {
    q.push(v[i]);
}

// 弹出最大元素
q.pop()
```

**小根堆**

```c
priority_queue<int, vector<int>, greater<int> > q;

// 从无序数组建立小顶堆
vector<int> v = {5,4,10,14,7,9,3,2,8,30};
for (int i = 0; i < v.size(); ++i) {
    q.push(v[i]);
}

// 弹出最大元素
q.pop()
```


## 堆的应用

### top K 元素

[最小的K个数](https://www.nowcoder.com/questionTerminal/6a296eb82cf844ca8539b57c23e6e9bf)

类似求最小的K个数，最大的K个数，第K大的数这类问题，都可以用堆来解决。（第K大的数字可以使用快速排序的思想，时间复杂度可以达到o(n)）

```c
/**
 * 最小的K个数
 * 维护一个大顶堆，顶是最小的K个数字中最大的那个，如果新的数字比堆顶的元素大，跳过
 * 如果新的数字比顶小，丢弃顶部元素，把新元素加入堆中。
 * @param input
 * @param k
 * @return
 */
vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
    if(k > input.size() || k <= 0 || input.empty()) return {};
    if(k == input.size()) return input;

    priority_queue<int> p;
    for (int i = 0; i < k; ++i) {
        p.push(input[i]);
    }
    for (int j = k; j < input.size(); ++j) {
        if(input[j] < p.top()){
            p.pop();
            p.push(input[j]);
        }
    }
    vector<int> result;
    while(!p.empty()){
        result.insert(result.begin(),p.top());
        p.pop();
    }
    return result;
}
```

### 中位数

中位数就是排好序之后位于最中间位置的那个数，或者两个数的平均值，当然也有的题目会把偶数的时候的中位数定义为`(n-1)/2`. 求数据流的中位数是堆的典型应用。因为我们只需要找到位于中间位置的元素(排好序后)，而不要求前半部分和后半部分是有序的，所以整体排好序之后求中位数的方法看起来做了某些我们不需要的工作。 凡是这种排好序之后出结果，而又不要求每一个元素的大小顺序的题目，都可以用堆来降低时间复杂度。例如求前K个最大的数字。我们不需要直到前K个最大的数字是有序的，所以也可以用堆来实现，降低时间复杂度。

具体到求解中位数，我们可以用大根堆存储前半部分数据，小根堆存储后半部分数据，这样我们很容易取出位于中间位置的数。剩下的最重要的是如何保证大根堆的所有元素都小于小根堆的元素。具体步骤如下：

1. 初始化大根堆max,小根堆min为空。
2. 读取数据A[i],(i从0开始)，if(i%2==0),如果min为空或者min的堆顶元素大于等于A[i]，A[i]直接加入大根堆，否则，A[i]先加入小根堆，然后把小根堆的堆顶元素弹出，加入大根堆。
3. if(i%2==1),A[i]加入小根堆。如果max为空或者max的堆顶元素小于等于A[i],A[i]直接加入小根堆，否则，A[i]先加入大根堆，然后把大根堆的堆顶元素弹出，加入小根堆。
4. 当数据是奇数的时候，返回max的堆顶元素
5. 当数据是偶数的时候，返回max和min堆顶元素的算数平均值

[lintcode](http://lintcode.com/zh-cn/problem/data-stream-median/)

```c
struct mless{
    bool operator() (const int &a, const int &b){
        return a <= b;
    }
};
struct mgreater{
    bool operator() (const int &a, const int &b){
        return a >= b;
    }
};

/**
 * 数据流中的中位数
 * @param nums
 * @return
 */
vector<int> medianII(vector<int> &nums) {
    if(nums.empty()) return {};
    int m = nums[0];
    int n_left = 0, n_right = 0;
    priority_queue<int,vector<int>,mless> left;
    priority_queue<int,vector<int>,mgreater > right;
    vector<int> result;
    for (int i = 0; i < nums.size(); ++i) {
        if(i % 2 == 0){
            if(right.empty() || right.top() >= nums[i]){
                left.push(nums[i]);
            }else{
                right.push(nums[i]);
                left.push(right.top());
                right.pop();
            }

            result.push_back(left.top());
            continue;
        }
        if(left.empty() || left.top() <= nums[i]){
            right.push(nums[i]);
        }else{
            left.push(nums[i]);
            right.push(left.top());
            left.pop();
        }

        result.push_back(left.top());
    }
    return result;
}
```

[leetcode](https://leetcode.com/problems/find-median-from-data-stream/description/)

```c

struct mless{
    bool operator() (const int &a, const int &b){
        return a <= b;
    }
};
struct mgreater{
    bool operator() (const int &a, const int &b){
        return a >= b;
    }
};

class MedianFinder {
public:
    /** initialize your data structure here. */
    bool is_left;
    priority_queue<int,vector<int>,mless> left;
    priority_queue<int,vector<int>,mgreater > right;
    
    
    MedianFinder() {
         is_left = true;
    }
    
    void addNum(int num) {
        if(is_left){
            if(right.empty() || right.top() >= num){
                left.push(num);
            }else{
                right.push(num);
                left.push(right.top());
                right.pop();
            }
            is_left = !is_left;
            return;
        }
        if(!is_left){
            if(left.empty() || left.top() <= num){
                right.push(num);
            }else{
                left.push(num);
                right.push(left.top());
                left.pop();
            }
            is_left = !is_left;
            return;
        }
    }
    
    double findMedian() {
        if(!is_left) return left.top();
        if(is_left){
            double re = (left.top() + right.top() ) / 2.0;
            return re;
        }
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder obj = new MedianFinder();
 * obj.addNum(num);
 * double param_2 = obj.findMedian();
 */
```

[剑指offer](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=13&tqId=11216&tPage=4&rp=1&ru=%2Fta%2Fcoding-interviews&qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking)

```c
struct mless{
    bool operator() (const int &a, const int &b){
        return a <= b;
    }
};
struct mgreater{
    bool operator() (const int &a, const int &b){
        return a >= b;
    }
};

class Solution {
public:
    bool is_left = true;
    priority_queue<int,vector<int>,mless> left;
    priority_queue<int,vector<int>,mgreater > right;
    void Insert(int num)
    {
         if(is_left){
            if(right.empty() || right.top() >= num){
                left.push(num);
            }else{
                right.push(num);
                left.push(right.top());
                right.pop();
            }
            is_left = !is_left;
            return;
        }
        if(!is_left){
            if(left.empty() || left.top() <= num){
                right.push(num);
            }else{
                left.push(num);
                right.push(left.top());
                left.pop();
            }
            is_left = !is_left;
            return;
        }
    }

    double GetMedian()
    { 
        if(!is_left) return left.top();
        if(is_left){
            double re = (left.top() + right.top() ) / 2.0;
            return re;
        }
        return 0;
    }

};
```

### 合并K个排序的链表

合并k个排序链表，并且返回合并后的排序链表。尝试分析和描述其复杂度。

[合并k个排序链表](http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/)

很容易想到的方法是每次从这K个链表中找到一个最小的数字，把它加入到新的链表中，直到所有的节点都搜索完就可以了。这样的方法可以用来练习练习，自己指针的操作水平，但是不是最高效的解法。

这种解法的代码如下：

```c
ListNode *mergeKLists(vector<ListNode *> &lists) {
    // write your code here
    ListNode* guard = new ListNode(0);
    ListNode* head = guard;

    // current 指向K个链表的头指针
    vector<ListNode*> currents;
    for(auto link : lists){
        if(link != nullptr)
            currents.push_back(link);
    }

    int index = 0;
    while(!currents.empty()){
        int minV = INT32_MAX;
        for(int i = 0; i < currents.size();++i){
            // 去掉已经为空的链表
            if(currents[i] == nullptr){
                currents.erase(currents.begin()+i);
            }
            if(currents[i]->val < minV){
                index = i;
                minV = currents[i]->val;
            }
        }
        guard->next = currents[index];
        guard = guard->next;
        if(currents[index]->next != nullptr)
            currents[index] = currents[index]->next;
        else
            currents.erase(currents.begin()+index);
    }
    return head->next;
}
```

在K个链表中每次找到最小的数的代价是o(K), 需要扫描到最长的链表结束才能结束，所以算法的复杂度是o(nk).

每次从K个数字中找到最小的数字，时间复杂度是o(k),但是这不是最优的方法，这个时间复杂度可以更低，我们使用堆来维护K个元素，只需要logk的时间就能确定最小元素是谁。

具体做法是建立一个K个元素的小根堆，每次输出堆顶元素之后，把堆顶元素所属链表的下一个元素加入到堆中，调整堆。如此循环直到所有链表都输出。

```c
struct cmp {
    bool operator () (ListNode *a, ListNode *b) {
        return a->val > b->val;
    }
};

ListNode *mergeKLists(vector<ListNode *> &lists) {
        priority_queue<ListNode*, vector<ListNode*>, cmp> q;
        for (int i = 0; i < lists.size(); ++i) {
            if (lists[i]) q.push(lists[i]);
        }
        ListNode *head = NULL, *pre = NULL, *tmp = NULL;
        while (!q.empty()) {
            tmp = q.top();
            q.pop();
            if (!pre) head = tmp;
            else pre->next = tmp;
            pre = tmp;
            if (tmp->next) q.push(tmp->next);
        }
        return head;
}
```














