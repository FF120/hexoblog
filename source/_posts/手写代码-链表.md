---
title: 手写代码
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-09-19 09:50:23
---

需要掌握的一些手写代码

<!--more-->

### [反转链表](http://lintcode.com/zh-cn/problem/reverse-linked-list/)

```c
/**
* 1. 如果是空链表，或者只有一个元素，直接返回头节点
* 2. pre --> head, iter --> head->next, pre->next = nullptr;
* pre 指向第一个元素，iter指向第二个节点(可能为空，为空说明到达了链表的结尾)，断开前两个节点之间的连接
* 3. while(iter!=nullptr) 转换pre iter指向的节点的连接。
* 首先用一个新的节点变量存储iter的下一个节点信息，node = iter->next
* iter->next = pre;
* pre = iter;
* iter = node;
*/
ListNode *reverse(ListNode *head){
    if(!head || !head->next) return head;
    ListNode* pre = head;
    ListNode* iter = head->next;
    pre->next = nullptr;
    while(iter){
        ListNode* next = iter->next;
        iter->next = pre;
        pre = iter;
        iter = next;
    }
    return pre;
}
```

### [局部翻转链表](http://lintcode.com/zh-cn/problem/reverse-linked-list-ii/)

```c
ListNode * reverseBetween(ListNode * head, int m, int n) {
    // 翻转从m到n之间的链表，连接在原来的链表上
    if(!head || !head->next || m <=0 || n <=0 || m >= n) return head;
    // 1. 增加一个头节点
    ListNode* g = new ListNode(0);
    g->next = head;
    head = g;

    ListNode* pre_start = head;
    ListNode* end_next = head;
    // 1. 找到第m个节点的前一个节点
    m = m - 1;
    while(pre_start && m--){
        pre_start = pre_start->next;
    }
    // 2. 找到第n个节点的后一个节点
    n = n + 1;
    while(end_next && n--){
        end_next = end_next->next;
    }

    if(m >0 || n>0) return head;

    // 3. 翻转m 到 n之间的链表
    ListNode* stmp = pre_start->next;
    ListNode* start = pre_start->next;
    ListNode* end = start->next;
    start->next = nullptr;
    while(end != end_next){
        ListNode* tmp = end->next;
        end->next = start;
        start = end;
        end = tmp;
    }
    // 4. 连接到原来的链表上
    pre_start->next = start;
    stmp->next = end;
    return head->next;
}
```

### [K组翻转链表](http://lintcode.com/zh-cn/problem/reverse-nodes-in-k-group/)

```c
ListNode *reverseKGroup(ListNode *head, int k) {
    // 每K个节点翻转一下链表
    if(!head || k <= 1) return head;
    // 增加一个头节点
    ListNode* g = new ListNode(0);
    g->next = head;
    head = g;

    ListNode* pre_start = head;
    ListNode* end_next = head;
    while(true){
        // 1. 找到第K个节点的下一个节点
        int cc = k + 1;
        while(end_next && cc--){
            end_next = end_next->next;
        }
        
        if(cc > 0) break; // 不足K个节点的部分不翻转
        
        // 2. 翻转K个节点
        ListNode* start = pre_start->next;
        ListNode* stmp = pre_start->next;
        ListNode* end = start->next;
        while(end && end != end_next){
            ListNode* tmp = end->next;
            end->next = start;
            start = end;
            end = tmp;
        }
        //3. 连接到原来的链表
        pre_start->next = start;
        stmp->next = end_next;

        //4. 维护pre_start, end_start在正确的位置上，执行下一次循环
        pre_start = end_next = stmp;
    }
    return head->next;
}
```

### [删除链表中倒数第n个节点](http://lintcode.com/zh-cn/problem/remove-nth-node-from-end-of-list/#)

使用两个指针，遍历一遍链表就能解决；

```c
/**
*  删除倒数第K个节点，我们需要找到倒数第K+1个节点
* 1. 设链表的长度是n, 1<=k<=n
* 2. 用两个间隔是K的指针，当第二个指针指向链表的null元素的时候，第一个指针指向导数第K+1个节点
* 3. 在链表的第一个节点的前面添加一个节点guard; first --> guard
* 4. second = guard->next; second向后移动K步，如果在K大于0的时候循环结束，表示没有导数第K个元素，返回原来的链表
* 循环退出的时候，first 和second间隔K个节点，此时同时移动first second, second到达链表结尾的时候，first指向导数第K+1个节点，
* 5. 删除节点： first->next = first->next->next;
*/
ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *g = new ListNode(0);
    g->next = head;
    head = g;
    ListNode* first = g;
    ListNode* second = g->next;
    while(second && n--){
        second = second -> next;
    }
    if(n > 0) return head->next; // n超过了链表的长度
    while(second){
        first = first->next;
        second = second->next;
    }
    first->next = first->next->next;
    return head->next;
}
```

### [判断链表是否有环](http://lintcode.com/zh-cn/problem/linked-list-cycle/)

```c
/**
* 1. head=null 或者 head->next = null，肯定无环
* 2. first = second = head;
* 3. do{}while();  first == second时候循环结束，说明链表有环；
* 4. 一旦找到环，把first = head, 然后一步一步的移动first second, 再次相遇的地方就是环的入口。
*/
bool hasCycle(ListNode *head) {
    if(!head || !head->next) return false;
    ListNode* first = head;
    ListNode* second = head;
    do{
        first = first->next;
        second = second->next->next;
    }while(first && second && second->next && second != first);

    if(!first || !second || !second->next) return false;
    // 找到入口节点
    first = head;
    while(first != second){
        first = first->next;
        second = second->next;
    }
    return true;
}
```

### [判断链表是否相交](http://lintcode.com/zh-cn/problem/intersection-of-two-linked-lists/)

两种思路： 一种先遍历一遍两个链表，得出每个链表的长度，将尾部对其，判断

另外一种，将一个链表的尾部连接到其头结点，从另外一个链表的头节点开始遍历，转换成判断链表是否有环的问题。

```c
bool hasCycle(ListNode *head,ListNode* &enter) {
    if(!head || !head->next || !head->next->next) return false;
    ListNode* first = head;
    ListNode* second = head;
    do{
        first = first->next;
        second = second->next->next;
    }while(first && second && second->next && first != second);
    if(!first || !second || !second->next) return false;
    // 找到入口节点
    first = head;
    while(first != second){
        first = first->next;
        second = second->next;
    }
    enter = first;
    return true;
}

ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    if(!headA || !headB) return nullptr;
    ListNode* iterA = headA;
    while(iterA->next !=nullptr){
        iterA = iterA->next;
    }
    iterA->next = headA;
    ListNode* enter;
    hasCycle(headB,enter);
    return enter;
}
```

### [合并K个排序的链表](http://lintcode.com/zh-cn/problem/merge-k-sorted-lists/)

1. 第一方法，用一个数组保存K个链表的头指针，每次都比较K个元素的大小，选出最小的元素，链接到新的链表的结尾，然后该链表向下一个节点移动一位。

2. 利用上面的思路，每次都要从K个元素中选择最小的元素，可以使用一个K个元素的最小堆实现，降低时间复杂度。

3. 利用归并的思想，两两合并；

```c
// 每次找出最小值的方式
 ListNode *mergeKLists(vector<ListNode *> &lists) {
    // write your code here
    ListNode* guard = new ListNode(0);
    ListNode* head = guard;

    // current 指向K个链表的头指针
    vector<ListNode*> currents;
    for(auto link : lists){
        if(link != nullptr)
            currents.push_back(link);
    }

    int index = 0;
    while(!currents.empty()){
        int minV = INT32_MAX;
        for(int i = 0; i < currents.size();++i){
            // 去掉已经为空的链表
            if(currents[i] == nullptr){
                currents.erase(currents.begin()+i);
            }
            if(currents[i]->val < minV){
                index = i;
                minV = currents[i]->val;
            }
        }
        guard->next = currents[index];
        guard = guard->next;
        if(currents[index]->next != nullptr)
            currents[index] = currents[index]->next;
        else
            currents.erase(currents.begin()+index);
    }
    return head->next;
}
```

```c
// 归并排序的方式
// 通过调用合并两个排序链表的方式实现
ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
    // write your code here
    ListNode* guard = new ListNode(0);
    ListNode* head = guard;
    while(l1 && l2){
        if(l1->val > l2->val){
            guard->next = l2;
            guard = guard->next;
            l2 = l2->next;
        }else{
            guard->next = l1;
            guard = guard->next;
            l1 = l1->next;
        }
    }
    if(l1){
        guard->next = l1;
    }
    if(l2){
        guard->next = l2;
    }
    return head->next;
}

ListNode *mergeKLists(const vector<ListNode *> &lists) {
    if(lists.empty()) return nullptr;
    if(lists.size() == 1) return lists[0];
    if(lists.size() == 2) return mergeTwoLists(lists[0],lists[1]);

    size_t n = lists.size();
    vector<ListNode*> left((n+1)/2),right(n-(n+1)/2);
    copy(lists.begin(),lists.begin()+(n+1)/2,left.begin());
    copy(lists.begin()+(n+1)/2,lists.end(),right.begin());
    return mergeTwoLists(mergeKLists(left),mergeKLists(right));
}
```

上面采用的是自顶向下的递归归并的方式，下面采用非递归的自底向上的方法来实现

```c
// 简单的实现一个数据的归并求和
// 自底向上归并
int solve(vector<int> &v){
    size_t end = v.size() - 1;
    if(end < 0) throw "";
    if(end == 0) return v[0];
    while(end > 0){
        int index = 0;
        for(int i=0;i<=end;i+=2){
            if(i+1 <= end){
                v[index] = add(v[i],v[i+1]);
                index++;
            }else{
                v[index] = v[i];
                index++;
            }
        }
        end = index - 1;
    }
    return v[0];
}
```

```c
ListNode *mergeKLists(vector<ListNode *> &lists) {
    
    if(lists.empty()) return nullptr;
    if(lists.size() == 1) return lists[0];
    if(lists.size() == 2) return mergeTwoLists(lists[0],lists[1]);

    size_t end = lists.size() - 1;
    while(end > 0){
        int index = 0;
        for(int i=0;i<=end;i+=2){
            if(i+1 <= end){
                lists[index] = mergeTwoLists(lists[i],lists[i+1]);
                index++;
            }else{
                lists[index] = lists[i];
                index++;
            }
        }
        end = index - 1;
    }
    return lists[0];
}
```

### [带随机指针链表的复制|复杂链表的复制](http://lintcode.com/zh-cn/problem/copy-list-with-random-pointer/)

使用O（1）的额外空间完成链表的复制，基本思路是把拷贝的新节点链接在原来节点的后面，设置完随机指针之后再断开与原来旧链表的连接。

```c
RandomListNode *copyRandomList(RandomListNode *head) {
    // write your code here
    if(!head) return head;
    RandomListNode* iter = head;
    // 1. 复制每个节点连接在原来节点的后面
    while(iter){
        RandomListNode* node = new RandomListNode(iter->label);
        node->next = iter->next;
        iter->next = node;
        iter = node->next;
    }
    // 2. 设置随机指针
    RandomListNode* newHead = head->next;
    head->next->random = head->random==nullptr ? nullptr : head->random->next;
    iter = newHead->next;
    while(iter){
        RandomListNode* next = iter->next->next;
        iter->next->random = iter->random == nullptr ? nullptr : iter->random->next;
        iter = next;
    }
    // 3. 断开和旧链表的连接
    iter = newHead;
    while(iter->next){
        iter->next = iter->next->next;
        iter = iter->next;
    }
    return newHead;
}
```