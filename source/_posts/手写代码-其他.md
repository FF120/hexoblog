---
title: 手写代码-其他
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-09-27 23:12:30
---

### 快速排序

```c
int partition(vector<int> &v,int i,int j){
    // 以i指向的元素为基准元素
    bool base = true; // base = true 表示此时 i 指向base 元素， base = false 表示此时j 指向base元素
    while(i < j){
        if(v[i] > v[j] && base){
            swap(v[i],v[j]);
            base = false;
            i++;
        }
        if(v[i] > v[j] && !base){
            swap(v[i],v[j]);
            base = true;
            j--;
        }
        if(base){
            j--;
        }
        if(!base){
            i++;
        }
    }
    return i;
}
/**
 * 快速排序
 * @param v  待排序数组
 * @param start  起始位置下标
 * @param end  结束位置下标
 */
void quickSort(vector<int> &v,int start, int end){
     if(start >= end) return;
     int mid = partition(v,start,end);
     quickSort(v,start,mid-1);
     quickSort(v,mid+1,end);
}

```

### 第K小的数

`int partition(vector<int> &v,int i,int j)` 返回一趟快排之后基准元素的位置，其前面的都小于它，后面的都大于它，这样一次可以确定一半，这样递归的处理，每次减少一半，效率近似二分查找。

```c
int Kth(vector<int> &v, int k){
    if(v.empty() || k <= 0) return -1;
    int begin = 0;
    int end = v.size() - 1;
    while(true){
         int i = partition(v,begin,end);
         if(i+1 == k) return v[i];
         if(i+1 < k){
            begin = i + 1;
         }else{
            end = i - 1;
         }
    }
}
```

### 归并排序

```c
void merge(vector<int> &v,int s1,int e1, int s2, int e2){
    vector<int> tmp;
    int ss1 = s1, ss2 = s2;
    while(s1<=e1 && s2 <= e2){
        if(v[s1] < v[s2]){
            tmp.push_back(v[s1]);
            s1++;
        }
        if(v[s1] >= v[s2]){
            tmp.push_back(v[s2]);
            s2++;
        }
    }
    if(s1 <= e1){
        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1);
    }
    if(s2 <= e2){
        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1);
    }
    int t = 0;
    for(int i=ss1;i<=e1;i++){
        v[i] = tmp[t];
        t++;
    }
    for(int i = ss2;i<=e2;i++){
        v[i] = tmp[t];
        t++;
    }
    tmp.clear();
    return ;
}
void mergeSort(vector<int> &v,int start,int end){
    if(start >= end) return;
    int mid = (start+end) / 2;
    mergeSort(v,start,mid);
    mergeSort(v,mid+1,end);
    merge(v,start,mid,mid+1,end);
}
```

### 统计逆序对

在归并排序归并两个已经排好序的数组的时候，是统计逆序对的最好时机。

```c
void merge(vector<int> &v,int s1,int e1, int s2, int e2, int &cc){
    vector<int> tmp;
    int ss1 = s1, ss2 = s2;
    while(s1<=e1 && s2 <= e2){
        if(v[s1] <= v[s2]){
            tmp.push_back(v[s1]);
            s1++;
        }
        if(v[s1] > v[s2]){
            tmp.push_back(v[s2]);
            s2++;
            cc += e1-s1+1; // 记录逆序对的数量
        }
    }
    if(s1 <= e1){
        tmp.insert(tmp.end(),v.begin() + s1,v.begin() + e1+1);
    }
    if(s2 <= e2){
        tmp.insert(tmp.end(),v.begin() + s2,v.begin() + e2+1);
    }
    int t = 0;
    for(int i=ss1;i<=e1;i++){
        v[i] = tmp[t];
        t++;
    }
    for(int i = ss2;i<=e2;i++){
        v[i] = tmp[t];
        t++;
    }
    tmp.clear();
    return ;
}
void mergeSort(vector<int> &v,int start,int end,int &cc){
    if(start >= end) return ;
    int mid = (start+end) / 2;
    mergeSort(v,start,mid,cc);
    mergeSort(v,mid+1,end,cc);
    merge(v,start,mid,mid+1,end,cc);
}
```