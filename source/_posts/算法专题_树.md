---
title: 算法专题：树及相关的常见问题
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-09 17:33:46
---
## 二叉树
每个节点最多有两个子节点的树叫做二叉树。类型有：完全二叉树，满二叉树和完美二叉树。
### 二叉树的性质
- 二叉树的第i层节点数目至多是`2^(i-1); (i>=1)`
- 深度为K的二叉树至多有`2^(K-1)`个节点。
- 二叉树中出度为2的节点数目记作n2, 叶节点记作n0; 则有`n0 = n2 + 1`
- 深度为n的完美二叉树，其节点的数目是`2^n -1`, 叶节点数目是`2^(n-1)`, 非叶节点的数目是`2^(n-1)-1`
- 节点数目为n的完美二叉树，深度是`log2(n+1)`
- 节点数目为n的完全二叉树，深度是`[log2(n)] + 1`  其中[]表示向下取整

### 二叉树的操作


#### 结构的定义
二叉树的结构和双向链表比较相似，需要两个指针分别指向左孩子和右孩子。
```c++
class TreeNode {
public:
   int val;
   TreeNode *left, *right;
   TreeNode(int val) {
       this->val = val;
       this->left = this->right = nullptr;
   }
}
```

#### 创建
根据二叉树的前序遍历和中序遍历的结果创建二叉树，根据前序遍历序列和中序遍历序列可以唯一的确定一棵二叉树。
假设前序遍历的序列是pre; 中序遍历的序列是vin;里面都不含有重复数字；
首先确定根节点，肯定是pre[0], 然后在vin中寻找pre[0], 它前面的一定是左子树上的，后面的都是右子树上的。
假设pre[0]出现在vin[3],可以知道左子树上有三个节点，分别是vin[0],vin[1],vin[2], 在pre中从pre[0]以后数3个数字
这三个数字一定是位于左子树上的，剩下的属于右子树。
分别按照上面的方法递归处理左右子树，直到只剩下一个元素，返回答案；
举例来说，假设`pre = [1,2,4,7,3,5,6,8] `   `vin=[4,7,2,1,5,3,8,6]`
第一次： 可知1是根，2，4，7是1的左子树上的，3,5,6,8,是1的右子树上的。 分别处理序列`[2,4,7] [4,7,2]` 和` [3,5,6,8] [5,3,6,8]`
第二次： 对于`[2,4,7] [4,7,2]` 可以得到2是根，而4，7都是左子树上的， 接着处理`[4,7] [4,7]` 此时4是根，而7位于右子树上，这边处理完毕；
         对于`[3,5,6,8] [5,3,8,6]` 可以得到3是根，5是左子树上的，`[6,8]`是右子树上的。接着处理`[6,8][8,6]` 此时6是根，而8位于左子树上。

综合上面的分析，可以得到这个二叉树的形状如下：
```
               1
		  ----------
		  |        |
          2	       3
	  ------     ------
      |          |   |
      4          5   6
	 ----           ----
       |            |
       7	        8
```

```C++
TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
         if(pre.empty() | vin.empty()){return nullptr;}
        TreeNode* node = new TreeNode(pre[0]);// 先建立根节点
        int len = pre.size();
        for(size_t i=0;i<vin.size();++i){
            if(vin[i] == pre[0]){
                // 找到了中序遍历的根节点，则左面的全部是左子树，右面的全部是右子树。
                vector<int> left_pre(i,0);
                vector<int> left_vin(i,0);
                vector<int> right_pre(len-1-i,0);
                vector<int> right_vin(len-1-i,0);
                copy(vin.begin(),vin.begin()+i,left_vin.begin());
                copy(vin.begin()+i+1,vin.end(),right_vin.begin());
                copy(pre.begin()+1,pre.begin()+1+i,left_pre.begin());
                copy(pre.begin()+i+1,pre.end(),right_pre.begin());
                node->left =  reConstructBinaryTree(left_pre,left_vin);
                node->right = reConstructBinaryTree(right_pre,right_vin);
            }

        }
        return node;
```
#### 遍历
##### 前序遍历(递归)
前序遍历就是按照`root->left->right`的顺序遍历二叉树
二叉树的遍历最方便的是使用递归函数，因为二叉树本身就是递归定义的，使用递归处理二叉树会比较方便。
**前序遍历遍历的步骤**：
1. 输出当前节点
2. 如果有左孩子，用左孩子做参数递归
3. 如果有右孩子，用由孩子做参数递归

```C++
 vector<int> preorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        re.push_back(root->val);
        if(root->left){
            vector<int> ll = preorderTraversal(root->left);
            re.insert(re.end(), ll.begin(), ll.end());
        }
        if(root->right){
            vector<int> rr = preorderTraversal(root->right);
            re.insert(re.end(), rr.begin(), rr.end());
        }
        return re;
    }
```
##### 前序遍历(非递归)
非递归的实现，递归函数的实现是使用堆栈的方式，所以把递归调用的函数改写成非递归的形式一般也是使用堆栈作为数据结构。
**前序遍历的非递归遍历步骤**
1. 输出输出当前的节点值，并把当前的节点压入栈
2. current = current->left;
循环以上步骤知道没有左孩子，执行下面的步骤
3. 取栈顶元素的右孩子，弹出栈顶元素，然后回到步骤1.
```C++
//前序遍历的非递归实现
vector<int> preorderTraversal(TreeNode *root) {
	vector<int> re;
	 if(root == nullptr) return re;
	 stack<TreeNode*> s;
	 TreeNode *tmp = root;
	 while(tmp!=nullptr || !s.empty()){ // 逻辑或是短路的
		while(tmp!=nullptr){
			re.push_back(tmp->val);
			s.push(tmp);
			tmp = tmp->left;
		}
		// 循环退出说明没有了左孩子
		if(!s.empty()){
		   tmp = s.top();
		   s.pop();
		   tmp = tmp->right;
		}
	 }
	 return re;
}
```
##### 中序遍历(递归)
中序遍历就是按照`left->root->right`的数序遍历二叉树
**中序遍历遍历的步骤**：
1. 如果当前的节点有左孩子，用左孩子作为参数递归
2. 输出当前节点
3. 如果当前节点有右孩子，用右孩子作为参数递归

```C++
vector<int> inorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = inorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        re.push_back(root->val);
        if(root->right){
            vector<int> rr = inorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        return re;
    }
```
##### 中序遍历(非递归)
**中序遍历的非递归实现**
1. 对于当前的节点，放入堆栈，然后搜索有没有左孩子，一直向下搜索到没有左孩子为止。
2. 从堆栈取出栈顶元素，输出，然后搜索右孩子

```C++
//中序遍历的非递归实现
vector<int> preorderTraversal(TreeNode *root) {
	 vector<int> re;
	 if(root == nullptr) return re;
	 stack<TreeNode*> s;
	 TreeNode *tmp = root;
	 while(tmp!=nullptr || !s.empty()){ // 逻辑或是短路的
		while(tmp!=nullptr){
			s.push(tmp);
			tmp = tmp->left;
		}
		// 循环退出说明没有了左孩子
		if(!s.empty()){
		   tmp = s.top();
		   re.push_back(tmp->val);
		   s.pop();
		   tmp = tmp->right;
		}
	 }
	 return re;
}
```
##### 后序遍历(递归)
后序遍历就是按照`left->right->root`的顺序遍历二叉树
**后序遍历遍历的步骤是**：
1. 如果当前节点有左孩子，用左孩子作为参数递归
2. 如果当前节点有右孩子，用右孩子作为参数递归
3. 输出当前节点
```C++
 vector<int> postorderTraversal(TreeNode *root) {
        // write your code here
        vector<int> re;
        if(root == nullptr) return re;
        if(root->left){
            vector<int> ll = postorderTraversal(root->left);
            re.insert(re.end(),ll.begin(),ll.end());
        }
        if(root->right){
            vector<int> rr = postorderTraversal(root->right);
            re.insert(re.end(),rr.begin(),rr.end());
        }
        re.push_back(root->val);
        return re;
    }
```
##### 后序遍历(非递归)
**后序遍历的非递归实现**
第一种思路：对于任一结点P，将其入栈，然后沿其左子树一直往下搜索，直到搜索到没有左孩子的结点，此时该结点出现在栈顶，但是此时不能将其出栈并访问，因此其右孩子还为被访问。所以接下来按照相同的规则对其右子树进行相同的处理，当访问完其右孩子时，该结点又出现在栈顶，此时可以将其出栈并访问。这样就保证了正确的访问顺序。可以看出，在这个过程中，每个结点都两次出现在栈顶，只有在第二次出现在栈顶时，才能访问它。因此需要多设置一个变量标识该结点是否是第一次出现在栈顶。
```C++
//后序遍历的非递归实现

```

第二种思路：要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点P，先将其入栈。如果P不存在左孩子和右孩子，则可以直接访问它；或者P存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将P的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。
```C++

```
- 层次遍历
二叉树的层次遍历类似与图的广度优先搜索，可以使用队列来实现。
思路是： 使用两个队列保存相邻两层的节点，循环输出每层的节点

**层次遍历遍历的步骤**：
1. 初始化两个队列d1,d2;令d1保存root,d2为空。
2. 清空d2,遍历d1中的节点，把d1中节点的所有孩子节点按照顺序放入d2中；
3. 打印d1中的节点
4. 交换d1和d2;转到2；
循环直到d2中为空，结束。

```C++
// 从底向上层次遍历二叉树
 vector<vector<int>> levelOrderBottom(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        vector<TreeNode*> v1,v2;
        if(root == nullptr){
            return result;
        }
        v1.push_back(root);
        while(!v1.empty()){
            // 遍历v1中的所有节点，将下一层节点保存在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            vector<int> tmp;
            //打印v1
            for(int i=0;i<v1.size();i++){
                tmp.push_back(v1[i]->val);
            }
            result.insert(result.begin(),tmp);
            swap(v1,v2);
            v2.clear();
        }
        return result;
 }
```

```C++
// 自顶向上遍历二叉树
 vector<vector<int>> zigzagLevelOrder(TreeNode *root) {
        // write your code here
        vector<vector<int>> result;
        if(!root) return result;
        vector<TreeNode*> v1,v2;
        v1.push_back(root);
        int level = 1;
        while(!v1.empty()){
            //遍历v1中的节点，把v1中所有节点的下一级节点存储在v2中
            for(int i=0;i<v1.size();i++){
                if(v1[i]->left){
                    v2.push_back(v1[i]->left);
                }
                if(v1[i]->right){
                    v2.push_back(v1[i]->right);
                }
            }
            // 打印v1中的节点,如果level 是奇数，则从左向又打印，
            // 如果level是偶数，则从右向左打印
            vector<int> tmp;
            if(level % 2 == 0){
                for(int i=v1.size()-1;i>=0;i--){
                    tmp.push_back(v1[i]->val);
                }
            }
            if(level % 2 ){
                for(int i=0;i<v1.size();i++){
                    tmp.push_back(v1[i]->val);
                }
            }
            result.push_back(tmp);
            // 更新该更新的数据
            swap(v1,v2);
            v2.clear();
            level++;
        }
        return result;

    }
```
#### 可视化
#### 插入、修改、删除
### 二叉树的应用
#### 哈夫曼编码
## 二叉查找树
## 平衡二叉树
## AVL树
## 红黑树
## B树
## B+树
## Trie树
## 堆

## 线段树

### 线段树的构造
### 线段树的查询
### 线段树的更新
