---
title: 一维数组相关的问题
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-03-20 21:42:45
---
一维数组相关的各种算法题目
<!-- more -->

## 求一个数组N宽度为m的子数组的最大值
![max_value](2017-03-21_090951.png)
解法： 维护一个宽度是m的滑动窗口的双端队列结构。始终在队列的尾部保存最大值的
下标，始终在队尾保存最小值的下标。从头到位扫描N数组，每扫描一个数，就按照相应的规则更新
双端队列，把超出范围的下标出队，找到当前的最大值保存下来。
```C++
#include <iostream>
#include <deque>
#include <vector>
using namespace std;

vector<int> getMaxs(vector<int> v,int w){
    deque<int> q;
    vector<int> result;
    for(int i=0;i<int(v.size());++i){
        if(v.empty()){
            v.push_back(i);
        }
        else if(v[i]<=v[q.back()]){
            v.push_back(i);
        }
        else{
            v.pop_back();
            if(v.empty()){
                v.push_back(i);
            }
            else{
                while(v[q.back()]<=v[i]){
                    q.pop_back();
                    if(q.empty()){
                        q.push_back(i);
                        break;
                    }
                }
                q.push_back(i);

            }
        }
        if(i-w == q.front()){
            q.pop_front();
        }
        if(i>=w-1){
            result.insert(result.end(),v[q.front()]);
        }
    }
    return result;

}

/**
 * 求滑动窗口做最大值,改进的分支逻辑，减少了if判断
 * @param v
 * @param w
 * @return
 */
vector<int> getMaxes2(vector<int> v, int w){
    vector<int> result;  // store result
    deque<int> d; //store index of the array
    for(int i=0;i<v.size();++i){
        if(!d.empty() && v[d.back()]<=v[i]){
            while(v[d.back()<=v[i]] && !d.empty()){
                d.pop_back();
            }
            d.push_back(i);
        }
        else{
            d.push_back(i);
        }
        if(i-w == d.front()){
            d.pop_front();
        }
        // 记录结果
        if(i>=w-1){
            result.insert(result.end(),v[d.front()]);
        }
    }
    return result;
}
/**
 * 求滑动窗口最小值
 * @param v
 * @param w
 * @return
 */
vector<int> getMines(vector<int> v,int w){
    vector<int> result;
    deque<int> min;
    for(int i=0;i<v.size();++i){
        if(!min.empty() && v[min.back()]>=v[i]){
            while(!min.empty() && v[min.back()]>=v[i]){
                min.pop_back();
            }
            min.push_back(i);
        }
        else{
            min.push_back(i);
        }
        if(i-w ==min.front()){
            min.pop_front();
        }
        //记录结果
        if(i>=w-1){
            result.insert(result.end(),v[min.front()]);
        }

    }
    return result;
}

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}

```
如果要求滑动窗口的最小值，只需要在判断大小的时候改变一下即可。
## 求一个数组的子数组最大值和最小值的差
![2017-03-21_091927.png](2017-03-21_091927.png)
这个题目和上一个很类似，只需要维护两个双端队列结构，一个用来找到当前窗口对应的数组的最大值，
一个用来找到当前窗口对应的数组的最小值。然后做差，就可以。
```C++
#include <iostream>
#include <vector>
#include <deque>
/**
 * 求一个数组的子数组最大值和最小值的差
 * @return
 */
int main() {
    vector<int> v = {6,5,4,3};
    int num=3;
    int count = 0;
    for(int i=0;i<v.size();++i){
        int j = i;
        deque<int> max;
        deque<int> min;
        while(j<v.size()){

            // 维护max
            if(!max.empty() && v[max.front()]<=v[j]){
                while(!max.empty() && v[max.front()<=v[j]]){
                    max.pop_back();
                }
                max.push_back(j);
            }
            else{
                max.push_back(j);
            }
            //维护min
            if(!min.empty() && v[min.front()]>=v[j]){
                while(!min.empty() && v[min.front()>=v[j]]){
                    min.pop_back();
                }
                min.push_back(j);
            }
            else{
                min.push_back(j);
            }
            //判断当前数组是否满足条件，如果该数组不满足条件，那么所有包含该数组的将全部不满足条件
            if(v[max.front()]-v[min.front()]>num){
                count+=j-i;
                break;
            }
            if(j==v.size()-1){
                count+=j-i+1;
            }
            ++j;
        }
//        while(!max.empty()){
//            max.pop_back();
//        }
//        while(!min.empty()){
//            min.pop_back();
//        }
    }
    cout<<count<<endl;
    return 0;
}
```
## 最长递增子序列
![2017-03-21_092428.png](2017-03-21_092428.png)
解法：用动态规划的方法，生成一个与数组长度一样的数组dp. dp[i]表示以i结尾的递增子序列的长度。
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
/**
 * 最长递增子序列
 * 给定数组arr,返回arr的最长递增子序列。
 * e.g. arr = [2,1,5,3,6,4,8,9,7]  返回 1,3,4,8,9 或 2，3，4，8，9
 * @param v
 * @return
 */
vector<int> getIncrease(vector<int> v){
    vector<int> dp(v.size(),1);//dp的第一个元素为1，表示以第一个元素结果时，最长递增子序列的长度是1，只包括自己
    for(int i=1;i<v.size();++i){
       for(int j=i-1;j>=0;--j){
           dp[i] = 1;
           if(v[j]<v[i]){
               dp[i] = max(dp[i],dp[j]+1);
           }
       }
    }
    for(int i=0;i<v.size();++i){
        cout<<dp[i]<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> v = {2,1,5,3,6,4,8,9,7};
    getIncrease(v);
    cout<<endl;
    return 0;
}
```

## 排成一条线的纸牌博弈问题
![2017-03-21_102624.png](2017-03-21_102624.png)
时间复杂度O(N^2), 空间复杂度O(N^2)
生成两个大小N*N的矩阵
N1的dp[i][j]表示arr[i...j]这个排列上如果A先拿，最终能得到什么分数。
N2的dp[i][j]表示arr[i...j]这个排列上如果B后拿，最终能得到什么分数。
```C++

```

## 跳跃游戏
![2017-03-21_103300.png](2017-03-21_103300.png)
没有使用动态规划，设置几个指示变量，遍历一遍数组即可做到。
```C++
#include <iostream>
#include <vector>
using namespace std;
/**
 * 跳跃游戏
 * @param v 
 * @return 
 */
int getMin(vector<int> v){
    if(v.empty()) return 0;
    int jump = 0;
    int current = 0;
    int next = 0;
    for(int i=0;i<v.size();++i){
        if(current < i){
            ++jump;
            current = next;
        }
        next = max(next,i+v[i]);
    }
    return jump;
}
int main() {
    vector<int> v = {3,2,3,1,1,4};
    int re = getMin(v);
    cout<<re<<endl;
    return 0;
}
```
## 数组中的最长连续序列
![2017-03-21_104858.png](2017-03-21_104858.png)
使用哈希表保存数组中的数字，每次新加入数字是看是否能够合并成连续序列，利用额外的变量记录连续序列的情况。
时间复杂度和空间复杂度都是O(N)

## 计算数组的小和
![2017-03-21_133320.png](2017-03-21_133320.png)
使用一种归并排序的思想，时间复杂度可以控制在O（N*logN）

## 子数组的最大累加和
![2017-03-21_134743.png](2017-03-21_134743.png)
![2017-03-21_135757.png](2017-03-21_135757.png)
```C++
#include <iostream>
#include <vector>
using namespace std;
/**
 * 子数组的最大累加和问题
 * @return
 */
int getMaxSum(vector<int> v){
    if(v.empty()){return 0;}
    int sum = 0; //遍历到v[i]的累加和
    int maxValue = -10000; // 遍历到v[i]时最大的累加和
    for(int i=0;i<v.size();i++){
        sum += v[i];
        if(sum < 0){
            sum = 0;
        }
        maxValue = max(maxValue,sum);
    }
    return maxValue;
}
int main() {
    vector<int> v = {1,-2,3,5,-2,6,-1};
    cout<<getMaxSum(v)<<endl;
    return 0;
}
```

## 在数组中找到一个局部最小的位置
![2017-03-21_141706.png](2017-03-21_141706.png)
最容易想到的解法：从头开始遍历数组，一旦遇到a[i-1]>a[i] && a[i]<a[i+1]的位置，终止
遍历，输出i. 最坏的情况下时间复杂度是O（N）

采用二分查找的方法，时间复杂度可以降到O(logN). 二分查找并不是数组有顺序的时候才可以使用，
只要确定二分之后的某一侧必定有你要找的数，就可以使用二分查找来降低时间复杂度。
一般是从O（N） 降低到 O（logN ）[原书中提供的方法有误]
```C++
#include <iostream>
#include <vector>
using namespace std;
/**
 * 找到任意一个局部最小的位置并返回索引
 * 从左边开始，如果第二个数比第一个数小，第二个数是局部最小
 * 从右边开始，如果第二个数比第一个数小，第二个数是局部最小
 * 如果数组是空 ，没有局部最小
 * 如果数组只有一个数，这个数就是局部最小
 * else  局部最小就是两边挨着的数都比它大
 * 这里规定这个数组任意相邻的数都不相等
 * @param v
 * @return
 */
int getMinPart(vector<int> v){
    if(v.empty()) return -1;
    if(v.size() == 1) return v[0];
    if(v[0]>v[1]) return 1;
    if(v[v.size()-1]<v[v.size()-2]) return v.size()-2;
    for(int i=2;i<=v.size()-2;++i){
        if(v[i-1]>v[i] && v[i] < v[i+1]){
            return i;
        }
    }
    return -1; // 如果没有局部最小值，返回-1
}
int main() {
    vector<int> v = {1,2,1,4,3,5};
    cout<<getMinPart2(v)<<endl;
    return 0;
}
```

## 数组中子数组的最大累乘积
![2017-03-21_150344.png](2017-03-21_150344.png)
解法： 分别求以v[i]结尾的子数组的最大累成积，dp[i],
dp[i]可以由dp[i-1]求出来，所以整体的时间复杂度是O（N）
因为最后的结果是求做大累乘积，而dp[i]只和dp[i-1]有关系，所以可以不用维护动态规划表，
空间复杂度可以降低到O（1）
```C++
#include <iostream>
#include <vector>
using namespace std;
/**
 * 求数组的最大子数组累乘积
 * 暴力的方法，就是枚举所有的子数组，计算子数组的累乘，然后取最大值
 * @param v
 * @return
 */
double getMaxC(vector<double> v){
    if(v.empty())  return 0;
    double maxC = -1000;
    double sum = 1;
    for(int i=0;i<v.size();++i){
        sum  = 1;
        for(int j=i;j<v.size();++j){
            sum = sum * v[j];
            maxC = max(maxC,sum);
        }
    }
    return maxC;
}
/**
 * 暴力的方法需要的时间复杂度是2重循环，是O(N**2)
 * 下面用记录最大累乘和最小累乘值的方法做，时间复杂度是O(N)
 * 1. 所有的子数组必然以v[i]结尾，首先计算v[0]结尾的最大值和最小值，都是v[0]
 * 2. 以v[i]结尾的数组的最大值的情况有这样几种；
 * max*v[i] ; min*v[i], v[i] 分别对应 v[i]正，负 和dp[i-1]是0的情况
 * @return
 */
double getMaxC2(vector<double> v){
    if(v.empty()) return 0;

    double maxValue = v[0];
    double minValue = v[0];
    double dpi = v[0]; // 存放前一个的结果
    double maxEnd = 0;
    double minEnd = 0;
    for(int i=1;i<v.size();++i){
        maxEnd = maxValue * v[i];
        minEnd = minValue * v[i];
        maxValue = max(max(maxEnd,minEnd),v[i]);
        minValue = min(min(maxEnd,minEnd),v[i]);
        dpi = max(dpi,maxValue);
    }
    return dpi;

}
int main() {
    vector<double> v={-2.5,4,0,3,0.5,-8,8,-1};
    cout<<getMaxC(v)<<endl;
    cout<<getMaxC2(v);
    return 0;
}
```
## 不包含本位置位的累乘数组
![2017-03-21_161407.png](2017-03-21_161557.png)
如果可以使用除法，那么问题很简单，先求累乘，再除以v[i]. (不包含0的情况)
如果数组中有一个0，则0位置上是累乘，其他位置是0
如果数组中有两个及以上的0， 则所有位置都是0；

如果不能使用除法运算，可以考虑除去自己的乘积，就是从左边乘到v[i-1] 再从右边乘到v[i+1];

```C++
#include <iostream>
#include <vector>

using namespace std;
/**
 * 不包含本位置位的累乘数组,可以使用除法
 */
vector<int> getC(vector<int> v){
    int sum = 1;
    for(auto i : v){
        sum *= i;
    }
    for(int i = 0;i<v.size();++i){
        v[i] = sum / v[i] ;
    }
    return v;

}
void printVecor(vector<int> v){
    for(auto i : v){
        cout<<i<<" ";
    }
    cout<<endl;
}
/**
 * 不使用除法的版本
 * @param v
 * @return
 */
vector<int> getC2(vector<int> v){
    vector<int> lr;
    vector<int> rl;
    int lrsum = 1;
    int rlsum = 1;
    for(int i=0;i<v.size();i++){
        lrsum *= v[i];
        lr.push_back(lrsum);
        rlsum *= v[v.size()-1-i];
        rl.push_back(rlsum);
    }
    vector<int> rl2;
    for(int i=v.size()-1;i>=0;--i){
        rl2.push_back(rl[i]);
    }
    v[0] = rl2[1];
    v[v.size()-1] = lr[v.size()-2];
    for(int i=1;i<v.size()-1;++i){
        v[i] = lr[i-1] * rl2[i+1];
    }
    return v;
}
/**
 * 减少空间复杂度的版本
 * @param v
 * @return
 */
vector<int> getC3(vector<int> v){
    if(v.empty()) return {};
    vector<int> re(v);
    re[0] = v[0];
    for(int i=1;i<v.size()-1;++i){
        re[i] = re[i-1] * v[i];
    }
    int tmp =1;
    for(int i=v.size()-1;i>0;--i){
        re[i] = re[i-1] * tmp ;
        tmp *= v[i];
    }
    re[0] = tmp;

    return re;
}

int main() {
    vector<int> v = {2,3,1,4};
    auto result = getC(v);
    auto result2 = getC2(v);
    auto  result3 = getC3(v);
    printVecor(result);
    printVecor(result2);
    printVecor(result3);
    return 0;
}
```
## 数组的partition调整
![2017-03-21_200734.png](2017-03-21_200734.png)
都用到了用下标指示不同的分区的思想。
```C++
#include <iostream>
#include <vector>
using namespace std;
void setV(vector<int> &v){
    int u = 0;
    for(int i=1;i<v.size();++i){
        if(v[i]>v[u]){
            swap(v[i],v[u+1]);
            u++;
        }

    }

}
void sortV(vector<int> &v){
    if(v.empty()) return;
    int left = -1;
    int index = 0;
    int right = v.size();
    while(index < right){
        if(v[index] == 0){
            swap(v[++left],v[index++]);
        }else if(v[index] == 2){
            swap(v[index],v[--right]);
        }else{
            index++;
        }
    }
}
void print(vector<int> v){
    for(auto a: v){
        cout<<a<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> v = {1,2,2,3,3,4,4,4,5,6,7};
    setV(v);
    print(v);

    vector<int> v2 = {1,0,1,0,1,1,1,2,2,0,0};
    sortV(v2);
    print(v2);
    return 0;
}
```
## 数组中未出现的最小正整数
![2017-03-21_213108.png](2017-03-21_213108.png)
```C++
#include <iostream>
#include <vector>
using namespace std;
/**
 * 给定一个无序的整形数组，找到数组中未出现的最小正整数。
 * @param v 
 * @return 
 */
int missNum(vector<int> v){
    int l = 0;
    int r = v.size();
    while(l<r){
        if(v[l] == l+1){
            l++;
        }else if(v[l] <= l || v[l] > r || v[v[l]-l] == v[l]){
            v[l] = v[--r];
        }else{
            swap(v[l],v[v[l]-l]);
        }
    }
    return l+1;
}
int main() {
    vector<int> v1 = {-1,2,3,4};
    vector<int> v2 = {1,2,3,4};
    cout<<missNum(v1)<<endl;
    cout<<missNum(v2)<<endl;
    return 0;
}
```

## 数组排序之后相邻数字的最大差值
![2017-03-21_213346.png](2017-03-21_213346.png)

![2017-03-21_213648.png](2017-03-21_213648.png)
```C++
#include <iostream>
#include <vector>
#include <limits>
using namespace std;
// 计算数num应该放入哪个桶里面
int bucket(long num,long len,long min,long max){
    return (int) ( (num-min)*len/(max-min) );
}
int maxGap(vector<int> v){
    if(v.empty() || v.size() < 2) return 0;
    int len = v.size();
    int minValue = INT32_MAX;
    int maxValue = INT32_MIN;
    for(int i=0;i<len;++i){
        minValue = min(minValue,v[i]);
        maxValue = max(maxValue,v[i]);
    }
    if(minValue == maxValue)  return 0; //如果数组的最大值==最小值，说明只有一种元素，那间隔为0
    vector<bool> hasNum(len+1,0);
    vector<int> maxes(len+1,0);
    vector<int> mines(len+1,0);
    int bid = 0;
    for(int i=0;i<len;++i){
        bid = bucket(v[i],len,minValue,maxValue);
        mines[bid] = hasNum[bid] ? min(mines[bid],v[i]) : v[i];
        maxes[bid] = hasNum[bid] ? max(maxes[bid],v[i]) : v[i];
        hasNum[bid] = true;
    }
    int res = 0;
    int lastMax = 0;
    int i = 0;
    while(i<=len){
        if(hasNum[i++]){
            lastMax = maxes[i-1];
            break;
        }
    }
    for(;i<=len;i++){
        if(hasNum[i]){
            res = max(res,mines[i]-lastMax);
            lastMax = maxes[i];
        }
    }
    return res;
}
void print(vector<bool> v){
    for(auto a:v){
        cout<<a<<" ";
    }
    cout<<endl;
}
int main() {
    vector<int> v = {9,3,1,10};
    cout<<maxGap(v)<<endl;
    return 0;
}
```

## 找到出现50%以上的数字
思路就是每次删除两个不同的数字，那么最后一定会剩下那个出现次数大于一半的数字。
```C++
/*
 * 选出数组中出现次数大于一半的数
 */
int majorityElement(vector<int>& nums)
    {
        int cand = -1;
        int count = 0;

        int len = nums.size();
        for (int i = 0; i < len; i++)
        {
            if (count == 0)
            {
                count = 1;
                cand = nums[i];
            }
            else if (nums[i] == cand) count++;
            else count--;
        }
        int times = 0;
        for(int i=0;i<len;i++){
            if(nums[i] == cand){
                times ++;
            }
        }
        if(times > len /2){return cand;}

        return 0;
    }
```
## 找到出现次数在N/K次以上的数字
每次删除数组中K个不同的数字。
```C++
/**
 * 每次删除数组中K个不同的数字，返回剩下的数字
 * @return
 */
vector<int> deleteK(vector<int> v,int k){
    vector<int> result;
    map<int,int> record; // key : cands  value: times
    for(int i=0;i<v.size();++i){
        if(record.find(v[i]) != record.end()){
            record[v[i]] ++;
        }
        else if(record.size() == k-1){
            //所有候选减1，并把是0的删除
            for(auto aa : record){
                aa.second--;
                if(aa.second == 0){
                    record.erase(aa.first);
                }
            }
        }
        else{
            record[v[i]] = 1;
        }
    }
    for(auto ss : record){
        cout<<ss.first<<" "<<ss.second<<endl;
    }
    return result;
}
```
## 求直方图的最大连续面积
题目：给定一个正整数数组arr,把每个数字看作直方图的高，宽度都是1，返回连续的最大面积。
例如，arr = [2,3,4,2,7,8,4]  返回 17  ，7和8组成的面积是14，最大。
```C++
#include <iostream>
#include <vector>
#include <string>
#include <stack>
#include <algorithm>

using namespace std;
/**
 * 直方图求面积的题
 * @return
 */
int main() {
    vector<int> v={3,4,5,4,3,6};
    stack<int> s;
    vector<int> result;
    for(int i=0;i<v.size();++i){
        if(s.empty()||v[s.top()]<v[i]){
            s.push(i);
        }
        else{

            while( !s.empty() &&v[s.top()]>=v[i]){
                int j = s.top();
                s.pop();
                int k = s.empty()?-1:s.top();
                int area = (i-k-1)*v[j];
                result.insert(result.end(),area);
            }
            s.push(i);
        }
    }
    for(auto i:result){
        cout<<i<<endl;
    }
    auto a=max(result.begin(),result.end());

    return 0;
}


#include <iostream>
#include <vector>
#include <stack>
/**
Largest Rectangle in Histogram
*/
using namespace std;

class Solution{
public:
    int largestRetangleArea(vector<int> &height){
        stack<int> s;
        height.push_back(0);
        int result = 0;
        for(int i=0;i<height.size();){
            if(s.empty() || height[i]>height[s.top()]){
                s.push(i++);
            }
            else{
                int tmp = s.top();
                s.pop();
                result = max(result,height[tmp]*(s.empty()?i:1 -s.top()-1));
            }
        }
        return result;
    }
};
int main()
{
    vector<int> a = {1,2,3,4,5,6};
    Solution s;
    cout<<s.largestRetangleArea(a)<<endl;
    return 0;
}
#include <iostream>
#include <vector>
#include <stack>
/**
Largest Rectangle in Histogram
*/
using namespace std;

class Solution{
public:
    int largestRetangleArea(vector<int> &height){
        stack<int> s;
        height.push_back(0);
        int result = 0;
        for(int i=0;i<height.size();){
            if(s.empty() || height[i]>height[s.top()]){
                s.push(i++);
            }
            else{
                int tmp = s.top();
                s.pop();
                result = max(result,height[tmp]*(s.empty()?i:1 -s.top()-1));
            }
        }
        return result;
    }
};
int main()
{
    vector<int> a = {1,2,3,4,5,6};
    Solution s;
    cout<<s.largestRetangleArea(a)<<endl;
    return 0;
}


```

## 换钱的最少货币数量
![2017-03-22_102806.png](2017-03-22_102806.png)
![2017-03-22_102836.png](2017-03-22_102836.png)
原问题和补充问题都可以用动态规划做。
原问题的dp[i][j]表示 在可以任意使用arr[0...i]货币的情况下，做成面值j需要
的最小货币数量

补充问题的dp[i][j]表示，在可以任意使用arr[0...i]的情况下，组成面值j所需要的
最小张数，注意这里的每个数字仅代表一张，不能重复使用。
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
/**
 *给定数组arr, 整数aim arr中的整数不重复，每个数字代表一种面值的货币，求组成aim的最少张数
 * e.g. arr=[5,2,3] aim = 20  输出 4
 * arr=[3,5] aim=2  找不开的情况输出-1
 * @param v
 * @param aim
 * @return
 */
 int getMin(vector<int> v, int aim){
    vector<vector<int> > dp(v.size(),vector<int>(aim+1));
    //初始化第一列
    for(int i=0;i<v.size();++i){
        dp[i][0] = 0;
    }
    //初始化第一行,不能找开的情况设置为1000,只要这个数是整数并且足够大就可以。
    for(int j=1;j<=aim;++j){
        dp[0][j] = j%v[0]==0 ? j / v[0] : 1000;
    }
    for(int i=1;i<v.size();++i){
        for(int j=1;j<=aim;++j){
            if(dp[i][j-v[i]]<0 && dp[i-1][j]){
                dp[i][j] = 1000;
            }
            else if(dp[i][j-v[i]]<0) {
                dp[i][j] = dp[i - 1][j];
            }
            else{
                dp[i][j] = min(dp[i - 1][j], dp[i][j - v[i]] + 1);
            }
        }
    }
    //输出动态规划表格
    for(int i=0;i<dp.size();++i){
        for(int j=0;j<dp[0].size();++j){
            cout<<dp[i][j]<<"\t";
        }
        cout<<endl;
    }
    return dp[v.size()-1][aim];
}
int main() {
    vector<int> v = {5,2,3};
    int aim = 8;
    std::cout <<getMin(v,aim)<< std::endl;
    return 0;
}



#include <iostream>
#include <vector>
using namespace std;
/**
 * 给定整数数组arr 和 整数aim arr中的数字可以重复，每个数字代表一张相应面额的货币，
 * 求组成aim的最少张数
 * e.g. arr=[5,2,3] aim=20 无法组成
 * arr = [5,2,5,3] aim = 10 输出2
 * arr = [5,2,5,3] aim = 0  输出0
 * @param v
 * @param aim
 * @return
 */
int getMin(vector<int> v,int aim){
    vector<vector<int> > dp(v.size(),vector<int>(aim+1));
    //初始化第一列
    for(int i=0;i<v.size();++i){
        dp[i][0] = 0; //组成0需要任何货币0张就够了
    }
    //初始化第一行
    for(int j=1;j<=aim;++j){
        // 除了能组成和v[0]一样面值的货币，其他的都无法组成，因为v[0]只有一张
        dp[0][j] = j == v[0] ? 1 : 10000;
    }
    for(int i=1;i<v.size();++i){
        for(int j=1;j<=aim;++j){
            if(dp[i-1][j-v[i]]<0){
                dp[i][j] = dp[i-1][j];
            }
            else{
                dp[i][j] = min(dp[i-1][j],dp[i-1][j-v[i]]+1);
            }
        }
    }
    // 打印动态规划表格
    for(int i=0;i<dp.size();++i){
        for(int j=0;j<dp[0].size();++j){
            cout<<dp[i][j]<<"\t";
        }
        cout<<endl;
    }
    return dp[v.size()-1][aim];
}
int main() {
    vector<int> v = {5,2,5,3};
    int aim = 7;

    std::cout << getMin(v,aim)<< std::endl;
    return 0;
}
```

## 换钱的方法数
![2017-03-22_105837.png](2017-03-22_105837.png)
使用动态规划的方法，dp[i][j]表示在使用arr[0...i]货币的情况下，组成j有多少中情况。
```C++
#include <iostream>
#include <vector>

using namespace std;

int getNum(vector<int> v,int aim){
    vector<vector<int> > dp(v.size(),vector<int>(aim+1));
    //初始化第一列
    for(int i=0;i<v.size();++i){
        dp[i][0] = 1;
    }
    //初始化第一行
    for(int j=1;j<=aim;j++){
        dp[0][j] = j%v[0]==0 ? 1 : 0;
    }
    for(int i=1;i<v.size();++i){
        for(int j=1;j<=aim;++j){
            dp[i][j] = j-v[i]>=0 ? dp[i-1][j]+dp[i][j-v[i]] : dp[i-1][j];
        }
    }
    //打印动态规划表格
    for(int i=0;i<dp.size();++i){
        for(int j=0;j<dp[0].size();++j){
            cout<<dp[i][j]<<"\t";
        }
        cout<<endl;
    }
    return dp[v.size()-1][aim];
}
int main() {
    vector<int> v = {5,2,3,7};
    int aim = 7;
    std::cout << getNum(v,aim) << std::endl;
    return 0;
}
```

## 判断字符数组中是否所有的字符都只出现一次
![2017-03-22_111143.png](2017-03-22_111143.png)

- 使用哈希表统计字符个数即可
- 第二个要求，使用非递归的方式实现堆排序，然后统计相邻的字符是否重复就可以了。

## 数组中两个字符串的最小距离
![2017-03-22_112158.png](2017-03-22_112158.png)
![2017-03-22_112307.png](2017-03-22_112307.png)
![2017-03-22_134025.png](2017-03-22_134025.png)

## 找到最长回文子串
![2017-03-22_141453.png](2017-03-22_141453.png)
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=631401164&auto=1&height=430"></iframe>


## 统计数组中每个数字前面比自己小的数字有多少个
保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1]   输出：[0,1,1,2,2,1,0]
```C++
#include <iostream>
#include <vector>
using namespace std;
class Node
{
public:
    Node(int _start, int _end) :
            start(_start), end(_end), left(nullptr), right(nullptr),
            cnt(0) {}

    int start, end;
    Node *left, *right;
    int cnt;
};

class Solution {
public:
    /**
      * @param A: An integer array
      * @return: Count the number of element before this element 'ai' is
      *          smaller than it and return count number array
      */
    vector<int> countOfSmallerNumberII(vector<int> &A) {
        // write your code here
        Node *root = build(0, 20000);
        vector<int> res;

        for (int i = 0; i < A.size(); i++)
        {
            int cnt = query(root, 0, A[i] - 1);
            res.push_back(cnt);
            // 更新计数下标是i的计数
            modify(root, A[i]);
        }

        return res;
    }
private:
    Node *build(int start, int end)
    {
        if (start > end)
        {
            return NULL;
        }
        if (start == end)
        {
            return new Node(start, end);
        }

        int mid = start + ((end - start) >> 1);

        Node *root = new Node(start, end);
        root->left = build(start, mid);
        root->right = build(mid + 1, end);

        return root;
    }

    void modify(Node *root, int idx){
        if (root == NULL)
        {
            return;
        }

        if (root->start == root->end && root->start == idx)
        {
            ++(root->cnt);
            return;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= idx)
        {
            modify(root->left, idx);
        }
        else
        {
            modify(root->right, idx);
        }

        root->cnt = root->left->cnt + (root->right ? root->right->cnt : 0);
    }

    int query(Node *root, int start, int end)
    {
        if (root->end < start || root->start > end)
        {
            return 0;
        }
        if (root->start >= start && root->end <= end)
        {
            return root->cnt;
        }

        int mid = root->start + ((root->end - root->start) >> 1);
        if (mid >= end)
        {
            return query(root->left, start, end);
        }
        if (mid < start)
        {
            return query(root->right, start, end);
        }

        int leftRes = query(root->left, start, mid);
        int rightRes = query(root->right, mid + 1, end);

        return leftRes + rightRes;
    }
};

int main() {
    vector<int> v = {2,7,4,6,5,3,1};
    Solution s;
    auto re = s.countOfSmallerNumberII(v);
    return 0;
}
```
## 统计数组中每个数字后面比自己小的数字有多少个
保证都是正整数，没有重复的数字，例如输入 [2,7,4,6,5,3,1]   输出：[1,5,2,3,2,1,0]

这个可以调用上面的函数实现
```C++
 vector<int> countOfSmallerNumberBack(vector<int> &A){
        vector<int> tmp(A);
        int len = A.size();
        for(int i=0;i<len;i++){
            tmp[i] = A[len-1-i];
        }
        vector<int> re = countOfSmallerNumberII(tmp);
        vector<int> result(re);
        for(int i=0;i<len;i++){
            result[i] = re[len-1-i];
        }
        return result;
    }
```
# 一个有重复数字的整数数组，求包含所有的数字的最短的连续序列的长度
```C++
int getMinUnique(vector<int> v){
    int len = v.size();
    //统计独立的数字的个数
    set<int> se;
    for(int i=0;i<v.size();i++){
        se.insert(v[i]);

    }
    int ulen = se.size();

    int s = 0;
    int t = 0;
    int num = 0;
    map<int,int> count;
    int res = len; // 存放结果，最坏的情况下是数组的长度，结果肯定不会大于这个值
    for(;;){
        while(t<len && num <ulen){
            if(count[v[t++]]++ == 0){
                num ++;
            }
        }
        if(num < ulen) break;
        res = min(res,t-s);
        if(--count[v[s++]] == 0){
            num--;
        }
    }
    return res;

}
```
