---
title: 两个数组的相关问题
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-03-21 09:31:12
---
主要是关于两个数组，两个字符串的相关问题。
<!--more -->

## 最长公共子序列
![2017-03-21_093231.png](2017-03-21_093231.png]
解法: 动态规划。设str1的长度是M,str2的长度是N，生成M*N的矩阵dp.
dp[i][j]的含义是str[0...i]与str[0...j]最长公共子序列的长度。
时间复杂度O(M*N),空间复杂度（M*N）
```C++
#include <iostream>
#include <vector>
#include <string>

using namespace std;
string getMaxlength(string s1,string s2){
    string result;
    vector<vector<int> > dp(s1.size(),vector<int>(s2.size()));
    // 初始化第一列
    int label = -1;
    for(int i=0;i<s1.size();++i){
        if(s1[i] == s2[0]){
            label = i;
        }
    }
    //如果s1中含有s2的第一个字符，则这个字符和之后的所有位置都赋值为1，之前的都赋值为0
    if(label == -1){
        for(int i=0;i<s1.size();++i){
            dp[i][0] = 0;
        }
    }
    else{
        for(int i=0;i<label;++i){
            dp[i][0] = 0;
        }
        for(int i=label;i<s1.size();++i){
            dp[i][0] = 1;
        }
    }
    //初始化第一行
    int labels2 = -1;
    for(int j=0;j<s2.size();++j){
        if(s2[j] == s1[0]){
            labels2 = j;
        }
    }
    //如果s1中含有s2的第一个字符，则这个字符和之后的所有位置都赋值为1，之前的都赋值为0
    if(labels2 == -1){
        for(int j=0;j<s2.size();++j){
            dp[0][j] = 0;
        }
    }
    else{
        for(int j=0;j<labels2;++j){
            dp[0][j] = 0;
        }
        for(int j=labels2;j<s2.size();++j){
            dp[0][j] = 1;
        }
    }
    //动态规划的递推公式
    for(int i=1;i<s1.size();++i){
        for(int j=1;j<s2.size();++j){
            dp[i][j] = max(dp[i-1][j],dp[i][j-1]);
            if(s1[i] == s2[j]){
                dp[i][j] = max(dp[i][j],dp[i-1][j-1]+1);
            }
        }
    }
    //输出动态规划表格
    for(int i=0;i<dp.size();++i){
        for(int j=0;j<dp[0].size();++j){
            cout<<dp[i][j]<<" ";
        }
        cout<<endl;
    }
    //根据动态规划表格找出答案

    return result;
}
int main() {
    string s1 = "2bcd";
    string s2 = "a2ed";
    std::cout <<getMaxlength(s1,s2) << std::endl;
    return 0;
}
```

## 最长公共子串问题
![2017-03-21_093641.png](2017-03-21_093641.png)
解法：还是动态规划方法。不过要比上面的简单。因为子串都是连续的，比子序列要少。
生成dp。dp[i][j] 的含义是必须把str1[i]和str2[j]作为最后一个字符的情况下，公共子串最长
的长度。
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
/**
 * 两个字符串的最长公共子串
 * @param s1
 * @param s2
 * @return
 */
string getMaxC(string s1,string s2){
    string result;
    vector<vector<int>> dp(s1.size(),vector<int>(s2.size()));
    //初始化第一列
    for(int i=0;i<s1.size();++i){
        dp[i][0] = s1[i] == s2[0] ? 1 : 0;
    }
    //初始化第一行
    for(int j=0;j<s2.size();++j){
        dp[0][j] = s2[j] == s1[0] ? 1 : 0;
    }
    //动态规划迭代
    for(int i=1;i<s1.size();++i){
        for(int j=1;j<s2.size();++j){
            if(s1[i] == s2[j]){
                dp[i][j] = dp[i-1][j-1]+1;
            }
            else{
                dp[i][j] = 0;
            }
        }
    }
    //因为该动态规划过程每次值用到了左上角的内容，所以我们可以改进动态规划表格
    //减少占用的空间


    //输出动态规划表
    for(int i=0;i<dp.size();++i){
        for(int j=0;j<dp[0].size();++j){
            cout<<dp[i][j]<<" ";
        }
        cout<<endl;
    }
    return result;
}
int main() {
    string s1 = "1ab2345cd";
    string s2 = "12345ef";
    getMaxC(s1,s2);
    return 0;
}
```
## 最小的编辑代价
![2017-03-21_094030.png](2017-03-21_094030.png)
解法：动态规划，dp[i][j]的值代表把str1[0...i-1]编辑成[str2[0..j-1]
的最小的代价。注意这里生成的是M+1，N+1的dp矩阵，第一行和第一列都是空字符，
用来表示全部添加或者全部删除。
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
/**
 * 最小编辑代价
 * @param a
 * @param b
 * @param ic
 * @param dc
 * @param rc
 * @return
 */
int getMin(string a,string b,int ic,int dc,int rc){
    //如果先删除在插入的代价小于直接替换的代价，那么就永远不使用直接替换
    if(dc+ic<=rc){rc = dc+ic;}
    int result = 0;
    vector<vector<int>> dp(a.size()+1,vector<int>(b.size()+1));
    //初始化第一列，把a[i]编辑成空串的代价
    //要把a[i]编辑成空串只有一种方法，就是把所有的字符都删除
    for(int i=0;i<=a.size();++i){
        dp[i][0] = dc*i;
    }
    //初始化第一行，把空串编辑成b[j]的方法也只有一种，就是插入相应的字符
    for(int j=1;j<=b.size();++j){
        dp[0][j] = ic*j;
    }
    //动态规划的递推公式
    for(int i=1;i<=a.size();++i){
        for(int j=1;j<=b.size();++j){
            dp[i][j] = min(dp[i-1][j]+dc,dp[i][j-1]+ic);
            if(a[i-1] == b[j-1]){
                dp[i][j] = min(dp[i][j],dp[i-1][j-1]);
            }
            else{
                dp[i][j] = min(dp[i][j],dp[i-1][j-1]+rc);
            }
        }
    }
    //输出动态规划表
    for(auto row : dp){
        for(auto cow : row){
            cout<<cow<<"\t";
        }
        cout<<endl;
    }

    return  dp[a.size()][b.size()];
}
int main() {
    string a = "ab12cd3";
    string b = "abcdf";
    int ic = 5; int dc = 3; int rc = 2;
    std::cout << getMin(a,b,ic,dc,rc) << std::endl;
    return 0;
}
```
## 字符串的交错组成
![2017-03-21_094649.png](2017-03-21_094649.png)
解法： 动态规划，生成M+1，N+1的dp矩阵，dp[i][j]表示aim[0,i+j-1]
能否被str1[0...i-1]和str2[0...j-1]交错组成。注意第一行和第一列都是空串。
aim[-1]表示aim为空串的时候。str1[-1],str2[-1]都表示是空串的时候。
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
/**
 * 字符串的交错组成
 * 判断aim能够由str1  and str2 交错组成
 * @param s1
 * @param s2
 * @param aim
 * @return
 */
bool isCom(string s1,string s2,string aim){
    //先从长度判断
    if(s1.size() + s2.size() != aim.size()){return false;}
    vector<vector<bool>> dp(s1.size()+1,vector<bool>(s2.size()+1));
    //空串可以被空串交错组成
    dp[0][0] = true;
    //初始化第一列
    for(int i=1;i<=s1.size();++i){
        if(s1[i-1] != aim[i-1]){break;}
        dp[i][0] = true;
    }
    //初始化第一行
    for(int j=1;j<s2.size();++j){
        if(s2[j-1] != aim[j-1]){break;}
        dp[0][j] = true;
    }

    for(int i=1;i<=s1.size();++i){
        for(int j=1;j<=s2.size();++j){
            if(s1[i-1] == aim[i+j-1] && dp[i-1][j]
                    || s2[j-1] == aim[i+j-1] && dp[i][j-1]){
                dp[i][j] = true;
            }
        }
    }
    //输出dp数组
    for(auto i:dp){
        for(auto j:i){
            cout<<j<<" ";
        }
        cout<<endl;
    }
    return dp[s1.size()][s2.size()];
}
int main() {
    string s1 = "ABC";
    string s2 = "123";
    string aim = "12AA3C";
    auto result = isCom(s1,s2,aim);
    cout<<result;
    return 0;
}
```

## 判断两个字符串是否互为旋转词
![2017-03-22_110804.png](2017-03-22_110804.png)
思路： 将其中一个字符串复制一份，拼接在后面，然后在这个长字符串中查找另外一个短的有没有出现。
例如判断a,b字符串，只需要find(a,b+b)!=(b+b).end() 就是旋转词，否则就不是。
```C++

```

## 