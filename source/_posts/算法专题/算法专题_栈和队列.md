---
title: 数据结构_栈和队列
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-12 10:07:18
---

栈是一种实现了后进先出的规则的数据结构。C++里面有实现`stack`.使用的时候`include <stack>`,支持的操作有push,pop,top;需要注意的是，pop的作用是弹出栈顶元素，而不会返回栈顶元素，实现返回栈顶元素并弹出的操作应该是`int a = s.top(); s.pop();`.

队列是一种先进先出的数据结构。C++里面有实现`deque`.使用的时候`include<deque>`, 支持从两端压入元素和从两端取出元素。

<!-- more -->

## 带有getMin()的栈


实现一个可以在O(1)时间内得到最小值的栈结构。支持`pop(),push(),top(),getMin()`四种操作。

**思路**  使用两个栈来模拟这个栈，一个栈用来保存实际的数据，一个栈用来保存对应数据的最小值。每次入栈和出栈操作的时候，判断最小值有没有发生变化，如果没有发生变化，直接弹出数据，如果发生了变化，更新存储最大值最小值的栈。

```c
class StackWithGetMin2{
public:
    stack<int> data;
    stack<int> min_data;
    void push(int val){
        data.push(val);
        if(!min_data.empty()){
            if(min_data.top()>=val){
                min_data.push(val);
            }
        }
        else{
           min_data.push(val);
       }
    }
    int pop(){
        auto v = data.top();
        if(v > min_data.top()){
            data.pop();
            return v;
        }else{
            data.pop();
            min_data.pop();
            return v;
        }
    }
    int getMin(){
      if(min_data.empty){throw new exception;}
      else{
         return min_data.top();
      }
    }
    int top(){
        return data.top();
    }
};
```

## 用一个栈排序另外一个栈

要求排序好的数据就在原来的栈里面。

**思路**  设存放数据的栈是`s`, 辅助排序的栈是`help`,一个临时变量`v`用来暂存从栈里面出来的数据。我们只要确保把`s`中的数有序的入栈`help`,然后在反向从`help`压入`s`就能得到需要的结果。如果要求从大到小排序，即`s`栈顶的元素是最大的，那么`help`中就应该是从小到大排序,栈顶的元素是最小的。每次从`s`向`help`移动数据的时候，都要和`help`的栈顶比较，如果小于栈顶的元素，直接入栈，如果大于栈顶的元素，把栈顶元素入栈到`s`,直到`v`中的数小于`help`的栈顶元素，才将`v`入栈到`help`,其实这有点向汉诺塔问题，循环利用两个栈做中转，只不过更加简单。

```c
void sortStack(stack<int> s){
    stack<int> help;
    help.push( s.top() );
    s.pop();
    auto v = s.top();
    if(help.top()>v){
        help.push(v);
        s.pop();
    }
    else{
        while(help.top()<=v){
            auto temp = help.top();
            help.pop();
            s.push(temp);
        }
        help.push(v);
    }

}
```
## 栈的压入、弹出序列
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列`1,2,3,4,5`是某栈的压入顺序，序列`4,5,3,2,1`是该压栈序列对应的一个弹出序列,`4,3,5,1,2`就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）

**思路**  设压入序列是`pushV`,弹出序列是`popV`,从`pushV`中找到第一个和`popV`首元素相同的元素，假设是`a`,可以知道`a`必定是压入栈之后就被弹出来了。假设用一个临时的栈`s1`保`a`之前入栈的元素和`a`,那么此时`popV`和`s1`的栈顶元素应该是一致的。 接下来，遍历`popV`中的元素，与`s1`中的元素比较，如果相等，弹出该元素,`popV`的指针加1,继续下一次比较.如果不相等,就把`pushV`中`a`后面的元素继续入栈到`s1`,`popV`的指针不动，继续比较`popV`和当前`s1`的栈顶元素是不是相等。按照这样的规则处理，直到指针走到尽头，看`s1`中的元素是否非空，如果是空的，`popV`就是`pushV`的弹出序列。

```c
bool IsPopOrder(vector<int> pushV,vector<int> popV) {
       if(pushV.size() != popV.size()) return false;
       stack<int> s1;
       //找到第一个相同的元素
       size_t i = 0;
       while(pushV[i] != popV[0] && i<pushV.size()){
           s1.push(pushV[i]);
           i++;
       }
       s1.push(pushV[i]); //此时是s1栈顶和popV的第一个元素相同；
       i++;//i指向下一元素；
       for(size_t j=0;j<=popV.size();j++){
           if( j<popV.size() && popV[j] == s1.top() ){
              s1.pop();
           }else if(i<pushV.size()){
               s1.push(pushV[i]);
               j--;
               i++;
           }else if( j== popV.size() && s1.empty()){
               return true;
           }else{
               return false;
           }
       }
       return false;
   }
```
