---
title: 算法专题_八大排序算法
toc: true
categories:
  - 算法
tags:
  - ACM
date: 2017-04-16 19:31:24
---
排序算法，是将无序数据变为有序的一种算法。通常分为内部排序和外部排序。内部排序是指所有待排序的数据都在内存中，都可以直接访问得到。 外部排序是指数据存储在外部，通常都涉及大量的数据的排序问题，这里我们先不讨论。本文主要介绍主要的内部排序算法。
<!-- more -->
内部排序按照算法思想的不同，可以分为以下几种类型：
> - 插入排序
> - 选择排序
> - 交换排序
> - 归并排序
> - 基数排序

## 比较排序
如果排序算法中元素的顺序的确定依赖元素之间的比较，那么这类排序算法称作比较排序。

插入排序


插入排序的思想是将一个元素插入到一个已经排序好的序列中，在插入的时候逐个比较带插入元素和有序的序列，找到新插入元素的合适位置，插入到序列中。

### 直接插入排序
最简单的插入排序，直接使用插入排序的思想而没有经过任何的优化过程。
![](2017-04-16_193954.png)
```c
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
void print(vector<int> v,int i){
    int count = 0;
    for(auto a : v){
        if(count == i){
            cout<<" : ";
        }
        cout<<a<<" ";
        count ++;
    }
    cout<<endl;
}
vector<int> SimpleInsertSort(vector<int> &a)
{
    int n = a.size();
    // 每次循环，都假设i前面的数字已经排序好了，i是要插入到已排序序列的数字，i之后的数字都是未排序的。
    for(int i = 1; i<n; i++){
        // 打印当前的状态
        print(a,i);
        // 找到当前数字i应当插入的位置
        int curValue = a[i];
        int ii = i;
        if(a[ii]<a[0]){
            //应当插入首位
            while(ii-1>=0){
                a[ii] = a[ii-1];
                ii--;
            }
            a[0] = curValue;
        }else if(a[ii]>=a[ii-1]){
            //应当插入末尾
            continue; //如果应该插入的位置是有序列表的末尾，则什么都不用做。
        }else{
            for(int j=0;j<ii-1;j++){
                if(a[ii]>=a[j] && a[ii]<a[j+1]){
                    //应当插入j之后
                    while(ii-1>j){
                        a[ii] = a[ii-1];
                        ii--;
                    }
                    a[ii] = curValue;
                }
            }
        }
    }
    print(a,a.size());
    return  a;
}
int main() {
    vector<int> v = {49,38,65,97,76,13,27,49};
    auto re = SimpleInsertSort(v);
    return 0;
}
```
运行结果：
```c
49  : 38 65 97 76 13 27 49
38 49  : 65 97 76 13 27 49
38 49 65  : 97 76 13 27 49
38 49 65 97  : 76 13 27 49
38 49 65 76 97  : 13 27 49
13 38 49 65 76 97  : 27 49
13 27 38 49 65 76 97  : 49
13 27 38 49 49 65 76 97
```
简单插入排序的时间复杂度是`o(n^2)`;

### 折半插入排序(二分插入排序)
简单插入排序没有经过任何的过程优化，我们仔细分析简单插入排序的过程，寻找元素应该插入的位置这一过程是可以优化的。因为是在有序序列中查找，所以可以使用二分查找方法缩短查找的时间。该方法被叫做二分插入排序。
STL中`lower_bound(a.begin(),a.end()+ii,a[i]);`实现了二分查找算法，我们直接使用它替换原来的循环语句查找出插入位置即可。
```c
//使用二分查找方法搜索应该插入的位置，此方法叫做二分插入排序
//            for(int j=0;j<ii-1;j++){
//                if(a[ii]>=a[j] && a[ii]<a[j+1]){
//                    //应当插入j之后
//                    while(ii-1>j){
//                        a[ii] = a[ii-1];
//                        ii--;
//                    }
//                    a[ii] = curValue;
//                }
//            }
auto index = lower_bound(a.begin(),a.begin()+ii,a[ii]);
//应当插入j之后的位置
int j = distance(a.begin(),index)-1;
while(ii-1>j){
        a[ii] = a[ii-1];
        ii--;
}
a[ii] = curValue;
```
### 二路插入排序

### 缩小增量排序（希尔排序）

### 简单选择排序
在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。


### 二元选择排序
简单选择排序，每趟循环只能确定一个元素排序后的定位。我们可以考虑改进为每趟循环确定两个元素（当前趟最大和最小记录）的位置,从而减少排序所需的循环次数。改进后对n个数据进行排序，最多只需进行[n/2]趟循环即可。


### 堆排序
堆排序就是使用堆维护数据的有序结构，主要的问题是的建堆的操作和堆调整的操作。

交换排序

### 冒泡排序
冒泡排序总是交换相邻的两个值。

在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。
```c
void print(vector<int> v,int i){
    int count = 0;
    for(auto a : v){
        if(count == i){
            cout<<" | ";
        }
        cout<<a<<" ";
        count ++;
    }
    cout<<endl;
}

//冒泡排序
vector<int> sortTop(vector<int> &v){
    int tmp;
    for(int j=v.size()-1;j>0;j--){
        print(v,j+1);
        for(int i=0;i<j;i++){
            if(v[i+1] < v[i]){
                tmp = v[i];
                v[i] = v[i+1];
                v[i+1] = tmp;
            }
        }
    }
    return v;
}

int main() {
    vector<int> v = {49,38,65,97,76,13,27,12};
    auto a = sortTop(v);
    print(a);
    return 0;
}
```
运行结果：
```c
49 38 65 97 76 13 27 12
38 49 65 76 13 27 12  | 97
38 49 65 13 27 12  | 76 97
38 49 13 27 12  | 65 76 97
38 13 27 12  | 49 65 76 97
13 27 12  | 38 49 65 76 97
13 12  | 27 38 49 65 76 97
12 13 27 38 49 65 76 97  |
```
### 快速排序
快速排序也属于交换排序，不同的是，它并非交换相邻的元素，而是用基准元素来作为衡量标准。

![](2017-04-17_182740.png)
快速排序的基本思想是每次选择一个基准元素，调整数组，使得所有比基准元素小的元素都位于左边，所有比基准元素大的元素都位于基准元素的右边，从而使得基准元素放在了正确的位置上。然后以基准元素为准，把数组分成两个部分，递归的应用上面的方法，得到最终的结果。所以，快速排序的实现也有递归的版本和非递归的版本。一般使用递归的版本就够了。
```c
void print(vector<int> v,int i){
    int count = 0;
    for(auto a : v){
        if(count == i){
            cout<<"[";
            cout<<a;
            cout<<"]";
        }else{
            cout<<a<<" ";
        }
        count ++;
    }
    cout<<endl;
}

void quickSort(vector<int> &v,int i,int j){
    if(i >= j) return ;
    int tmp;
    int start = i;
    int end = j;
    bool base = true; // 指示 i 是否指向base 元素，如果i 不指向base元素，则j肯定指向base元素。
    print(v,i);
    while(i < j){
        //打印数组，可视化排序过程
        if(v[i] > v[j] && base){
            tmp = v[j];
            v[j] = v[i];
            v[i] = tmp;
            i = i + 1;
            base = false;
        }else if(v[i] > v[j] && !base){
            tmp = v[j];
            v[j] = v[i];
            v[i] = tmp;
            j = j - 1;
            base = true;
        }else if(base){
            j--;
        }else{
            i++;
        }
    }
    print(v,i);
    // 循环结束的时候i == j
    quickSort(v,start,i-1);
    quickSort(v,i+1,end);
}
```

### 归并排序
归并排序是分治法思想的典型应用。归并排序要处理好两件事，划分和合并。划分就是将待排序序列划分成子序列。合并就是如何将两个有序的子序列合并为一个有序的子序列。
归并的排序的思想是：首先把原来序列划分成n个子序列，每个子序列一个元素，这样每个子序列都可以看作是有序的。然后分别合并相邻的两个子序列，使合并之后的序列保持有序。这样，一趟归并之后子序列减少二分之一，直到最后归并为一个序列为止。

归并排序中最重要的操作是如何将两个有序的序列合并为一个有序的序列。
![](2017-04-16_213443.png)
这里合并两个有序序列的方法可以自己设计，我们使用逐个元素比较的方法，时间复杂度是`O(a1+a2)`.
```c
void print(vector<int> v){
    for(auto a:v){
        cout<<a<<" ";
    }
    cout<<" | ";
}

//合并两个有序的数组,返回新的有序的数组
vector<int> merge(vector<int> &v1,vector<int> &v2){
    vector<int> re;
    size_t i=0,j=0;
    while(i<v1.size() && j<v2.size()){
        if(v1[i] <= v2[j]){
            re.push_back(v1[i]);
            i++;
        }else{
            re.push_back(v2[j]);
            j++;
        }
    }
    //把剩下的放在最后
    for(size_t a = i;a<v1.size();a++){
        re.push_back(v1[a]);
    }
    for(size_t a=j;a<v2.size();a++){
        re.push_back(v2[a]);
    }
    return re;
}

//归并排序的非递归实现
vector<int> mergeSort2(vector<int> &v){
    vector<vector<int>> group;
    // 一开始，每一个元素单独为一组，然后一步一步的合并相邻的组，直到最后只剩下一组。
    for(int i=0;i<v.size();i++) {
        group.push_back({v[i]});
    }
    int group_end = group.size(); // 指示结果，每次归并，都是合并相邻的两组数据，所以group的元素个数每次都减少一半，为了减少开销，
    //我们每次合并之后的数组还是放在原来的数组中，用group指示数组的结束。
    //当group_end = 1的时候，所有的数组已经归并到一起了
    while(group_end > 1){
        for(size_t b=0;b<group_end;b++){
            print(group[b]);
        }
        cout<<endl;

        int j = 0;
        while(j+1<group.size()){
            group[j/2]  = merge(group[j],group[j+1]);
            j = j + 2;
        }
        // 个数是奇数的情况
        if(j == group_end -1 ){
            group[ceil(group_end / 2.0)-1] = group[group_end-1];
        }
        group_end = ceil(group_end / 2.0);
    }
    print(group[0]);
    return group[0];
}

int main() {
    vector<int> v = {49,38,65,97,76,13,27};
    auto a = mergeSort2(v);
    return 0;
}
```
运行结果:
```c
49  | 38  | 65  | 97  | 76  | 13  | 27  |
38 49  | 65 97  | 13 76  | 27  |
38 49 65 97  | 13 27 76  |
13 27 38 49 65 76 97  |
```

归并排序的递归实现方法 ：
```c
//  归并排序的递归实现
vector<int> mergeSort(vector<int> &v,int start,int end){
    if(start >= end){
        return {v[start]};
    }
    int mid = (start + end) / 2;
    auto v1 = mergeSort(v,start,mid); // 递归左半部分的排序
    auto v2 = mergeSort(v,mid+1,end); // 递归右半部分的排序
    return merge(v1,v2);
}
```

归并排序是一种稳定的排序（合并两个有序数组的时候是稳定的），所以可以用来求数组的逆序对这样的问题。

归并排序是将数列a[l,h]分成两半a[l,mid]和a[mid+1,h]分别进行归并排序，然后再将这两半合并起来。
在合并的过程中（设`l<=i<=mid，mid+1<=j<=h`），当a[i]<=a[j]时，并不产生逆序数；当a[i]>a[j]时，在
前半部分中比a[i]大的数都比a[j]大，将a[j]放在a[i]前面的话，逆序数要加上`mid-i+1`。因此，可以在归并
排序中的合并过程中计算逆序数.
```c
//合并两个有序的数组,返回新的有序的数组
vector<int> merge(vector<int> &v1,vector<int> &v2,int &cc){
    vector<int> re;
    size_t i=0,j=0;
    while(i<v1.size() && j<v2.size()){
        if(v1[i] <= v2[j]){
            re.push_back(v1[i]);
            i++;
        }else{
            re.push_back(v2[j]);
            cc = cc + v1.size() -  i; //增加统计逆序对的功能，以传递引用的方法返回结果，注意传入的参数的初始值要为0；
            j++;
        }
    }
    //把剩下的放在最后
    for(size_t a = i;a<v1.size();a++){
        re.push_back(v1[a]);
    }
    for(size_t a=j;a<v2.size();a++){
        re.push_back(v2[a]);
    }
    return re;
}

//归并排序的递归实现
vector<int> mergeSort(vector<int> &v,int start,int end,int &cc){
  if(start >= end){
      return {v[start]};
  }
  int mid = (start + end) / 2;
  auto v1 = mergeSort(v,start,mid,cc); // 递归左半部分的排序
  auto v2 = mergeSort(v,mid+1,end,cc); // 递归右半部分的排序
  return merge(v1,v2,cc);
}

//使用的使用定义int cc = 0; 传入函数即可。
```
统计数组的逆序对，还可以使用树状数组，不过就复杂度而言，使用归并排序已经足够了。
## 线性时间排序
比较排序依赖元素之间的比较，所以最优的算法的时间复杂度也不会低于`O(n*logn)`;归并排序，堆排序和快速排序都可以达到这一水平。还有一些不依赖元素之间的比较确定元素顺序的排序算法可以达到更低的时间复杂度。例如：计数排序，基数排序和桶排序。
### 计数排序
计数排序的基本思想是： 开辟一个与最大数的值大小一样的数组，然后把每个数字放到对应的数组中，自然而然就有序了。例如对`[9,23,2,100,34,398,5]`排序，开辟一个a[399]的数组，然后`令a[9] = 1;a[23] = 1;a[2]=1;a[100] = 1; a[34] = 1;a[398] = 1;a[5] = 1`;然后从头开始把有值的元素取出来就自然有了顺序。如果有元素的值相等，例如有2个100，只需要让a[100] = 2就行了。下面看看如何取出排序好的数据。
```c
//计数排序
vector<int> countSort(vector<int> &v){
    //1.找到最大值，开辟数组
    if(v.empty()) return v;
    int maxValue = v[0];
    for(int i=1;i<v.size();i++){
        maxValue = v[i] > maxValue ? v[i] : maxValue;
    }
    //2. 开辟对应的数组并计数
    vector<int> b(maxValue + 1,0);
    for(int i=0;i<v.size();i++){
        b[v[i]] = b[v[i]] + 1;
    }
    //3. 取出结果
    v.clear();
    for(int i=0;i<b.size();i++){
        while(b[i]>0){
            v.push_back(i);
            b[i] = b[i] - 1;
        }
    }
    return v;
}
```
上面的代码只能处理非负数的情况。需要注意的是，计数排序当处理有大量重复数字，而数据的范围不大的时候很有用。
### 基数排序(桶排序)
桶排序是一种时间复杂度可以达到O(n)的排序算法，但是它使用的空间较多，也有较大的限制条件，不适用于所有情况下的排序，只适用特定的情况下的排序。

一种更一般的算法思想是分桶法。它的思想是把元素按照一定的范围分别放在对应的桶中，然后再做相应的处理。分组后处理的复杂度就会降低很多，然后再想办法把每个桶中的结果合并起来。

基数排序专门针对的是整数的排序，（因为字符串也是整数表示的，所以字符串的排序也可以使用桶排序）。这里固定的把桶定为10个，分别对应数字0--9.首先按照个位数字入桶，然后按照十位数字，然后按照百位数字，...直到最高位数字，然后按照顺序取出来就是了。下面以`[521 310 72 373 15 546 385 856 187 147]`为例子说明具体的过程。
![](2017-04-17_200445.png)
```c
// 返回a的第i位数字，
// i = 0 个位
// i = 1 十位
int gg(int a,int i){
    int re;
    while(i>=0){
        re = a % 10;
        a = a / 10;
        i--;
    }
    return re;
}
vector<int> baseSort(vector<int> &v){
    if(v.empty()) return v;
    int maxValue = v[0];
    //找到最大值
    for(int i=0;i<v.size();i++){
        maxValue = v[i] > maxValue ? v[i] : maxValue;
    }
    int high = 0;  // 获得最高位，需要循环这么多次
    while(maxValue){
        maxValue /= 10;
        high ++;
    }
    // i = 0 按照个位入桶，收集
    // i = 1 按照十位入桶，收集
    // ...
    for(int i=0;i<high;i++){
        vector<vector<int>> t(10,vector<int>(0));
        // 入桶操作
        for(int j=0;j<v.size();j++){
            t[ gg(v[j],i) ].push_back(v[j]);
        }
        // 从0号桶开始按照顺序收集
        v.clear();
        for(auto a : t){
            for(auto b : a){
                v.push_back(b);
            }
        }
    }
    return v;
}
```
## 后记
说明：

当原表有序或基本有序时，直接插入排序和冒泡排序将大大减少比较次数和移动记录的次数，时间复杂度可降至O（n）；

而快速排序则相反，当原表基本有序时，将蜕化为冒泡排序，时间复杂度提高为O（n2）；

原表是否有序，对简单选择排序、堆排序、归并排序和基数排序的时间复杂度影响不大。
